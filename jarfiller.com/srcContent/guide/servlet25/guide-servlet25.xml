<?xml version="1.0" encoding="UTF-8"?>
<page xmlns="http://tjansen.de/refPage" 
	xmlns:inc="http://tjansen.de/refPageInclude" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://tjansen.de/refPage ../../../schemas/page.xsd 
	                    http://tjansen.de/refPageInclude ../../../schemas/include.xsd">
	                    
  <path>/guide/servlet25/</path>
  <title>Servlet 2.5 Guide</title>
  <titleIntro>Create Dynamic Web Content with the Servlet API</titleIntro>
  
 
  <license>cc-by-free-src</license>
  
  <multipage/>
  
  <topicConfig>
	<inc:includeContent file="../srcContent/shared/topics.inc.xml"/>
  </topicConfig>
 
   <docConfig>
	<inc:includeContent file="../srcContent/shared/webxmldocs-2.5.inc.xml"/>
  </docConfig> 
  
  <javadocConfig>
	<baseURL>http://java.sun.com/javaee/5/docs/api/</baseURL>
	<defaultPackage>javax.servlet.http</defaultPackage>
	<defaultAnnotationPackage>javax.annotation</defaultAnnotationPackage>
	<shortcuts>
		<shortcut name="javax.servlet.*" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/package-summary.html"/>
		<shortcut name="javax.servlet.http.*" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/package-summary.html"/>
		<shortcut name="java.io.*" uri="http://java.sun.com/javase/6/docs/api/java/io/package-summary.html"/>
		<shortcut name="java.nio.*" uri="http://java.sun.com/javase/6/docs/api/java/nio/package-summary.html"/>
		<shortcut name="java.util.*" uri="http://java.sun.com/javase/6/docs/api/java/util/package-summary.html"/>
		<shortcut name="java.awt.*" uri="http://java.sun.com/javase/6/docs/api/java/awt/package-summary.html"/>
		<shortcut name="java.awt.image.*" uri="http://java.sun.com/javase/6/docs/api/java/awt/image/package-summary.html"/>
		<shortcut name="java.sql.*" uri="http://java.sun.com/javase/6/docs/api/java/sql/package-summary.html"/>
		<shortcut name="javax.sql.*" uri="http://java.sun.com/javase/6/docs/api/javax/sql/package-summary.html"/>
		<shortcut name="javax.naming.*" uri="http://java.sun.com/javase/6/docs/api/javax/naming/package-summary.html"/>
		<shortcut name="javax.annotations.*" uri="http://java.sun.com/javaee/5/docs/api/javax/annotations/package-summary.html"/>
		<shortcut name="javax.imageio.*" uri="http://java.sun.com/javase/6/docs/api/javax/imageio/package-summary.html"/>

		<shortcut name="InitialContext" uri="http://java.sun.com/javase/6/docs/api/javax/naming/InitialContext.html"/>
		<shortcut name="ServletContext" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html"/>
		<shortcut name="ServletConfig" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletConfig.html"/>
		<shortcut name="Servlet" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/Servlet.html"/>
		<shortcut name="ServletException" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletException.html"/>
		<shortcut name="ServletRequest" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html"/>
		<shortcut name="ServletResponse" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletResponse.html"/>
		<shortcut name="UnavailbleException" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/UnavailbleException.html"/>
		<shortcut name="init" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/GenericServlet.html#init(javax.servlet.ServletConfig)"/>
		<shortcut name="service" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServlet.html#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)"/>
		<shortcut name="destroy" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/GenericServlet.html#destroy()"/>
		<shortcut name="doGet" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServlet.html#doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)"/>
		<shortcut name="doPost" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServlet.html#doPost(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)"/>
		<shortcut name="doHead" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServlet.html#doHead(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)"/>
		<shortcut name="getLastModified" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServlet.html#getLastModified(javax.servlet.http.HttpServletRequest)"/> 
		<shortcut name="InputStream" uri="http://java.sun.com/javase/6/docs/api/java/io/InputStream.html"/>
		<shortcut name="OutputStream" uri="http://java.sun.com/javase/6/docs/api/java/io/OutputStream.html"/>
		<shortcut name="File" uri="http://java.sun.com/javase/6/docs/api/java/io/File.html"/>
		<shortcut name="delete" uri="http://java.sun.com/javase/6/docs/api/java/io/File.html#delete()"/>
		<shortcut name="IOException" uri="http://java.sun.com/javase/6/docs/api/java/io/IOException.html"/>
		<shortcut name="setContentType" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletResponse.html#setContentType(java.lang.String)"/>
		<shortcut name="setCharacterEncoding" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletResponse.html#setCharacterEncoding(java.lang.String)"/>
		<shortcut name="PrintWriter" uri="http://java.sun.com/javase/6/docs/api/java/io/PrintWriter.html"/>
		<shortcut name="print" uri="http://java.sun.com/javase/6/docs/api/java/io/PrintWriter.html#print(java.lang.String)"/>
		<shortcut name="println" uri="http://java.sun.com/javase/6/docs/api/java/io/PrintWriter.html#println(java.lang.String)"/>
		<shortcut name="printf" uri="http://java.sun.com/javase/6/docs/api/java/io/PrintWriter.html#printf(java.lang.String, java.lang.Object...)"/>
		<shortcut name="getWriter" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletResponse.html#getWriter()"/>
		<shortcut name="Date" uri="http://java.sun.com/javase/6/docs/api/java/util/Date.html"/>
		<shortcut name="GregorianCalendar" uri="http://java.sun.com/javase/6/docs/api/java/util/GregorianCalendar.html"/>
		<shortcut name="Calendar" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html"/>
		<shortcut name="get" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#get(int)"/>
		<shortcut name="Calendar.AM_PM" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#AM_PM"/>
		<shortcut name="Calendar.PM" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#PM"/>
		<shortcut name="Calendar.AM" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#AM"/>
		<shortcut name="Calendar.HOUR" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#HOUR"/>
		<shortcut name="Calendar.MINUTE" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#MINUTE"/>
		<shortcut name="Calendar.SECOND" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#SECOND"/>
		<shortcut name="Calendar.MILLISECOND" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#MILLISECOND"/>
		<shortcut name="getTimeInMillis" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#getTimeInMillis()"/>
		<shortcut name="getOutputStream" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletResponse.html#getOutputStream()"/>
		<shortcut name="getServletConfig" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/GenericServlet.html#getServletConfig()"/>
		<shortcut name="getServletContext" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/GenericServlet.html#getServletContext()"/>
		<shortcut name="getRealPath" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getRealPath(java.lang.String)"/>
		<shortcut name="getResource" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getResource(java.lang.String)"/>
		<shortcut name="getResourceAsStream" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getResourceAsStream(java.lang.String)"/>
		<shortcut name="BufferedImage" uri="http://java.sun.com/javase/6/docs/api/java/awt/image/BufferedImage.html"/>
		<shortcut name="BufferedImage.TYPE_3BYTE_BGR" uri="http://java.sun.com/javase/6/docs/api/java/awt/image/BufferedImage.html#TYPE_3BYTE_BGR"/>
		<shortcut name="Graphics2D" uri="http://java.sun.com/javase/6/docs/api/java/awt/Graphics2D.html"/>
		<shortcut name="createGraphics" uri="http://java.sun.com/javase/6/docs/api/java/awt/image/BufferedImage.html#createGraphics()"/>
		<shortcut name="setStroke" uri="http://java.sun.com/javase/6/docs/api/java/awt/Graphics2D.html#setStroke(java.awt.Stroke)"/>
		<shortcut name="drawOval" uri="http://java.sun.com/javase/6/docs/api/java/awt/Graphics.html#drawOval(int, int, int, int)"/>
		<shortcut name="drawLine" uri="http://java.sun.com/javase/6/docs/api/java/awt/Graphics.html#drawLine(int, int, int, int)"/>
		<shortcut name="fillRect" uri="http://java.sun.com/javase/6/docs/api/java/awt/Graphics.html#fillRect(int, int, int, int)"/>
		<shortcut name="BasicStroke" uri="http://java.sun.com/javase/6/docs/api/java/awt/BasicStroke.html"/>
		<shortcut name="ImageIO.write" uri="http://java.sun.com/javase/6/docs/api/javax/imageio/ImageIO.html#write(java.awt.image.RenderedImage, java.lang.String, java.io.OutputStream)"/>
		<shortcut name="setColor" uri="http://java.sun.com/javase/6/docs/api/java/awt/Graphics.html#setColor(java.awt.Color)"/>
		<shortcut name="Color.BLACK" uri="http://java.sun.com/javase/6/docs/api/java/awt/Color.html#BLACK"/>
		<shortcut name="Color.WHITE" uri="http://java.sun.com/javase/6/docs/api/java/awt/Color.html#WHITE"/>
		<shortcut name="HttpServletResponse.SC_FORBIDDEN" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletResponse.html#SC_FORBIDDEN"/>
		<shortcut name="sendError" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletResponse.html#sendError(int, java.lang.String)"/>
		<shortcut name="sendRedirect" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletResponse.html#sendRedirect(java.lang.String)"/>
		<shortcut name="getParameter" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getParameter(java.lang.String)"/>
		<shortcut name="getParameterMap" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getParameterMap()"/>
		<shortcut name="getParameterNames" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getParameterNames()"/>
		<shortcut name="Map" uri="http://java.sun.com/javase/6/docs/api/java/util/Map.html"/>
		<shortcut name="Enumeration" uri="http://java.sun.com/javase/6/docs/api/java/util/Enumeration.html"/>
		<shortcut name="hasMoreElements" uri="http://java.sun.com/javase/6/docs/api/java/util/Enumeration.html#hasMoreElements()"/>
		<shortcut name="nextElement" uri="http://java.sun.com/javase/6/docs/api/java/util/Enumeration.html#nextElement()"/>
		<shortcut name="keySet" uri="http://java.sun.com/javase/6/docs/api/java/util/Map.html#keySet()"/>
		<shortcut name="getHeader" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getHeader(java.lang.String)"/>
		<shortcut name="setHeader" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String, java.lang.String)"/>
		<shortcut name="getRequestURI" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getRequestURI()"/>
		<shortcut name="getPathInfo" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getPathInfo()"/>
		<shortcut name="getServletPath" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getServletPath()"/>
		<shortcut name="getContextPath" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getContextPath()"/>
		<shortcut name="getQueryString" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getQueryString()"/>
		<shortcut name="getCookies" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getContextPath()"/>
		<shortcut name="Cookie" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/Cookie.html"/>
		<shortcut name="getValue" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/Cookie.html#getValue()"/>
		<shortcut name="getName" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/Cookie.html#getName()"/>
		<shortcut name="setMaxAge" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/Cookie.html#setMaxAge(int)"/>
		<shortcut name="matches" uri="http://java.sun.com/javase/6/docs/api/java/lang/String.html#matches(java.lang.String)"/>
		<shortcut name="addCookie" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletResponse.html#addCookie(javax.servlet.http.Cookie)"/>
		<shortcut name="getSession" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getSession()"/>
		<shortcut name="getAttribute" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSession.html#getAttribute(java.lang.String)"/>
		<shortcut name="setAttribute" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSession.html#setAttribute(java.lang.String, java.lang.Object)"/>
		<shortcut name="setMaxInactiveInterval" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSession.html#setMaxInactiveInterval(int)"/>
		<shortcut name="DataSource" uri="http://java.sun.com/javase/6/docs/api/javax/sql/DataSource.html"/>
		<shortcut name="Connection" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html"/>
		<shortcut name="SQLException" uri="http://java.sun.com/javase/6/docs/api/java/sql/SQLException.html"/>
		<shortcut name="getConnection" uri="http://java.sun.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection()"/>
		<shortcut name="Context" uri="http://java.sun.com/javase/6/docs/api/javax/naming/Context.html"/>
		<shortcut name="InitialContext" uri="http://java.sun.com/javase/6/docs/api/javax/naming/InitialContext.html"/>
		<shortcut name="lookup" uri="http://java.sun.com/javase/6/docs/api/javax/naming/Context.html#lookup(java.lang.String)"/>
		<shortcut name="NamingException" uri="http://java.sun.com/javase/6/docs/api/javax/naming/NamingException.html"/>
		<shortcut name="RuntimeException" uri="http://java.sun.com/javase/6/docs/api/java/lang/RuntimeException.html"/>
		<shortcut name="format" uri="http://java.sun.com/javase/6/docs/api/java/lang/String.html#format(java.lang.String, java.lang.Object...)"/>
		<shortcut name="log" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/GenericServlet.html#log(java.lang.String)"/>
		<shortcut name="getInitParameter" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getInitParameter(java.lang.String)"/>
		<shortcut name="X509Certificate" uri="http://java.sun.com/javase/6/docs/api/java/security/cert/X509Certificate.html"/>
		<shortcut name="Collections" uri="http://java.sun.com/javase/6/docs/api/java/util/Collections.html"/>
		<shortcut name="Collections.list" uri="http://java.sun.com/javase/6/docs/api/java/util/Collections.html#list(java.util.Enumeration)"/>
		<shortcut name="getRequestDispatcher" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getRequestDispatcher(java.lang.String)"/>
		<shortcut name="RequestDispatcher" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/RequestDispatcher.html"/>
		<shortcut name="forward" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/RequestDispatcher.html#forward(javax.servlet.ServletRequest, javax.servlet.ServletResponse)"/>
		<shortcut name="include" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/RequestDispatcher.html#include(javax.servlet.ServletRequest, javax.servlet.ServletResponse)"/>
		<shortcut name="URL" uri="http://java.sun.com/javase/6/docs/api/java/net/URL.html"/>
		<shortcut name="Properties" uri="http://java.sun.com/javase/6/docs/api/java/util/Properties.html"/>
		<shortcut name="sessionCreated" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSessionListener.html#sessionCreated(javax.servlet.http.HttpSessionEvent)"/>
		<shortcut name="sessionDestroyed" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSessionListener.html#sessionDestroyed(javax.servlet.http.HttpSessionEvent)"/>
		<shortcut name="setLocale" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletResponse.html#setLocale(java.util.Locale)"/>
		<shortcut name="Locale" uri="http://java.sun.com/javase/6/docs/api/java/util/Locale.html"/>
		<shortcut name="Locale.ENGLISH" uri="http://java.sun.com/javase/6/docs/api/java/util/Locale.html#ENGLISH"/>
		<shortcut name="Locale.GERMAN" uri="http://java.sun.com/javase/6/docs/api/java/util/Locale.html#GERMAN"/>
		<shortcut name="getLocale" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getLocale()"/>
		<shortcut name="getLocales" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getLocales()"/>
		<shortcut name="Arrays.asList" uri="http://java.sun.com/javase/6/docs/api/java/util/Arrays.html#asList(java.lang.Object[])"/>
		<shortcut name="getLocalName" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getLocalName()"/>
		<shortcut name="getLocalAddr" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getLocalAddr()"/>
		<shortcut name="getNamedDispatcher" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getNamedDispatcher(java.lang.String)"/>
		<shortcut name="Filter" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/Filter.html"/>
		<shortcut name="FilterConfig" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/FilterConfig.html"/>
		<shortcut name="FilterChain" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/FilterChain.html"/>
		<shortcut name="doFilter" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/Filter.html#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)"/>
		<shortcut name="getUserPrincipal" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()"/>
		<shortcut name="Principal" uri="http://java.sun.com/javase/6/docs/api/java/security/Principal.html"/>
		<shortcut name="getRemoteUser" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()"/>
		<shortcut name="isUserInRole" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)"/>
		<shortcut name="@EJB" uri="http://java.sun.com/javaee/5/docs/api/javax/ejb/EJB.html"/>
		<shortcut name="@Local" uri="http://java.sun.com/javaee/5/docs/api/javax/ejb/Local.html"/>

	</shortcuts>
  </javadocConfig>
  
  <article>
  <body>

	<singleColumnSection anchor="overview">
	  	<head>Overview</head>
		<subSection anchor="intro">
			<head>Intro</head>
			<explanation>
			The Java Servlet API is a low-level API to <em>extend a web server to generate dynamic content</em>. 
			The API's core is the <javadoc>Servlet</javadoc> interface. Classes implementing this interface can <em>receive the client's 
			HTTP request and generate the response</em>. 
			</explanation><explanation>
			Practically <em>all Java web frameworks are built on the Servlet API</em>. This makes it important to know the basics even when 
			you will never write a servlet.
			</explanation><explanation> 
			A collection of Servlets, Filters, <topic>JSPs</topic> and static web content that is bundled together in a single directory is 
			called a <em>web application</em>. Web application are usually distributed and deployed in 
			<em>WAR archives</em>. A web server that supports Java web applications is also called <em>web container</em>.
			</explanation><explanation>
			The Servlet API has two layers, a generic layer and a HTTP-specific layer. The generic part can also be used for
			other protocols such as FTP, SIP and SMTP. Non-HTTP servlets are not described in this document.
			</explanation>
		</subSection>
		<collapsedSubSection anchor="usecases">
			<head>Use cases</head>
			<summary>When should you write a Servlet?</summary>
			<content>
				<explanation>Practically <em>all Java Web APIs are built on top of the Servlet API</em>. Whenever you
				write a web application for Java, you <em>need at least basic knowledge of the API</em>. However,
				it is <em>rarely necessary to implement a <javadoc>Servlet</javadoc></em> directly. <br/>
				Write a Servlet when...</explanation>
				<list>
				<li>you serve <em>document types not supported</em> by frameworks, like images and other binaries</li>
				<li>you need <em>full control</em> over the response, for example to use your own web framework</li>
				<li>you need to work on the <em>HTTP level</em>, for example for writing a <link to="http://en.wikipedia.org/wiki/Proxy_server">proxy</link>.</li>
				</list>
				
				
				<miniHeadline>Alternatives</miniHeadline>
				<explanation>Here are the most common alternatives for pure servlet development. All of them are based on the Servlet API:</explanation>
				<list>
				<li><topic>JSP</topic> are a powerful, Java-centric template system that also allows you to mix HTML with Java code <more>You could
				spend a long time discussing whether mixing code with HTML is a good idea. Common opinion is that it should be avoided and
				custom tags (another JSP feature) should be used instead.<br/>
				However, the ability to include Java code makes JSPs very powerful. With JSPs you never have the situation wasting time
				to find a way around the limits of the template system. You always have pure Java as last resort.</more>. 
				Today they are mostly used as a template system for higher-level web application frameworks, but for simple applications <em>JSPs 
				without additional framework can be the fastes solution</em>.</li>
				<li><topic>JSF</topic> is <topic>Java EE</topic>'s high-level web application framework, designed for
				<em>complex web applications</em>. It is based on the  
				<annotated><title>MVC</title><explanation>MVC (Model-View-Controller) is the most common pattern to implement user interfaces.
				The code is split into a Model (represents the data being edited), a View (to present the data to the user) and a Controller (which
				handles user input and initiates actions).</explanation></annotated> pattern, offers web components and multiple output formats.</li>
				<li><topic>Spring</topic> is a popular alternative. It is a complete 
				application framework that also includes support for web applications, among other features. Typically it is used as a 
				<annotated><title>relatively</title><explanation>Originally Spring was a small and easy-to-use framework, 
				while EJB 2.x application servers were monsters with complex APIs and a huge overhead. Over the years
				the situation has changed though. Spring grew and is a pretty large system now, while EJB reduced its overhead with version 3.0
				and became simpler to use.<br/> 
				Today Spring may still be smaller than EJB application servers, but the difference is not nearly as large as it used 
				to be.</explanation></annotated> light-weight alternative to <topic>EJB</topic> application servers.</li>
				</list>
				<explanation>This list is far from complete, and there is an almost endless number of web frameworks for Java. A few additional, notable frameworks: <link to="http://struts.apache.org">Struts</link>, <link to="http://tapestry.apache.org">Tapestry</link>, 
				<link to="http://wicket.apache.org/">Wicket</link> and <link to="http://code.google.com/webtoolkit">GWT</link>.
				</explanation>
			</content>  
		</collapsedSubSection>
		<collapsedSubSection anchor="requirements">
			<head>Requirements</head>
			<summary>What do you need for Servlets?</summary>
			<content>
				<explanation>
				In order to run applications written for the Java Servlet API you need a Servlet-capable web container. The most popular choice is
				<link to="http://tomcat.apache.org">Apache Tomcat</link>, but there are many others. Also, all EJB application server ship
				with a web container.
				</explanation><explanation> 
				You web container should include the all JARs that you need to compile your web application (usually a JAR called
				<idf>servlet-api.jar</idf> or <idf>javax.servlet.jar</idf>).
				</explanation>
			</content>
		</collapsedSubSection>
		<collapsedSubSection id="section-containerOverview"  anchor="containers">
			<head>Containers</head>
			<summary>Which container supports which Servlet / JEE version?</summary>
			<content>
				
<!--
Servlet 3.0     December 2009     JavaEE 6
Servlet 2.5     September 2005     JavaEE 5
Servlet 2.4     November 2003     J2EE 1.4 + J2SE 1.3

Tomcat 5.5 -> 2.4
Tomcat 6.0 -> 2.5
Tomcat 7.0 -> 3.0

Wikipedia http://en.wikipedia.org/wiki/JBoss_application_server :
JBoss AS 3.2 -> Tomcat 5.0 (not part of JBoss)
JBoss AS 4.0 -> Tomcat 5.5 -> Servlet 2.4
JBoss AS 4.2 -> Tomcat 6.0 -> Servlet 2.5
JBoss AS 6M2 -> soon Servlet 3.0, not yet ()

http://caucho.com/resin-3.1/changes/changes.xtp
Resin 3.0 -> Servlet 2.4
Resin 3.1 -> Servlet 2.5
Resin 4.0 -> Servlet 3.0 (preview)

Glassfish 1.0 -> JEE 5 -> Servlet 2.5
Glassfish 2.0 -> JEE 5 -> Servlet 2.5
Glassfish 3.0 -> JEE 6 -> Servlet 3.0

http://publib.boulder.ibm.com/infocenter/wasinfo/v6r1/index.jsp?topic=/com.ibm.websphere.base.doc/info/aes/ae/rovr_specs.html
http://en.wikipedia.org/wiki/IBM_WebSphere#WebSphere_compatibility_matrix)
http://en.wikipedia.org/wiki/Comparison_of_application_servers
-->
				<table> 
				    <head><cell></cell><cell>Servlet 3.0</cell><cell>Servlet 2.5</cell><cell>Servlet 2.4</cell></head>
				    <row><cell>JEE Version</cell><cell>Java EE 6</cell><cell>Java EE 5</cell><cell>J2EE 1.3/1.4</cell></row>
				    <row><cell>Released</cell><cell>December 2009</cell><cell>September 2005</cell><cell>November 2003</cell></row>
				    <row><cell>in Tomcat</cell><cell>>= 7.0 (*)</cell><cell>>= 6.0</cell><cell>>= 5.5</cell></row>
				    <row><cell>in Jetty</cell><cell>>= 8.0 (*)</cell><cell>>= 6.0</cell><cell>>= 5.0</cell></row>
				    <row><cell>in Glassfish</cell><cell>>= 3.0</cell><cell>>= 1.0</cell><cell>>= 1.0</cell></row>
				    <row><cell>in JBoss AS</cell><cell>>= 6.0 (*)</cell><cell>>= 4.2</cell><cell>>= 4.0</cell></row>
				    <row><cell>in Resin</cell><cell>>= 4.0</cell><cell>>= 3.1</cell><cell>>= 3.0</cell></row>
				    <row><cell>in <annotated><title>WAS</title><explanation>Websphere Application Server</explanation></annotated></cell><cell>-</cell><cell>>= 7.0</cell><cell>>= 6.0</cell></row>
				</table>
				<explanation>(*) - not stable yet
				</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="httpintro">
			<head>HTTP Intro</head>
			<summary>Short HTTP Introduction</summary>
			<content>
				<explanation>HTTP is a relatively simple, text-based protocol:</explanation>
				<list>
				<li>HTTP uses a <em>request/response pattern</em>: 
				    <list>
				    <li>the <em>client</em>, usually a web browser, <em>sends requests</em> to the web server.</li>
				    <li>The <em>server answers with a response</em>.</li>
				    <li>The web <em>server can not send anything to the client</em> without the client initiating the connection and requesting it explicitly.</li>
				    </list>
				</li>
				<li>Every <em>request consists of a command, a path to the requested resource, a set of headers and an optional body</em>
				    <list>
				    <li>The only important commands are GET, POST and HEAD:
				        <list>
				        <li><em>GET retrieves a document</em>. Web browsers use it when you <em>visit a page</em>.</li>
				        <li><em>POST sends data</em>, and also gets a document as response. Web browser use POST when you <em>submit a form</em>.</li>
				        <li><em>HEAD simulates a GET without a body in the response</em>. This is important sometimes. For example it allows the browser
				        to find out about a large document before downloading it.</li>
				        </list>
				    </li>
				    <li>The <em>path identifies the resource</em> on the server. For example, if you enter the URL "http://jarfiller.com/guide/jaxb/", the
				        requested path is "/guide/jaxb/".</li>
				    <li><em>Headers contain additional information</em> about the request. Header values are just string key/value pairs.
				    Usually the web server evaluates them automatically for you. Even though you can access them
					directly, the Servlet API provides convenience methods to handle important headers (such as cookies).
				    Wikipedia <link to="http://en.wikipedia.org/wiki/List_of_HTTP_headers">has a complete list</link>.</li>
				    <li>The <em>POST command needs a document as body</em>. For example, if a user submits a form, the content of the
				    fields will be sent in the body. <em>GET requests do not have a body</em>.</li>
				    <li>A request may <em>contain parameters</em>:
				    	<list>
				    		<li>GET and most other commands support <em>parameters appended to the path</em>, separated by a question mark ("?") from the rest.</li>
				    		<li>POST sends <em>parameters in the body</em></li>
				    		<li>parameters are sent as <em>name/value pairs</em>, which looks like this: "param1=value&amp;param2=value&amp;param3=value"... <more>There
				    		are encoding rules to transmit special characters and characters like "=" and "&amp;" in the URL. 
				    		Spaces will be replaced by "+". All other characters are escaped as "%" character followed by a 2 hexadecimal
				    		characters to specify the character code.</more></li>
				    	</list>
				    </li>
				    <li>Example URL with parameters: "http://jarfiller.com/search?query=xml&amp;maxresults=20"</li>
				    </list>
				</li>
				<li>A <em>response consists of a status code, a set of headers and a body</em> containing a document.
				    <list>
				    <li>The <link to="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">status code</link> is just a number. 
				    The most important ones:
				        <list>
				        <li>200 for success</li>
				        <li><link to="http://en.wikipedia.org/wiki/HTTP_301">301</link> forwards the client to a different page</li>
				        <li><link to="http://en.wikipedia.org/wiki/HTTP_404">404</link> for unknown paths</li>
				        <li><link to="http://en.wikipedia.org/wiki/HTTP_500">500</link> for server errors</li>
				        </list>
				    </li>
				    <li><em>Headers contain additional information</em> such as cookies. Header values are just string key/value pairs.
				    Usually the web container will set them automatically for you, so you don't need to know them.
				    Wikipedia <link to="http://en.wikipedia.org/wiki/List_of_HTTP_headers">has a complete list</link>.</li>
				    <li>The response body is the document sent to the client. In a web browser, this is the document shown to the user.</li>
				    </list>
				</li>
				</list>
				<explanation>This is what a simple request looks like:
				</explanation>
				<config><annotated><title>GET /guide/jaxb/ HTTP/1.1</title><explanation>The first line contains the command (GET), the path (/guide/jaxb/) and the HTTP protocol version (1.1).</explanation></annotated>
<annotated><title>Host: jarfiller.com</title><explanation>The required header value "HOST" tells the web server
the host name requested by the user. It allows you to host several domains on a single web server.</explanation></annotated>
<annotated><title>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2) Gecko/20100115 Firefox/3.6</title><explanation>This tells 
the webserver all about the client doing the request. Here, it is a Firefox 3.6 browser running on Windows.</explanation></annotated>
<annotated><title>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</title><explanation>This header value
is a list of comma-separated content types to show the web server what kind of documents the browser can handle. 
Firefox prefers "text/html" (HTML) or "application/xhtml+xml" (XHTML). Other XML ("application/xml") is also good,
but less desirable ("q=0.9"). Everything else will be accepted ("*/*") if necessary.<br/>
Note that this header value is ignored by most servlets - just send the browser the requested document.</explanation></annotated>
<annotated><title>Accept-Language: en-us,en;q=0.8,de-de;q=0.5,de;q=0.3</title><explanation>Many multilingual pages
use this setting to find out which language the user prefers. This user prefers US English ("en-us") over plain
English ("en") and German ("de-de" and "de").</explanation></annotated>
<annotated><title>Accept-Encoding: gzip,deflate</title><explanation>This tells the web server that the browser
can handle compressed pages that use the "gzip" or "deflate" (ZIP) compression mechanisms.</explanation></annotated>
<annotated><title>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</title><explanation>This header value tells the web server
what character sets the browser prefers. Here it prefers "ISO-8859" over "utf-8", but will take anything ("*").</explanation></annotated>
<annotated><title>Connection: keep-alive</title><explanation>Tells the server to keep the connection open for additional requests.</explanation></annotated>
				</config>
				<explanation>
				And here is the server's response (the body containing HTML <em>has been omitted</em> in this example):
				</explanation>
				<config><annotated><title>HTTP/1.1 200 OK</title><explanation>The first line of the response always contains
the HTTP version used by the server (1.1) and the status code (200) with an explanation (OK).</explanation></annotated>
<annotated><title>Content-Length: 4227</title><explanation>This header value contains the length of the body document in bytes.</explanation></annotated>
<annotated><title>Date: Mon, 01 Mar 2010 18:47:48 GMT</title><explanation>This is the date at which the server generated
the response.</explanation></annotated>
<annotated><title>Content-Type: application/xhtml+xml; q=0.8</title><explanation>This contains the type of the body document.
Here, it is XHTML ("application/xhtml+xml").</explanation></annotated>
<annotated><title>Server: Apache/2.2.3 (Debian)</title><explanation>Here the web server identifies its version.</explanation></annotated>
<annotated><title>Last-Modified: Fri, 26 Feb 2010 19:28:08 GMT</title><explanation>This is the date at which the document
has been modified. It may be important for caching.</explanation></annotated>
<annotated><title>Accept-Ranges: bytes</title><explanation>If the server sends this, it means that the client is
also allowed to request the document partially by specifying a byte range.</explanation></annotated>
				</config>
				<explanation>
				An important HTTP concept is the <em>content type</em>, also known as MIME type. It describes the type of document transmitted
				as body. Basically it is like a file extension, but it can also be used for documents that your servlet created on the fly
				and thus do not have a file extension. Here are the most important content types:</explanation>
				<table>
				    <head><cell>Content Type</cell><cell>File Extension</cell><cell>Name</cell></head>
				    <row><cell>text/html</cell><cell>.html, .htm</cell><cell>HTML</cell></row>
				    <row><cell>application/xhtml+xml</cell><cell>.xhtml</cell><cell>XHTML</cell></row>
				    <row><cell>text/plain</cell><cell>.txt</cell><cell>Plain text file</cell></row>
				    <row><cell>application/pdf</cell><cell>.pdf</cell><cell>PDF</cell></row>
				    <row><cell>image/png</cell><cell>.png</cell><cell>PNG images</cell></row>
				    <row><cell>image/jpeg</cell><cell>.jpg, .jpeg</cell><cell>JPEG images</cell></row>
				    <row><cell>image/gif</cell><cell>.gif</cell><cell>GIF images</cell></row>
				</table>
				<explanation>Find a <link to="http://www.iana.org/assignments/media-types/">more types on Wikipedia</link>.
				</explanation>
			</content>
		</collapsedSubSection>
	</singleColumnSection>
	
	<singleColumnSection anchor="servlets">
		<head>Servlets</head> 
		<subSection anchor="servletintro">
			<head>Servlet Intro</head>
			<explanation>Servlets are <em>classes that handle HTTP requests</em> and generate a response for the client. 
			To have a Servlet ready for deployment, you need to do four things:</explanation>
			<orderedList>
			    <li>Write the servlet class (must extend <javadoc>HttpServlet</javadoc>)</li>
			    <li>Declare the servlet in your <annotated id="doc-webxml"><title>web.xml</title><explanation><idf>web.xml</idf> is
			    the <em>deployment descriptor for web applications</em>. It is always located at the path <em>/WEB-INF/web.xml</em>
			    in the application's directory structure. Usually the whole web application is stored in a WAR file (a special kind of 
			    JAR archive) for deployment in the web container.</explanation></annotated> deployment descriptor</li>
			    <li>Define one or more <annotated id="doc-url-pattern"><title>url patterns</title><explanation>A URL Pattern defines which URLs the servlet 
			    responds to. You can either define a path, a partial path or a file extension.</explanation></annotated> that the servlet responds to</li>
			    <li>Package your whole application in a <annotated id="doc-war"><title>WAR</title>
			    <explanation>A WAR file is a <em>special kind of JAR archive</em> that contains all classes of a web application as well as static
			    files and JSPs. The content of the WAR is described in the deployment descriptor at /WEB-INF/web.xml.</explanation></annotated> file.</li>
			</orderedList>
		</subSection>
		
		<subSection anchor="classoverview">
			<head>Class Overview</head>
			<table>
				<head>
					<cell>Base Interface</cell>
					<cell>HTTP-specific Class</cell>
					<cell>Purpose</cell>
				</head>
				<row><cell><javadoc>Servlet</javadoc></cell><cell><javadoc>HttpServlet</javadoc></cell><cell>Base interface to <em>implement for handling requests</em></cell></row>
				<row><cell><javadoc>ServletRequest</javadoc></cell><cell><javadoc>HttpServletRequest</javadoc></cell><cell>Represents the request</cell></row>
				<row><cell><javadoc>ServletResponse</javadoc></cell><cell><javadoc>HttpServletResponse</javadoc></cell><cell>Creates a response</cell></row>
				<row><cell><javadoc>ServletConfig</javadoc></cell><cell>-</cell><cell>Retrieving initialization parameters, servlet name</cell></row>
				<row><cell><javadoc>ServletContext</javadoc></cell><cell>-</cell><cell>Access to web container features: resources, attributes, logging, dispatcher</cell></row>
				<row><cell><javadoc>Filter</javadoc></cell><cell>-</cell><cell>Modify a request before processing, or a response after processing</cell></row>
				<row><cell>*Listener</cell><cell>Http*Listener</cell><cell>Notifications about various events in the application</cell></row>
				<row><cell>-</cell><cell><javadoc>HttpSession</javadoc></cell><cell>Keeps state for a single client</cell></row>
				
			</table>
			
		</subSection>
		
		<subSection anchor="servletclass">
			<head>Servlet Class</head>
			<more>To write a servlet, just create a class that <em>extends from <idf>HttpServlet</idf></em>, and provide a <em>constructor without arguments</em>.
			You do not need to override any of the <idf>HttpServlet</idf> methods.<br/>
			Beside the initialization and destruction methods <idf>init</idf> and <idf>destroy</idf>, the <idf>HttpServlet</idf> provides 
			overridable methods for each HTTP command, like <idf>doGet</idf>, <idf>doPost</idf>, <idf>doHead</idf>....</more>
			<code>
				<line>package com.jarfiller.example;</line>
				<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
				<line>import <javadoc>javax.servlet.*</javadoc>;</line>
				<line>import <javadoc>java.io.*</javadoc>;</line>
				<emptyLine/>
			    <line><plainCmt>Simple dummy servlet with the most important methods</plainCmt></line>
			    <line>public class SkeletonServlet extends <javadoc>HttpServlet</javadoc> {</line>
			    <emptyLine/>
			    <line>    public SkeletonServlet() { <cmt><em>default constructor required</em> <more>A 
			    <em>constructor without arguments is required</em> for every <idf>Servlet</idf> class. You should <em>avoid putting code here</em>. 
			    Costly operations, such as
			  retrieving connections via JNDI, should be done in the <em><idf>init</idf> method</em>, which will always be invoked
			  before the servlet handles its first request.<br/>
			  Usually it is up to the web container to decide when to initialize a servlet. Either the servlet is initialized
			  when the application is started, or when the first request needs to be handled. You can enforce the former behaviour 
			  using the <idf>&lt;load-on-startup></idf> element in the <idf>web.xml</idf> deployment descriptor.</more></cmt></line>
			    <line>    }</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    public void <javadoc>init</javadoc>(<javadoc>ServletConfig</javadoc> config) <cmt><em>invoked before first request</em> <more>The <idf>init</idf> method will be invoked
			  by the web container before the servlet gets the first request. All <em>costly initialization should be done here</em>. Also, the
			  <idf>ServletConfig</idf> will be passed here and can be used to configure the servlet.<br/>
			  Usually it is up to the web container to decide when to initialize a servlet. Either the servlet is initialized
			  when the application is started, or when the first request needs to be handled. You can enforce the former behaviour 
			  using the <idf>&lt;load-on-startup></idf> element in the <idf>web.xml</idf> deployment descriptor.</more></cmt></line>
			  	<line>        throws <javadoc>ServletException</javadoc> {</line>
			  	<line>        super.<javadoc>init</javadoc>(config); <cmt>required when overriding <idf>init</idf>!</cmt></line>
			    <line>        <plainCmt>do all initialization here</plainCmt></line>
			    <line>    }</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
			    <line>        throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
			    <line>        <plainCmt>handle HTTP GET requests here</plainCmt></line>
			    <line>    }</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    protected void <javadoc>doPost</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
			    <line>        throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
			    <line>        <plainCmt>handle HTTP POST requests here</plainCmt></line>
			    <line>    }</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    public void <javadoc>destroy</javadoc>() { <cmt>invoked before server discards the servlet <more>When the server does 
			    not need the servlet anymore, it calls <idf>destroy</idf>. All <em>resources should be released here</em>.<br/>
			  There are two reasons for the server to call <idf>destroy</idf>. Either the web application is being shut down,
			  or the server decides that the servlet has not been needed for a while and it should be removed in order
			  to conserve resources.<br/>
			  After calling <idf>destroy</idf>, the container will not use the servlet anymore. If it needs the servlet to handle 
			  a request, it will create a new instance and initialize it again.</more></cmt></line>
			    <line>        <plainCmt>release resources here</plainCmt></line>
			    <line>    }</line>  
			    <line>}</line>
			</code>
		</subSection>
	
		<collapsedSubSection anchor="servicemethods">
			<head>Service Method</head>
			<summary>Service Dispatching in the HttpServlet</summary>
			<content>
				<explanation>The skeleton servlet above showed you methods like <javadoc>doGet</javadoc>
				and <javadoc>doPost</javadoc> to process requests. They are provided by the
				<javadoc>HttpServlet</javadoc> class, and overriding those methods is what you should do in 99% 
				of all servlets.</explanation>
				
				<explanation>However, the actual <em><javadoc>Servlet</javadoc> interface is protocol agnostic</em>
				and thus does not know anything about the HTTP protocol and its commands, nor will it provide
				<javadoc>HttpServletRequest</javadoc> and <javadoc>HttpServletResponse</javadoc> objects, which
				are also HTTP-specific. Instead, <javadoc>Servlet</javadoc> has a single method
				called <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/Servlet.html#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)">service</javadoc>
				which will be invoked for every request:</explanation>
				<code>
					<line>void <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/Servlet.html#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)">service</javadoc>(<javadoc>ServletRequest</javadoc> req, <javadoc>ServletResponse</javadoc> res);</line>
				</code>
				<explanation><em><javadoc>HttpServlet</javadoc> 
				overrides <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/Servlet.html#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)">service</javadoc>
				and will call one of the <idf>doCommandName</idf> methods</em> (<javadoc>doGet</javadoc>...), depending on the command of the request. It will also cast the 
				generic request and response objects into HTTP-specific responses.
				</explanation>
			</content>
		</collapsedSubSection>
	
		
		<collapsedSubSection anchor="lifecycle">
			<head>Servlet Lifecyle</head>
			<summary>The Servlet Lifecycle</summary>
			<content>
				<explanation>The lifecyle of a servlet:</explanation>
				<orderedList>
				  <li>Class instantiation with the empty default constructor</li>
				  <li><javadoc>init</javadoc> method invoked</li>
				  <li>processing with <javadoc>doGet</javadoc>, <javadoc>doPost</javadoc> etc (<javadoc>service</javadoc> methods)</li>
				  <li><javadoc>destroy</javadoc> method invoked</li>
				</orderedList>
				
			</content>
		</collapsedSubSection>

		<subSection anchor="multithreading">
			<head>Multithreading</head>
			<explanation>
			Servlets are multi-threaded. This means that the web server will call the service 
			methods (<javadoc>doGet</javadoc>, <javadoc>doPost</javadoc>...) from several threads, and thus your
			<em>servlet implementation must be thread-safe</em>.<br/> 
			The next section shows you <link anchor="twothreadsafeways">two easy ways to make your servlets multi-threaded</link>.
			</explanation>
			
			

		</subSection>
		
		<collapsedSubSection anchor="twothreadsafeways">
			<summary>Two Simple Ways to Write Thread-Safe Servlets</summary>
			<content>
			<explanation>
			Here are two <em>recipes that allow you to write thread-safe servlets</em> without knowing anything about multi-threading 
			<more>You can, of course, also use
			the usual synchronization techniques to write a thread-safe servlet. But explaining them is far outside of the scope of this page.</more>.
			</explanation>
			
			<miniHeadline>Recipe 1: Synchronize your Servlet</miniHeadline>
			<explanation>To make your servlet thread-safe, just <em>declare all overriden methods as <idf>synchronized</idf></em> 
			(<javadoc>init</javadoc>, <javadoc>destroy</javadoc>, <javadoc>doGet</javadoc>...). 
			This is the easiest way, but also means that you can <em>process only one request at a time</em>. Synchronizing the whole servlet 
			is only feasible for low-volume sites.
			</explanation><explanation>
			The following example shows how to synchronize a Servlet so that only one thread runs in it at a time. Note that there
			is no constructor, but Java's default constructor will be taken. If you would provide an constructor, you'd need to
			put the code into a <idf>synchronize</idf> block with 'this' as synchronization object <more>Yes, that's true! 
At least if you follow the Java specification by the word. Because thread synchronization is not only needed to avoid concurrent access, but 
also to synchronize the thread's local memory (read: the CPU core's cache) with the main memory.<br/>
However, on today's machines, not synchronizing the constructor won't hurt. This may change though in the future, when caches
are not cache coherent anymore.</more>.</explanation>
			<code>
			    <line>public class SynchronizedSkeletonServlet extends <javadoc>HttpServlet</javadoc> {</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    public <em>synchronized</em> void init(ServletConfig config) {</line>
			  	<line>        super.<javadoc>init</javadoc>(config);</line>
			    <line>        <plainCmt>do all initialization here</plainCmt></line>
			    <line>    }</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    protected <em>synchronized</em> void doGet(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
			    <line>        throws IOException {</line>
			    <line>        <plainCmt>handle HTTP GET requests here</plainCmt></line>
			    <line>    }</line>
			    <line>}</line>
			</code>
			
			<miniHeadline>Recipe 2: Restrict Usage of Fields</miniHeadline>
			<explanation>Alternatively, restrict the use of fields and follow these simple five rules <more>The goal of these rules is to prevent the sharing 
			of data between threads, which would require synchronization.</more>:</explanation>
			<orderedList>
			<li>All fields in the <javadoc>Servlet</javadoc> class <em>must be <idf>volatile</idf></em>.</li>
			<li><em>Only <javadoc>init</javadoc> can set and modify fields</em> (including objects reachable by those fields).</li>
			<li>The <em>service methods</em> (<javadoc>doGet</javadoc>, <javadoc>doPost</javadoc>...) can read the <idf>volatile</idf> fields,
			but <em>must not modify</em> any field.</li>
			<li>Data in attributes, sessions etc must be treated like <idf>volatile</idf> members: write them in the <javadoc>init</javadoc>
			method, read-only access in the service methods.</li>
			<li>Constant fields with <idf>final</idf> modifier are allowed, but can only be modified in the constructor.</li> 
			</orderedList>
			<explanation>Of course, the easiest way to achieve this is to <em>have no fields in your servlet class</em>, and to work only
			with local variables.</explanation>
			<explanation>This example shows a simple servlet that initializes a local field in <javadoc>init</javadoc>.</explanation>
			<code>
			    <line>public class RedirectServlet extends <javadoc>HttpServlet</javadoc> {</line>
			    <emptyLine/>
			    <line>    private <em>volatile</em> String <em>newLocation</em>;</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    public void init(ServletConfig config) {</line>
			  	<line>        super.<javadoc>init</javadoc>(config);</line>
			  	<emptyLine/>
			    <line>        <em>newLocation</em> = config.getInitParameter("redirectUrl");</line>
			    <line>    }</line>
			    <emptyLine/>
			    <line>    @Override</line>
			    <line>    protected void doGet(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
			    <line>        throws IOException {</line>
			    <line>        response.<javadoc>sendRedirect</javadoc>(<em>newLocation</em>);<cmt>sends client to the configured URL</cmt></line>
			    <line>    }</line>
			    <line>}</line>
			</code>
			</content>
		</collapsedSubSection>

		<subSection anchor="webapplications">
			<head>Web Applications</head>
			<explanation>
			To deploy your servlet in a web container, you need to package it as a web application and store it in a WAR file. 
			WARs are <em><topic>JARs</topic> with a special file layout</em> and a ".war" extension. They also require a
			<em>deployment descriptor file called <idf>web.xml</idf></em> which must be located at <idf>/WEB-INF/web.xml</idf> in the WAR.
			</explanation>
			<miniHeadline>Web Application Layout</miniHeadline>
			<table>
			<head><cell>Path Pattern</cell><cell>Description</cell></head>
			<row><cell>/*</cell><cell>Static content (HTML, images, stylesheets..) and <topic>JSPs</topic> <more>Any file that you put into a JAR
			will be served by the web container. The only exceptions are files in the special '/WEB-INF' and '/META-INF' directories.<br/>
			Depending on the extension, some files will be served as static content, and some files (like JSPs) will be handled in a special way. 
			The files are reachable under the same path as in the JAR, within the application's context. For example, if your web-application's 
			context URL is 'http://myserver/myapp' and you have a file 'a/b/c.html' in the WAR, its URL is 'http://myserver/myapp/a/b/c.html'.</more></cell></row>
			<row><cell>/WEB-INF/*</cell><cell>All data except static content</cell></row>
			<row><cell>/WEB-INF/web.xml</cell><cell>Deployment descriptor (<link anchor="webxml">shown below</link>)</cell></row>
			<row><cell>/WEB-INF/classes/</cell><cell>The application's Java classes (e.g. your servlet class)</cell></row>
			<row><cell>/WEB-INF/lib/*.jar</cell><cell>Libraries required by the application</cell></row>
			<row><cell>/META-INF/*</cell><cell>optional <topic>JAR</topic> descriptors, vendor extensions <more>As a WAR is technically a JAR, 
			it supports many JAR features. You could, for example, put JAR's <idf>MANIFEST.MF</idf> descriptor there. Some containers also define 
			<idf>META-INF</idf> as location for non-standard
			configuration files. Beside those vendor extensions, <idf>META-INF</idf> is not important for most WARs. You
			only need to know that files in '/META-INF' will not be served as static files.</more></cell></row>
			</table>
			<explanation>There are <em>no required files</em> or directories for WARs. A WAR containing only static files does not 
			need <idf>WEB-INF</idf> at all.</explanation>
			
			<miniHeadline>Creating the Web Application / WAR</miniHeadline>
			<explanation>To create a WAR, you need to</explanation>
			<list>
			    <li>Copy your classes, libraries and static files into the directory structure shown above</li>
			    <li>Create a deployment descriptor at /WEB-INF/web.xml (<link anchor="webxml">see below</link>)</li>
			    <li>Put the whole directory into a WAR archive <more>As said above, a WAR is just a JAR with a special file layout
			    and the file extension ".war". So if you do not have a IDE or build tool that helps you to assemble the web 
			    application, you can always resort to the good old "jar" command line tool. Just write 
			    "jar cvf <idf>myapp.war</idf> <idf>path/to/dir</idf>".</more></li>
			</list>
			<explanation>If you use an IDE (such as Eclipse or Netbeans), <em>the IDE will help you assemble the WAR</em>, so you don't have to do this manually.<br/>
			Also, many application servers allow you to copy the directory directly instead of the deploying a WAR file. This makes deployment faster
			during development.
			</explanation>
		</subSection>
		
		<subSection anchor="webxml">
		<head>web.xml</head>
		<explanation>You need to <em>declare all servlets in the <idf>web.xml</idf> deployment descriptor</em>.
		</explanation>
		<explanation>Here is a very simple <idf>web.xml</idf>, declaring only one servlet and mapping it onto a path:</explanation>
		<config>&lt;?xml version="1.0" encoding="UTF-8"?>
<tag>web-app <doc>xmlns</doc>="http://java.sun.com/xml/ns/j2ee"
         <doc>xmlns:xsi</doc>="http://www.w3.org/2001/XMLSchema-instance"
         <doc>xsi:schemaLocation</doc>="http://java.sun.com/xml/ns/j2ee
                             http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
         <doc>version</doc>="2.4"</tag>
         
    <plainCmt> Declare the servlet class </plainCmt>
    <tag>servlet</tag>
        <tag>servlet-name</tag>timeServlet1<ctag/>
        <tag>servlet-class</tag>com.jarfiller.example.TimeServlet<ctag/>
    <ctag/>
    
    <plainCmt> Declare the URL path handled by this servlet <more>The servlet mapping defines for which path the
    server will invoke the servlet.<br/> This is is the path under which it is reachable by web browsers, minus 
    	the context root which must be declared by you in the web container.<br/>For example, if your server is at
		www.example.org, you define a context root 'timeapp', and the <idf>&lt;url-pattern></idf> is
		'/now', then you can reach the servlet under 'http://www.example.org/timeapp/now'.</more> </plainCmt>
    <tag>servlet-mapping</tag>
        <tag ref="doc-servlet-mapping-servlet-name">servlet-name</tag>timeServlet1<ctag/> <plainCmt><em>much match servlet-name</em> above!</plainCmt>
        <tag ref="doc-servlet-mapping-url-pattern">url-pattern</tag>/now<ctag/>
    <ctag/>
<ctag/>
		</config>
		<explanation>For details on <idf>web.xml</idf>, visit Jarfiller's <link to="../../reference/webxml2x/">Web.xml Reference</link>.</explanation>
		</subSection>

		<collapsedSubSection anchor="applayout">
			<head>Example Layout</head>
			<summary>Example Application Layout</summary>
			<content> 
				<explanation>
				As example, here all files of a web application called <idf>timeapp.war</idf>:</explanation>
				<table>
				<head><cell>File</cell><cell>Description</cell></head>
				<row><cell>/index.html</cell><cell>Default page</cell></row>
				<row><cell>/images/clock.png</cell><cell>An Image (clock)</cell></row>
				<row><cell>/images/logo.png</cell><cell>An Image (clock)</cell></row>
				<row><cell>/WEB-INF/web.xml</cell><cell>Deployment descriptor</cell></row>
				<row><cell>/WEB-INF/classes/com/jarfiller/example/TimeServlet.class</cell><cell>The servlet class</cell></row>
				<row><cell>/WEB-INF/classes/com/jarfiller/example/Helper.class</cell><cell>Some other class</cell></row>
				<row><cell>/WEB-INF/lib/joda-time.jar</cell><cell>A library for the servlet</cell></row>
				</table>
				
		</content>
		</collapsedSubSection>

		<subSection anchor="contextroot">
			<head>Context Root</head>
			<explanation>The <em>context root is the web application's path on the web server</em>. All paths that you configure in <idf>web.xml</idf>
			are <em>relative to the context root</em>. The context root needs to be <em>set in the web container</em> <more>Setting
			your application's context root is <em>container-specific</em>. Containers that allow you to deploy by copying a WAR into 
			a deployment directory usually take <em>the WAR's file name without extension as context root</em> (thus a WAR called
			'myapp.war' gets '/myapp' as context root). Depending on the specific container, you can either set an application's 
			context root in a GUI, declare it in the container's configuration file, or you can declare it in the WAR itself by putting a container-specific 
			configuration file into the '/WEB-INF/' directory.</more>.
			</explanation>
			<explanation>
			Let's assume you have a web container running on <link to="http://en.wikipedia.org/wiki/Localhost">localhost</link> port 8080,
			and you set the context root to 'myapp'. Then all static files and all url patterns are relative to the URL
			"http://localhost:8080/myapp/".<br/>
			If you don't want your application to reside in a directory, you <em>must set your context root to '/'</em>. 
			</explanation>
		</subSection>
				
		<subSection anchor="staticcontent">
			<head>Static Content</head>

			<explanation>All files in a WAR file (except <idf>/WEB-INF/*</idf> and <idf>/META-INF/*</idf>) will automatically be <em>served 
			by the web server as static files</em>, located at the application's base URL
			<more>For example, if you have a file "/images/ball.png" in your WAR and your application is located at
			"http://server/myapp/", you can reach it under "http://server/myapp/images/ball.png".</more>.</explanation>
			<miniHeadline>Content Type / MIME Type Mapping</miniHeadline>
			<explanation>The server determines the content type (MIME type) of static files from their extension. 
				The specification does not require the container to know any extensions, unless you
				define <em>content type mappings in your <idf>web.xml</idf> deployment descriptor</em>:</explanation>
				<config><tag>mime-mapping</tag>
    <tag>extension</tag>html<ctag />
    <tag>mime-type</tag>text/html<ctag />
<ctag />
<tag>mime-mapping</tag>
    <tag>extension</tag>xhtml<ctag />
    <tag>mime-type</tag>application/xhtml+xml<ctag />
<ctag />
				</config>
			<explanation>In practice, common file types such as HTML and PNG are known to containers though, and you don't have to
				define them (hardly anyone does).</explanation>
			<miniHeadline>Welcome Files</miniHeadline>
			<explanation>You can <em>define welcome files</em>, which are the names of files which will be shown
			when a user requests a directory <more>For example, if you define "index.html" as welcome file and a user requests the directory
			"/test/", the server returns the content of the file "/test/index.html".</more>. Without them, the server shows a 
			<idf>404 Not Found</idf> error. This is a welcome file definition for <idf>web.xml</idf>:
			</explanation>
			<config><tag>welcome-file-list</tag>  <cmt>ordered by preference</cmt>
    <tag>welcome-file</tag>index.jsp<ctag />    
    <tag>welcome-file</tag>index.xhtml<ctag />
    <tag>welcome-file</tag>index.html<ctag />
<ctag /></config>
			<explanation></explanation>
		</subSection>
		
		
		
		<collapsedSubSection anchor="eclipse">
			<head>Eclipse</head>
			<summary>How to Create a Web Application with Eclipse</summary>
			<content>
				<explanation>
				Eclipse offers great support for web applications:</explanation>
				<list>
				<li>Create a '<em>Dynamic Web Project</em>' for web applications.</li>
				<li>The <em>'Dynamic Web Module Version' is the Servlet API version</em>. Select "2.5".</li>
				<li>All <em>files in <idf>/WebContent</idf> will be copied into the WAR</em>, in addition to all compiled classes. Use it for static files.</li>
				<li>Eclipse can <em>run and debug your web application directly in a local Tomcat</em> server and most other containers 
				<more>You need to configure
				your server in <idf>Preferences/Server/Runtime Environments</idf>. Then you can add your project to the server, and
				start/stop/debug the server. Eclipse will do everything else for you. It can even automatically re-deploy when you
				change anything in your project.<br/>
				Eclipse ships with support for Tomcat, JBoss and a few others. Plugins for many other servers
        		are available on the web.<br/>
				You can <em>edit the context root</em> in the project's properties / Web Project Settings. So for a server running on 
				port 8080 and a context root 'MyApp', find your application at http://localhost:8080/MyApp/.
				</more>.</li>
				<li>Use 'Export..' with a 'Web/WAR file' destination to create a WAR.</li>
				</list>
				
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="ant">
			<head>Ant Packaging</head>
			<summary>How to Create a Web Application (WAR) with Ant</summary>
			<content>
				<explanation>
				Use <link to="http://ant.apache.org/">Ant</link>'s <link to="http://ant.apache.org/manual/CoreTasks/war.html">war</link> task to create WAR files.
				You only need to specify the location of the WAR, the web.xml and your files:
				</explanation>
				<config>&lt;war destfile="build/timeapp.war" webxml="WebContent/WEB-INF/web.xml">
    &lt;fileset dir="WebContent/"/>     &lt;!-- Copy static files -->
    &lt;lib dir="lib/"/>                &lt;!-- Copy all libraries (*.jar) -->
    &lt;classes dir="build/classes/"/>  &lt;!-- Copy classes -->
&lt;/war>   
				</config>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="tomcat">
			<head>Tomcat</head>
			<summary>How to Deploy a Web Application on Tomcat</summary>
			<content>
				<explanation>Deployment of web applications in Tomcat is very easy:</explanation>
				<list>
				<li>To deploy an application, <em>copy the WAR into Tomcat's <idf>webapps</idf> directory</em>. The application will start automatically.</li>
				<li>Alternatively, you can also <em>copy web application directories</em> (extracted WARs) into <idf>webapps</idf>.</li>
				<li>You can configure your application either <em>by editing Tomcat's <idf>conf/context.xml</idf> file</em>, or by putting a file
				<idf>/META-INF/context.xml</idf> into your web application. Read Tomcat's
				<link to="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html">Context Configuration documentation</link>.</li>
				<li>The <em>context root is the application's WAR file name</em> (without extension) if you copied a WAR, or the directory name for directories.
				If the WAR file is called <idf>ROOT.war</idf> (or you copy a directory called <idf>ROOT</idf>), it will be deployed with the
				context root "/".</li>
				</list>
				
			</content>
		</collapsedSubSection>
	</singleColumnSection>

	<singleColumnSection anchor="responses">
		<head>Responses</head>
	
		<subSection anchor="textoutput">
			<head>Text Output</head>
			<more>Before you can send a text as response, you need to <em>set the content type</em> of the response
			(<idf>setContentType</idf>) and optionally the character encoding (<idf>setCharacterEncoding</idf>). 
			Then <em>retrieve a <idf>Writer</idf></em> using <idf>getWriter</idf> from the <idf>HttpServletResponse</idf>, 
			and use the <idf>Writer</idf>'s methods to write the body.</more>
			<code>
<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
<line>import <javadoc>java.io.*</javadoc>;</line>
<emptyLine/>
<line><plainCmt>Servlets that shows the current time</plainCmt></line>
<line>public class TimeServlet extends <javadoc>HttpServlet</javadoc> {</line>
<emptyLine/>
<line>  protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
<line>      throws <javadoc>IOException</javadoc> {</line>
<emptyLine/>   
<line>    response.<javadoc><em>setContentType</em></javadoc>("text/html; charset=UTF-8");<cmt><em>required</em>: HTML in UTF-8 <more>You must always set the
<em>content type</em> of your response (also called <em>internet media type</em> or <em>MIME type</em>). 
Basically it does what file extensions do for files - telling the browser what kind of document it is receiving.<br/>
A good entry point to find the right content type is the <link to="http://en.wikipedia.org/wiki/Internet_media_type">Internet Media Type 
page on Wikipedia</link>.<br/>
For some text formats (HTML and plain text in particular), you should <em>specify the <idf>charset</idf> attribute</em>, as shown here, to tell
the browser about the encoding you use.
</more></cmt></line>
<line>    response.<javadoc><em>setCharacterEncoding</em></javadoc>("UTF-8");<cmt>recommended: use UTF-8 <more>Usually you can't do 
anything wrong when you set the character set to "UTF-8". It's widely supported and works with every character that
is possible in Java. The default, "ISO-8859-1", only works with western european languages.</more></cmt></line> 
<emptyLine/>   
<line>    <javadoc>PrintWriter</javadoc> writer = response.<javadoc><em>getWriter</em></javadoc>(); <cmt>writer for sending text <more id="more-getwriteroutputstream">After setting
headers (such as content type and character encoding), you need to <em>write the response body</em>. Here you have a choice between
getting a <idf>Writer</idf> for text and getting an <idf>OutputStream</idf> for binary data. Once you have the 
<idf>Writer</idf> or <idf>OutputStream</idf>, just write your response. <br/>
<em>Closing the stream is not required</em>, the web container will do this automatically as soon as the service method ends.</more></cmt></line>
<line>    writer.<javadoc>print</javadoc>("&lt;html>&lt;head>&lt;title>Time&lt;/title>&lt;/head>&lt;body>");</line>
<line>    writer.<javadoc>print</javadoc>("The current time is: ");</line>
<line>    writer.<javadoc>print</javadoc>((new java.util.Date()).toString());</line>
<line>    writer.<javadoc>print</javadoc>("&lt;/body>&lt;/html>");</line>
<line>  }</line>
<line>}</line>
			</code>
		</subSection>
		
		<subSection anchor="responsebinary">
			<head>Binary Output</head>
			<more>Before you can send a binary document as response, you need to <em>set the content type</em> 
			(<idf>setContentType</idf>). 
			Then <em>retrieve an <idf>OutputStream</idf></em> using <idf>getOutputStream</idf> from the <idf>HttpServletResponse</idf>, 
			and use the <idf>OutputStream</idf>'s methods to write the body.</more>
			
			<code>
				<line>import <javadoc>java.io.*</javadoc>;</line>
				<line>import <javadoc>java.util.*</javadoc>;</line>
				<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
				<emptyLine/>
				<line><plainCmt>Servlet that sends one of two PNG images, depending on time of day</plainCmt></line>
				<line>public class AmPmFileServlet extends <javadoc>HttpServlet</javadoc> {</line>
				<emptyLine/>
				<line>  <plainCmt>simple helper: copy data from InputStream to OutputStream</plainCmt></line>
				<line>  private void copy(<javadoc>InputStream</javadoc> in, <javadoc>OutputStream</javadoc> out) </line>    
				<line>      throws <javadoc>IOException</javadoc> {</line>
    			<line>    byte buffer[] = new byte[4096];</line>
    			<line>    while (true) {</line>
    			<line>      int r = in.<javadoc to="http://java.sun.com/javase/6/docs/api/java/io/InputStream.html#read(byte[])">read</javadoc>(buffer);</line>
    			<line>      if (r &lt; 0) <cmt>end of stream?</cmt></line>
    			<line>        break;</line>
    			<line>      out.<javadoc to="http://java.sun.com/javase/6/docs/api/java/io/OutputStream.html#write(byte[], int, int)">write</javadoc>(buffer, 0, r);</line>
    			<line>    }</line>
    			<line>  }</line>
    			<emptyLine/>
				<line>  protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>      throws <javadoc>IOException</javadoc> {</line>
    			<emptyLine/>
    			<line>    <plainCmt>before or after noon? determine path to the right image in the WAR</plainCmt></line>
    			<line>    boolean isPM = new <javadoc>GregorianCalendar</javadoc>().get(<javadoc>Calendar.AM_PM</javadoc>) == <javadoc>Calendar.PM</javadoc>; </line>
    			<line>    String resName = "/WEB-INF/images/time" + (isPM ? "PM" : "AM") + ".png";</line>
    			<emptyLine/>
    			<line>    response.<javadoc><em>setContentType</em></javadoc>("image/png");<cmt>required: content type PNG</cmt></line>
    			<line>    <javadoc>OutputStream</javadoc> out = response.<javadoc><em>getOutputStream</em></javadoc>();<cmt>stream for binary files <more ref="more-getwriteroutputstream"/></cmt></line>
     			<line>    <javadoc>InputStream</javadoc> in = <javadoc>getServletContext</javadoc>().<javadoc>getResourceAsStream</javadoc>(resName);</line>
    			<line>    <em>copy</em>(in, out);<cmt>copy file to client</cmt></line>
    			<line>  }</line>
    			<line>}</line>
			</code>
		</subSection>
		
		
		<collapsedSubSection anchor="buffering">
			<head>Buffering</head>
			<summary>Buffering and Committing</summary>
			<content>
			    <explanation>As long as you <em>set the Content Type and other headers before writing the actual data</em>, your servlet will always work fine.
			    However, the Servlet API allows you a bit more flexibility when you understand its <em>buffering mechanism</em>: </explanation>
			    
			    <list>
			        <li>The web container <em>buffers all data</em> that you write to the client</li>
			        <li><em>Data will be sent to the client when ...</em>
			        <list>
			            <li>the buffer's capacity is exceeded, or</li>
			            <li>you call <javadoc>flushBuffer</javadoc>, or</li> 
			            <li>the amount of bytes specified with <javadoc>setContentLength</javadoc> has been written, or</li>
			            <li>the <javadoc>OutputStream</javadoc> or <javadoc>PrintWriter</javadoc> has been closed, or</li>
			            <li>the service method (doGet, doPost etc) has finished.</li>
			        </list></li>
			        <li>Use <javadoc>getBufferSize</javadoc> to get the buffer size.</li>  
			        <li>You may set the buffer size with <javadoc>setBufferSize</javadoc>, but only <em>before getting the stream/writer</em>.</li>  
			        <li><em>The response is <idf>committed</idf></em> as soon as data has been sent to the client. </li>
			        <li>Find out whether the response is committed using <javadoc>isCommitted</javadoc>.</li>
			        <li>The following things are only allowed <em>before the response is committed</em>:  
			        <list>
			            <li>setting headers <more>This includes every operation that modifies headers, including setting the content
			            type, content length and setting cookies.</more></li>
			            <li>clearing the buffer with <javadoc>resetBuffer</javadoc> <more>If you call <idf>resetBuffer</idf>, the buffer
			            will be cleared, and anything that you have written so far will be discarded. This means, that you
			            can start all over again. Unlike <idf>reset</idf>, <idf>resetBuffer</idf> will not modify headers.</more></li>
			            <li>clearing buffer and headers with <javadoc>reset</javadoc> <more>If you call <idf>reset</idf>, all headers 
			            and the buffer will be cleared, and anything that you have written so far will be discarded. This means that you
			            can start all over again.</more></li>
			        </list>
			        </li>
			    </list>
			   
			</content>
		</collapsedSubSection>
		
		<subSection anchor="errors">
			<head>Error Code</head>
			<more>The Servlet API has a simple convenience method to <em>send a standard error page</em> to the user. <br/>The standard
			error page should only be used <em>for unexpected errors</em> that users usually do not run into. For example, if your database
			is not available, the error page with error code may be ok. If the user entered a wrong value into a form, an error code is
			not appropriate and you should explain the user her mistake more gently.<br/>
			The <idf>web.xml</idf> deployment descriptor lets you customize the page that will be shown with the
			<tag>error-page</tag> element.<br/>
			<idf>sendError</idf> will only work correctly if the <em>response is not committed</em> yet.:</more>
			<code>
				<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>    throws <javadoc>IOException</javadoc> {</line>
    			<emptyLine/>
    			<line>  <plainCmt>send status code 403 <more>The <idf>HttpServletResponse</idf> class 
    			offers constants for all HTTP status codes. It will be shown to the user together with the text you provide as second argument.
    			By default, the web container provides its own page to show. You can customize it in the <idf>web.xml</idf> deployment descriptor
    			with the <tag>error-page</tag> element.</more>:</plainCmt></line>
    			<line>  response.<javadoc><em>sendError</em></javadoc>(<javadoc>HttpServletResponse.SC_FORBIDDEN</javadoc>, "Access not allowed");</line>
    			<line>  <plainCmt>Important: return from service method immediately <more id="more-sendxx-return">After invoking
    			<idf>sendError</idf> or <idf>sendRedirect</idf> you should usually <em>return immediately from the service method</em>, as the response for
    			the client has already been sent. It is a common error to forget a <idf>return</idf> after the invocation and
    			go on processing, often leading to bugs that are hard to find.</more></plainCmt></line>
    			<line>}</line>
    		</code>
		</subSection>
		
		<subSection anchor="redirection">
			<head>Redirection</head>
			<more>To <em>redirect the client</em> to a different URL use the <idf>sendRedirect</idf> method. Redirecting
			is often useful for various reasons, but be careful with it: it breaks the back button for the user (if the user want to go back, she
			will be redirected again).<br/>
			<idf>sendRedirect</idf> will only work correctly if the <em>response is not committed</em> yet.</more>
			<code>
				<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>    throws <javadoc>IOException</javadoc> {</line>
    			<emptyLine/>
    			<line>  response.<javadoc><em>sendRedirect</em></javadoc>("http://jarfiller.com/");</line>
    			<line>  <plainCmt>Important: return from service method immediately <more ref="more-sendxx-return"/></plainCmt></line>
    			<line>}</line>
    		</code>
		</subSection>
	</singleColumnSection>
	
	<singleColumnSection anchor="requests">
		<head>Requests</head>
		
		<subSection anchor="reqparameters">
			<head>Request Parameters</head>
			<more>Requests parameters are usually <em>values sent by a form</em> on an HTML page. Parameters are very simple: each has <em>a name</em>
			(corresponding to the form input's name) and a simple <em>string as value</em> (containing the user's input or, for buttons, a value specified
			in the HTML). You can retrieve a parameter's value using <idf>HttpServletResponse</idf>'s <idf>getParameter</idf> method. It is possible that 
			there's more than one parameter with the same name - you can then retrieve the complete list using <idf>getParameterValues</idf>. To find
			out which parameters have been sent use <idf>getParameterMap</idf> or <idf>getParameterNames</idf>.</more>
			<code>
				<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
				<line>import <javadoc>java.io.*</javadoc>;</line>
				<emptyLine/>
				<line><plainCmt>Servlet that shows a simple form with two text fields, </plainCmt></line>
				<line><plainCmt>allowing the user to enter numbers and showing their sum</plainCmt></line>
				<line>public class CalculatorServlet extends <javadoc>HttpServlet</javadoc> {</line>
				<emptyLine/>
				<line>  <plainCmt>Prints the calculator HTML</plainCmt></line>
				<line>  private void printCalculator(<javadoc>HttpServletResponse</javadoc> response, Integer result) </line>
				<line>      throws <javadoc>IOException</javadoc> {</line>
				<emptyLine/>
				<line>    response.<javadoc>setContentType</javadoc>("text/html; charset=UTF-8");<cmt>HTML in UTF8</cmt></line>
				<line>    response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
				<emptyLine/>
				<line>    <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
				<line>    writer.<javadoc>print</javadoc>("&lt;html>&lt;head>&lt;title>Calculator&lt;/title>&lt;/head>&lt;body>");</line>
				<line>    writer.<javadoc>print</javadoc>("&lt;form>&lt;input <em>name='x'</em>> + &lt;input <em>name='y'</em>> &lt;input type='submit' value='='> ");</line>
				<line>    if (result != null)</line>
				<line>      writer.<javadoc>print</javadoc>(result);</line>
				<line>    writer.<javadoc>print</javadoc>("&lt;/form>&lt;/body>&lt;/html>");</line>
				<line>  }</line>
				<emptyLine/>
				<line>  <plainCmt>handles GET and POST <more>This method is called by <idf>doGet</idf> and <idf>doPost</idf> to handle
				both commands. GET will be used the first time the user visits the page - if a user enters a URL or follows a link, the
				browser uses GET. POST will be used for posting the form.</more></plainCmt></line>
				<line>  private void doAll(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>      throws <javadoc>IOException</javadoc> {</line>
				<emptyLine/>
				<line>    Integer result = null;</line>
				<line>    String x = request.<javadoc><em>getParameter</em></javadoc>("x");</line>
				<line>    String y = request.<javadoc><em>getParameter</em></javadoc>("y");</line>
				<emptyLine/>
				<line>    <plainCmt>validation: check parameters are numeric <more>The following line tests whether both parameters
				have been set and are numeric. <em>Parameters validation of  is very important</em> and a frequent source of
				security issues, as users can send any string as parameters. Always be sure to <em>only accept those values that
				you can handle</em> and ignore or return errors for everything else.</more></plainCmt></line>
				<line>    if (x != null &amp;&amp; y != null &amp;&amp;</line>
				<line>        x.<javadoc>matches</javadoc>("[0-9]+") &amp;&amp; y.<javadoc>matches</javadoc>("[0-9]+")) {</line>
				<emptyLine/>
				<line>      result = Integer.parseInt(x) + Integer.parseInt(y);</line>
				<line>    }</line>
				<emptyLine/>
				<line>  protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>      throws <javadoc>IOException</javadoc> {</line>
				<line>    doAll(request, response);</line>
				<line>  }</line>
				<line>  protected void <javadoc>doPost</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>      throws <javadoc>IOException</javadoc> {</line>
				<line>    doAll(request, response);</line>
				<line>  }</line>
				<line>}</line>
			</code>
		</subSection>
	
		<collapsedSubSection anchor="parameternames">
			<head>Parameter Names</head>
			<summary>How to find out which parameters have been sent</summary>
			<content>
				<explanation>The Servlet API offers two ways of getting a list of all parameters. <javadoc>getParameterNames</javadoc>
				returns an <annotated><title>Enumeration</title>
				<explanation><idf>java.util.Enumeration</idf> is the predecessor of <idf>Iterator</idf> and was
				used before Java 1.2 - as you can see the Servlet API is really old! Use <idf>Collections.list</idf> to convert the
				result into a modern <idf>ArrayList</idf>.</explanation></annotated><javadoc></javadoc> of names. The alternative, <javadoc>getParameterMap</javadoc>, returns a 
				<javadoc>Map</javadoc> of all parameter name/value pairs, but with one catch: the <em>value is a String array</em> 
				<more ref="more-parameter-values"/>.</explanation>
				<explanation>The following example uses <javadoc>getParameterMap</javadoc> to print all request parameters that it got:</explanation>
				
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>    throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>  response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");<cmt>plain text <more id="more-plain-text-servlet">This servlet returns 
plain text instead of HTML. For trying things out plain text is often more convenient.</more></cmt></line>
					<line>  response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<line>  <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<emptyLine/>
					<line>  <javadoc>Map</javadoc>&lt;String, String[]> params = (<javadoc>Map</javadoc>&lt;String, String[]>) request.<javadoc><em>getParameterMap</em></javadoc>();</line>
					<emptyLine/>
					<line>  writer.<javadoc>println</javadoc>("Request parameters:");</line>
					<line>  for (String name: params.<javadoc>keySet</javadoc>())</line>
					<line>    for (String value: params.<javadoc to="http://java.sun.com/javase/6/docs/api/java/util/Map.html#get(java.lang.Object)">get</javadoc>(name)) <cmt><em>values are arrays</em> <more id="more-parameter-values">It 
is possible in HTTP that there 	is more than one name/value pair with the same name. That's why <em>the map contains string 
arrays</em> as values. Some mean people would add that Java designers prefer correctness over ease-of-use, but don't quote me on that!</more></cmt></line>
					<line>      writer.<javadoc>printf</javadoc>("%s=%s\n", name, value); <cmt>formatted print <more id="more-printf">The example uses
<idf>PrintWriter</idf>'s <idf>printf</idf> method. It formats the string exactly like <idf>String.format</idf> does. If you don't
know <idf>String.format</idf>, check out its Javadocs now - it will save you a lot of time!</more></cmt></line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
	
		<collapsedSubSection anchor="headers">
			<head>Headers</head>
			<summary>How to read header values</summary>
			<content>
				<explanation>This example reads the <idf>User-Agent</idf> request header sent by the client to guess the user's browser 
				<more>Every browser version has a distinct <idf>User-Agent</idf> value. However, <em>a browser may lie</em> and give you a wrong
				value (usually the same as some more popular browser to increase compatibility). Furthermore, browsers try to
				include keywords from other browsers if they share the same features. All this makes interpreting the <idf>User-Agent</idf>
				an art of its own.</more>:</explanation>
								<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>    throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>  response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");<cmt>plain text <more ref="more-plain-text-servlet"/></cmt></line>
					<line>  response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<emptyLine/>
					<line>  String userAgent = request.<em><javadoc>getHeader</javadoc>("User-Agent")</em>;</line>
					<emptyLine/>
					<line>  String browserGuess = "some other browser";</line>
					<line>  if (userAgent != null) {</line>
					<line>    if (userAgent.contains("Firefox/"))</line>
					<line>      browserGuess = "Firefox";</line>
					<line>    else if (userAgent.contains("MSIE"))</line>
					<line>      browserGuess = "Internet Explorer";</line>
					<line>  }</line>
					<emptyLine/>
					<line>  response.<javadoc>getWriter</javadoc>().<javadoc>println</javadoc>("Request parameters:");</line>
					<line>}</line>
				</code>
				<explanation>Find out more about browser detection in the <link anchor="browserdetection">browser detection section</link> below.</explanation>
			</content>
		</collapsedSubSection>
		
		<subSection anchor="paths">
			<head>Paths</head>
			<explanation>With the <tag>servlet-mapping</tag> element you can define for which paths your servlet will be invoked. Paths are <em>defined using
			URL patterns</em>.</explanation>
			<miniHeadline>URL Pattern</miniHeadline>
			<explanation>The <tag ref="doc-servlet-mapping-url-pattern">url-pattern</tag> element in the servlet mapping supports 
			<em>only two kinds of wildcards</em>:</explanation>
			<list><li>'/*' at the end, to <em>map the servlet on a virtual directory</em></li>
			<li>'*.ext', to <em>map the servlet on a file extension</em></li></list>
			<explanation>Other uses of wildcards are not allowed.</explanation>
			<miniHeadline>Servlet Mapping</miniHeadline>
			<explanation>This <idf>web.xml</idf> snippet maps the servlet both on the directory '/libs' and the file extension
			'*.do':</explanation>
			<config><tag>servlet-mapping</tag>
    <tag ref="doc-servlet-mapping-servlet-name">servlet-name</tag>myServlet<ctag/> 
    <tag ref="doc-servlet-mapping-url-pattern">url-pattern</tag><em>/libs/*</em><ctag/>
<ctag/>
<tag>servlet-mapping</tag>
    <tag ref="doc-servlet-mapping-servlet-name">servlet-name</tag>myServlet<ctag/> 
    <tag ref="doc-servlet-mapping-url-pattern">url-pattern</tag><em>*.do</em><ctag/>
<ctag/>
		</config>
			<miniHeadline>Path Methods</miniHeadline>
			<explanation>When using wildcards like this, there are a number of <em>methods in <javadoc>HttpServletRequest</javadoc> to
			find out the request path</em>:</explanation>
			<list>
				<li><javadoc>getRequestURI</javadoc> - the <em>complete path</em>, starting at the server's root</li>
				<li><javadoc>getContextPath</javadoc> - the <em>context root</em> of the servlet (empty for context root "/")</li>
				<li><javadoc>getServletPath</javadoc> - for <annotated id="doc-directory-url-pattern"><title>directory patterns</title><explanation><idf>&lt;url-pattern</idf>
				elements that end with a wildcard and thus specify a directory (e.g. '/images/*').</explanation></annotated>: <em>the mapped directory</em>; for 
				<annotated id="doc-extension-url-pattern"><title>extension patterns</title><explanation><idf>&lt;url-pattern</idf>
				elements that start with a wildcard and describe a extension (e.g. '*.html').</explanation></annotated>: path relative to context root</li>
				<li><javadoc>getPathInfo</javadoc> - for <annotated ref="doc-directory-url-pattern"/>: path <em>relative to servlet path</em>; 
				for <annotated ref="doc-extension-url-pattern"/>: always <idf>null</idf></li>
			</list>
			<miniHeadline>URL Examples</miniHeadline>
			<explanation>Assuming the servlet mapped above has the context root 'myapp', here a few example URLs and their resulting paths:</explanation>
			<table>
				<head><cell>URL</cell><cell>getRequestURI</cell><cell>getContextPath</cell><cell>getServletPath</cell><cell>getPathInfo</cell></head>
				<row><cell>http://localhost/myapp/lib/x/y/a.htm</cell><cell>/myapp/lib/x/y/a.htm</cell><cell>/myapp</cell><cell>/lib</cell><cell>/x/y/a.htm</cell></row>
				<row><cell>http://localhost/myapp/lib/abc/</cell><cell>/myapp/lib/abc/</cell><cell>/myapp</cell><cell>/lib</cell><cell>/abc/</cell></row>
				<row><cell>http://localhost/myapp/help.do</cell><cell>/myapp/help.do</cell><cell>/myapp</cell><cell>/myapp/help.do</cell><cell><idf>null</idf></cell></row>
				<row><cell>http://localhost/myapp/abc/run.do</cell><cell>/myapp/abc/run.do</cell><cell>/myapp</cell><cell>/myapp/abc/run.do</cell><cell><idf>null</idf></cell></row>
			</table>
			<miniHeadline>Root Pattern</miniHeadline><explanation>			
			You can also set the <tag ref="doc-servlet-mapping-url-pattern">url-pattern</tag> to "/". The <em>servlet will then handle all paths</em>,
			and the path methods return the same values as they do for mapped extensions.
			</explanation>
		</subSection>
	</singleColumnSection>

	<singleColumnSection anchor="sessionsandcookies">
		<head>Sessions and Cookies</head>
		<subSection anchor="cookies">
			<head>Cookies</head>
			<more>The Servlet API represents cookies with the <idf>Cookie</idf> object. Use 
			<idf>getCookies</idf> on the request to get a list of all cookies sent by the client. In order to add
			or update a cookie, use the response's <idf>addCookie</idf> method.</more>
			<code>
				<line>final static String COOKIE_NAME = "visitCounter";</line>
				<emptyLine/>
				<line><plainCmt>This method uses <annotated id="annotated-cookies"><title>cookies</title><explanation>Cookies are
			name/value string pairs that a server can store in the browser to store things such as the user's identity and 
			configuration. In the browser's request it sends all cookies that it has for the server name. In the server's response, the
			server can add or overwrite cookies by sending a special header.<br/>
			To learn more about cookies, read <link to="http://en.wikipedia.org/wiki/HTTP_cookie">HTTP Cookie</link> on 
			Wikipedia.</explanation></annotated> to find out how many times the user</plainCmt></line>
			    <line><plainCmt>has visited the servlet before:</plainCmt></line>
				<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>      throws <javadoc>IOException</javadoc> {</line>
				<emptyLine/>
				<line>    response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");<cmt>plain text <more ref="more-plain-text-servlet"/></cmt></line>
				<line>    response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
				<line>    <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
				<emptyLine/>
				<line>    <plainCmt>Finding the cookie (if it exists)</plainCmt></line>
				<line>    int visits = 0;</line>
				<line>    if (request.<javadoc>getCookies()</javadoc> != null) <cmt>may be null if no cookies <more>Unfortunately, if there is is no cookie sent by the
				browser, <idf>getCookies</idf> returns null instead of an empty array. So you always need to check for null first.</more></cmt></line>
				<line>        for (<javadoc>Cookie</javadoc> c: request.<javadoc><em>getCookies</em></javadoc>())</line>
				<line>            if (c.<javadoc>getName</javadoc>().equals(COOKIE_NAME) &amp;&amp; c.<javadoc>getValue</javadoc>().<javadoc>matches</javadoc>("[0-9]+"))</line>
				<line>                visits = Integer.parseInt(c.<javadoc>getValue</javadoc>());</line>
				<emptyLine/>
				<line>    <plainCmt>Print a message for the user</plainCmt></line>
				<line>    if (visits == 0)</line>
				<line>        writer.<javadoc>println</javadoc>("This is your first visit.");</line>
				<line>    else</line>
				<line>        writer.<javadoc>printf</javadoc>("This is visit number %d.\n", visits);<cmt>formatted printing <more ref="more-printf"/></cmt></line>
				<emptyLine/>
				<line>    <plainCmt>Set / Update the cookie <more>To modify a cookie, <em>create a new <idf>Cookie</idf></em> instance and
				set it with <idf>addCookie</idf>.<br/>
				Only modifying a <idf>Cookie</idf> returned by <idf>getCookies</idf> will not work, you <em>always need to call <idf>addCookie</idf></em> to 
				update a cookie, even if the cookie already exists!</more></plainCmt></line>
				<line>    <javadoc>Cookie</javadoc> c = <em>new <javadoc>Cookie</javadoc></em>(COOKIE_NAME, Integer.toString(visits + 1));</line>
				<line>    c.<javadoc><em>setMaxAge</em></javadoc>(60*60*24*28);<cmt>valid for 28 days <more>By default, a cookie is only
				<em>valid for the current session</em>. That means that the browser will forget about the cookie as soon as it is closed. 
				In order to let the browser save the cookie, you need to <em>give it an expiration date</em> as shown here. <br/>
				The value passed to <idf>setMaxAge</idf> is the cookie's <em>maximum age in seconds</em>.</more></cmt></line>
				<line>    response.<javadoc><em>addCookie</em></javadoc>(c);</line>
				<line>}</line>
			</code>
		</subSection>
		
		<subSection anchor="sessions">
			<head>Sessions</head>
			<explanation><javadoc>HttpSession</javadoc> allows you to <em>store arbitrary objects</em> for a user
			as named <em>attributes</em>. Sessions are <em>managed by the web container</em>, which <em>associates a session id with 
			every session</em> and uses mechanisms such as cookies to <em>store the session id in the client</em> <more>Storing the session id
			in a cookie is the most important way for the container to connect sessions to browsers, but there are others: if the
			connection is SSL-encrypted (HTTPS), <em>SSL's session mechanism</em> will be used. As a third option, the container may <em>rewrite
			URLs</em> and add the session id to them. The latter approach works with every browset, but you have to modify every single link on your pages
			using the <idf>encodeURL</idf> string rewriting method.<br/>
			Note that the session implementation's <em>details are container-specific</em>.</more>.<br/>
			Sessions are typically <em>short lived</em>, and do not survive neither a browser-restart nor a server-restart 
			<more>Web containers <em>use session-only cookies to store the session id</em>. Thus the session is lost when the
			browser is restarted, and the server will create a new one.<br/>
			By default, containers <em>do not persist the http sessions</em>, and thus all sessions are lost on restart. 
			Some containers offer you container-specific way to store sessions though, for clustering (several servers sharing
			the same session objects) or to allow restarts without losing sessions. <br/>
			If you need to store data about the user for a longer time, you should use cookies.
			</more>.</explanation>
			<explanation>The following example implements a visitor counter with HttpSessions:</explanation>
			
			<code>
				<line>final static String ATTRIBUTE_NAME = "visitCounter";</line>
				<emptyLine/>
				<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>      throws <javadoc>IOException</javadoc> {</line>
				<emptyLine/>
				<line>    response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");<cmt>plain text <more ref="more-plain-text-servlet"/></cmt></line>
				<line>    response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
				<line>    <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
				<emptyLine/>
				<line>    <plainCmt>Reading the session</plainCmt></line>
				<line>    int visits = 0;</line>
				<line>    <javadoc>HttpSession</javadoc> session = request.<javadoc>getSession</javadoc>();<cmt>can create session <more><idf>getSession</idf> returns the user's
				session if there is already one. Otherwise it creates a new session.</more></cmt></line>
				<line>    if (session.<javadoc>getAttribute</javadoc>(ATTRIBUTE_NAME) != null)<cmt>not set in new sessions</cmt></line>
				<line>        if (c.<javadoc>getName</javadoc>().equals(COOKIE_NAME) &amp;&amp; c.<javadoc>getValue</javadoc>().<javadoc>matches</javadoc>("[0-9]+"))</line>
				<line>            visits = (Integer) session.<javadoc>getAttribute</javadoc>(ATTRIBUTE_NAME);</line>
				<emptyLine/>
				<line>    <plainCmt>Print a message for the user</plainCmt></line>
				<line>    if (visits == 0)</line>
				<line>        writer.<javadoc>println</javadoc>("This is your first visit.");</line>
				<line>    else</line>
				<line>        writer.<javadoc>printf</javadoc>("This is visit number %d.\n", visits);<cmt>formatted printing <more ref="more-printf"/></cmt></line>
				<emptyLine/>
				<line>    <plainCmt>Update the session</plainCmt></line>
				<line>    session.<javadoc>setAttribute</javadoc>(ATTRIBUTE_NAME, visits + 1);</line>
				<line>    session.<javadoc>setMaxInactiveInterval</javadoc>(60*60*24);<cmt>valid for 24 hours max</cmt></line>
				<line>}</line>
			</code>
			
		</subSection>
		<collapsedSubSection anchor="distributablesessions">
			<head>Distributable Sessions</head>
			<summary>Sessions in Distributed Servers (Clusters)</summary>
			<content><explanation>When you configure your web application to be <em>distributable</em> (thus you have not a single container, but
			a cluster of containers hosting your application), you must be sure that you <em>store only <topic>serializable</topic> objects</em>
			in the session (some containers also support EJB references). Distributable containers can move sessions across servers, and
			serialization allows the container to do this. Objects stored in a session can implement 
			the <javadoc>HttpSessionActivationListener</javadoc> interface to be notified before and after such a migration.</explanation>
			<explanation>See also <link anchor="distributedapps">How to Write Distributed Applications</link> below.</explanation>
			</content>
		</collapsedSubSection>
		<collapsedSubSection anchor="sessioncaveat">
			<head>Session Caveat</head>
			<summary>Be Careful When Using HttpSession</summary>
			<content>
				<explanation>
					<javadoc>HttpSession</javadoc> looks simple and easy to use. In practice, however, you should
					<em>consider carefully what you store in a session</em>. There are three pitfalls:</explanation>
					<orderedList>
						<li>Attribute values put into the session will be <em>accessed by several threads simultanously</em>, so
						proper synchronization and/or thread-safe objects are required.</li>
						<li>In general, you should <em>store only the user's identity and configuration</em> in the session. Using it for most 
						other purposes,	for example storing the state of a multi-page form in the session, is a very bad idea <more>The problem is that users
						will not go through pages linearly. They may use the browser's back button to revisit a page, or open a new tab
						and go through the multi-page form with several tabs at the same time. Another common pitfall is that many people
						double-click links and thus may submit the content twice. <br/>
						If you write a multi-page-form, you should store all data as hidden fields in the form. Everything else is a nightmare
						to debug.</more>.</li>
						<li>When working with sessions, <em>be careful about memory use</em>. If you store large objects in your session and
						have many visitors, you may run out of heap memory. Be aware that <em>people with disabled cookies create a new session
						with every hit</em>, because they always look like a new visitor to the server.</li>
					</orderedList>
					<explanation>Often <em>using cookies is easier than using sessions</em>. You may need to write a few more lines to use them,
					but they are easier to debug and implement correctly. 
				</explanation>
			</content>
		</collapsedSubSection>
	</singleColumnSection>
		

	<singleColumnSection anchor="resources">
		<head>Resources</head>
		<subSection anchor="resourceannotations">
			<head>Resource Annotations</head>
			<explanation>To configure your servlet for the web container's environment, <em>declare required resources
			with the <javadoc>@Resource</javadoc> annotation</em> in the servlet. The container will <em>inject those resources right after instantiation</em> 
			(but before <javadoc>init</javadoc> is called).<br/>
			The <annotated id="annotated-deployer"><title>deployer</title><explanation>The person installing the application on the server.</explanation></annotated>
			is responsible for configuring the web container to provide the values required by the application. The <em>configuration itself
			is container-specific</em>.
			</explanation>
			<explanation>The following Servlet declares a requirement for a String and a <topic>JDBC</topic> <javadoc>DataSource</javadoc>:</explanation>
			<code>
				<line>package com.jarfiller.example;</line>
				<emptyLine/>
				<line>import <javadoc>javax.sql.*</javadoc>;</line>
				<line>import <javadoc>java.sql.*</javadoc>;</line>
				<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
				<line>import <javadoc>javax.servlet.*</javadoc>;</line>
				<line>import <javadoc>javax.annotation.*</javadoc>;</line>
				<line>import <javadoc>java.io.*</javadoc>;</line>
				<emptyLine/>
				<line>public class ResourceServlet extends <javadoc>HttpServlet</javadoc> {</line>
				<emptyLine/>
				<line>  <em><javadoc>@Resource</javadoc>(name="jdbc/db")</em></line>
				<line>  private <javadoc>DataSource</javadoc> db;<cmt>inject database connection <more><idf>@Resource</idf> tells the container that the
servlet <em>requires a JDBC <idf>DataSource</idf> with the JNDI name 'jdbc/db'</em>. The deployer is responsible for configuring the
container to provide it. The container will <em>inject the value</em> into the field after instantiation.</more></cmt></line>
				<emptyLine/>
				<line>  <em><javadoc>@Resource</javadoc>(name="param/webmaster")</em></line>
				<line>  private String webmaster;<cmt>inject string <more><idf>@Resource</idf> tells the container that the
servlet <em>requires a String with the JNDI name 'param/webmaster'</em>. The deployer is responsible for configuring the
container to provide it. The container will <em>inject the value</em> into the field after instantiation.</more></cmt></line>
				<emptyLine/>
				<line>  protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
				<line>        throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
				<line>    try {</line>
				<line>      <javadoc>Connection</javadoc> connection = <em>db</em>.<javadoc>getConnection</javadoc>();<cmt>use injected value</cmt></line>
				<emptyLine/>
				<line>      <plainCmt><abstract>do something ...</abstract></plainCmt></line>
				<emptyLine/>
				<line>    }</line>
				<line>    catch (<javadoc>SQLException</javadoc> e) {</line>
				<line>      throw new <javadoc>ServletException</javadoc>(e); <cmt>simple error handling <more id="more-servletexception">The easiest way
				to handle an unexpected problem is to throw a <idf>ServletException</idf>. The server will return an error
				page with HTTP status code 500 (internal error).</more></cmt></line>
				<line>    }</line>
				<line>  }</line>
				<line>}</line>
			</code>
		</subSection>
		
		<collapsedSubSection anchor="jndilookup">
			<head>JNDI Lookup</head>
			<summary>How to get resources with JNDI</summary>
			<content>
				<explanation>Instead of declaring resources with JNDI, you can also <em>look them up manually
				using the <topic>JNDI</topic> API</em>. This was also the only way to get resources 
				in Servlet 2.4 API and earlier.<br/>In order to look up resources, you need to <em>declare them in your <idf>web.xml</idf></em>
				like this:</explanation>
				<config><tag>env-entry</tag>
    <tag>description</tag>Name of the webmaster<ctag/>
    <tag>env-entry-name</tag><em>param/webmaster</em><ctag/>
    <tag>env-entry-type</tag>java.lang.String<ctag/>
<ctag/>

<tag>resource-ref</tag>
    <tag>description</tag>A DataSource for our database<ctag/>
    <tag>res-ref-name</tag><em>jdbc/db</em><ctag/>
    <tag>res-type</tag>javax.sql.DataSource<ctag/>
    <tag>res-auth</tag>Container<ctag/>
<ctag/>
</config>
				<explanation>As with <javadoc>@Resource</javadoc> annotations, the <annotated ref="annotated-deployer"/>
				must <em>provide values for those resources</em> by configuring a web container (in a container specific way).</explanation>
				<explanation>With the resources being declared, you can use JNDI to look them up:</explanation>
				
				<code>
					<line>import <javadoc>javax.naming.*</javadoc>;</line>
					<line>import <javadoc>javax.sql.*</javadoc>;</line>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<line>import <javadoc>javax.servlet.*</javadoc>;</line>
					<line>import <javadoc>java.io.*</javadoc>;</line>
					<emptyLine/>
					<line>public class JNDIServlet extends <javadoc>HttpServlet</javadoc> {</line>
					<emptyLine/>
					<line>  protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
					<line>    try {</line>
					<line>      <javadoc>Context</javadoc> ic = new <javadoc>InitialContext</javadoc>();</line>
					<line>      <javadoc>Context</javadoc> ctx = (<javadoc>Context</javadoc>) ic.<em><javadoc>lookup</javadoc>("java:comp/env")</em>;<cmt>enter ENC <more>All resources
that the container provides to the application are always contained in the application's private namespace
'java:comp/env'. Also called Environment Naming Content (ENC).</more></cmt></line>
					<emptyLine/>
					<line>      String wm = (String) ctx.<em><javadoc>lookup</javadoc>("param/webmaster")</em>;<cmt>lookup string <more>Looks 
up the JNDI name 'java:comp/env/param/webmaster'. 'param/webmaster' is the name specified in <idf>web.xml</idf>.</more></cmt></line>
					<line>      <javadoc>DataSource</javadoc> db = (<javadoc>DataSource</javadoc>) ctx.<em><javadoc>lookup</javadoc>("jdbc/db")</em>;<cmt>lookup <javadoc>DataSource</javadoc> <more>Looks 
up the JNDI name 'java:comp/env/jdbc/db'. 'jdbc/db' is the name specified in <idf>web.xml</idf>.</more></cmt></line>
					<emptyLine/>
					<line>      <plainCmt><abstract>do something ...</abstract></plainCmt></line>
					<emptyLine/>
					<line>    }</line>
					<line>    catch (<javadoc>NamingException</javadoc> e) {</line>
					<line>      throw new <javadoc>ServletException</javadoc>(e); <cmt>simple error handling <more ref="more-servletexception"/></cmt></line>
					<line>    }</line>
					<line>  }</line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="tomcatresources">
			<head>Tomcat</head>
			<summary>How to Provide Resources in Tomcat</summary>
			<content>
				<explanation>In <link to="http://tomcat.apache.org">Tomcat</link>, resources are <em>configured in files called <link to="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html">context.xml</link></em>.
				Global resources are defined in <idf>$TOMCAT_HOME/conf/context.xml</idf>. Web applications can add additional
				resources by putting a file <idf>/META-INF/context.xml</idf> into the WAR.</explanation>
				<explanation>The following example <idf>context.xml</idf> defines resources for the last two examples. It can be either
				placed in the WAR's <idf>/META-INF/context.xml</idf> or at <idf>$TOMCAT_HOME/conf/context.xml</idf>.</explanation>
				<config>&lt;Context>
  &lt;Environment name="<em>param/webmaster</em>" value="tim@jarfiller.com" type="java.lang.String" 
  		<em>override="false"</em>/> &lt;!-- <em>required for web.xml version</em> <more>For whatever reason, in Tomcat 'override' means
  		overriding the (optional) default value given in <idf>web.xml</idf>'s <tag>env-entry</tag> element. So <em>to use the
  		value in <idf>context.xml</idf> you must set the attribute to "false"</em>.<br/>
  		If the application is declaring the value with <idf>@Resource</idf>, the <idf>override is not needed.</idf></more> -->

  &lt;Resource name="<em>jdbc/db</em>" 
               auth="Container" type="javax.sql.DataSource"
               driverClassName="org.apache.derby.jdbc.EmbeddedDriver"
               url="jdbc:derby:c:\tmp\JarfillerDB;create=true"/>
&lt;/Context>
				</config>
				<explanation>For more details read Tomcat's <link to="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html">context documentation</link>.</explanation>
			</content>
		</collapsedSubSection>
	</singleColumnSection>


	<singleColumnSection anchor="howtorequestresponses" multipage="true">
		<head>How to... Requests and Responses</head>
		
		<collapsedSubSection anchor="customheaders">
			<head>Custom headers</head>
			<summary>How to Read and Write Additional Headers</summary>
			<content>
				<explanation>Reading request header values and setting headers for the response is straight-forward:</explanation>
				<list>
					<li>Use <javadoc>getHeader</javadoc> to <em>read a request header value</em>.
						<list>
							<li><javadoc to="javax/servlet/http/HttpServletRequest.html#getIntHeader(java.lang.String)">getIntHeader</javadoc>
							and <javadoc to="javax/servlet/http/HttpServletRequest.html#getDateHeader(java.lang.String)">getDateHeader</javadoc>
							are convenience methods that convert the value to <idf>int</idf> or a <annotated id="doc-date"><title>date</title>
							<explanation>Actually it is a timestamp as provided by <idf>System.currentTimeMillis()</idf>.
							The <idf>long</idf> contains the number of milliseconds passed since January 1 1970. You can easily use it
							with <idf>Date</idf>, <idf>Calendar</idf> and most other date-related objects in Java.</explanation></annotated>.</li>
							<li><javadoc to="javax/servlet/http/HttpServletRequest.html#getHeaderNames()">getHeaderNames</javadoc> 
							returns an <javadoc>Enumeration</javadoc> of all headers in the request.</li>
						</list>
					</li>
					
					<li>Use <javadoc to="javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String, java.lang.String)">setHeader</javadoc>
						to <em>set a response header value</em> (possibly overwriting a previous value).
						<list>
							<li><javadoc to="javax/servlet/http/HttpServletResponse.html#setIntHeader(java.lang.String, int)">setIntHeader</javadoc>
							and <javadoc to="javax/servlet/http/HttpServletResponse.html#setDateHeader(java.lang.String, long)">setDateHeader</javadoc>
							are convenience methods for <idf>int</idf> and <annotated ref="doc-date"/> values.</li>
						</list>
					</li>
						
					<li>Use <javadoc to="javax/servlet/http/HttpServletResponse.html#addHeader(java.lang.String, java.lang.String)">addHeader</javadoc>
						to <em>add a response header value</em> (if there already was a value before, you add a second header).
						<list>
							<li><javadoc to="javax/servlet/http/HttpServletResponse.html#addIntHeader(java.lang.String, int)">addIntHeader</javadoc>
							and <javadoc to="javax/servlet/http/HttpServletResponse.html#addDateHeader(java.lang.String, long)">addDateHeader</javadoc>
							are convenience methods for <idf>int</idf> and <annotated ref="doc-date"/> values.</li>
							<li><javadoc to="javax/servlet/http/HttpServletResponse.html#containsHeader(java.lang.String)">containsHeader</javadoc>
							 allows you to find out whether there is already a header of the same name.</li>
						</list>
					</li>
				</list>
				<explanation>This example uses the <idf>User-Agent</idf> header to detect whether the browser supports
				<link to="http://code.google.com/chrome/chromeframe/">Google Chrome Frame</link> and if it does, enables it:
				</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>      throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>    String ua = request.<javadoc><em>getHeader</em></javadoc>("user-agent");<cmt>name is <em>case-insensitive</em></cmt></line>
					<line>    if (ua != null &amp;&amp; ua.contains("chromeframe"))<cmt>detect google chrome frame <more><idf>User-Agent</idf>
					contains a string describing the user's browser and its version. If an Internet Explorer contains the 
					Google Chrome Frame plugin, the user agent string contains the text "chromeframe" (according to the
					Chrome Frame documentation). </more></cmt></line>
					<line>    response.<javadoc to="javax/servlet/http/HttpServletResponse.html#addHeader(java.lang.String, java.lang.String)"><em>addHeader</em></javadoc>("X-UA-Compatible", "chrome=1");<cmt>add header <more>The
					<idf>X-UA-Compatible</idf> header is mostly used by Internet Explorer and allows the server to state which special IE features it supports.
					In this case, we set it to "chrome=1" to enable Google Chrome Frame.</more></cmt></line>
					<emptyLine/>
					<line>    <plainCmt><abstract>...</abstract></plainCmt></line>
	    			<line>}</line>
				</code>
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="attributes">
			<head>Attributes</head>
			<summary>How to Use Attributes in Request and Context</summary>
			<content>
				<explanation>Attributes are <em>named objects stored in <javadoc>ServletRequest</javadoc> and <javadoc>ServletContext</javadoc></em>.
				They are used by containers to <em>provide additional data</em> to the web application, especially for <em>container-specific
				extensions</em>. You can also set attributes yourself for <em>communication between components</em>, for example if your 
				servlet invokes a JSP, you can use pass arguments as request attributes.
				</explanation>
				<explanation>By convention, attribute names should <em>start with your package name</em>. Names starting with
				<idf>java.</idf>, <idf>javax.</idf> or <idf>com.sun.</idf> are reserved. The following example prints
				all available attributes:</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>    throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>  response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");</line>
					<line>  response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<line>  <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<emptyLine/>
					<line>  writer.<javadoc>println</javadoc>("Request attributes:");</line>			
					<line>  for (String name: <javadoc>Collections.list</javadoc>((<javadoc>Enumeration</javadoc>&lt;String>) request.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getAttributeNames()"><em>getAttributeNames</em></javadoc>()))</line>			
					<line>    writer.<javadoc>printf</javadoc>("%s=%s\n", name, request.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getAttribute(java.lang.String)"><em>getAttribute</em></javadoc>(name));</line>			
					<emptyLine/>
					<line>  writer.<javadoc>println</javadoc>("Context attributes:");</line>
					<line>  <javadoc>ServletContext</javadoc> ctx = <javadoc>getServletContext</javadoc>();</line>			
					<line>  for (String name: <javadoc>Collections.list</javadoc>((<javadoc>Enumeration</javadoc>&lt;String>) ctx.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getAttributeNames()"><em>getAttributeNames</em></javadoc>()))</line>			
					<line>    writer.<javadoc>printf</javadoc>("%s=%s\n", name, ctx.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#getAttribute(java.lang.String)"><em>getAttribute</em></javadoc>(name));</line>			
					<line>}</line>
				</code>
				<explanation>
					This is a list of all standard attributes that are part of the Servlet API:</explanation>
				<table>
					<head><cell>Where?</cell><cell>Name</cell><cell>Type</cell><cell>Description</cell></head>
					<row><cell>ServletContext</cell><cell>javax.servlet.context.tempdir</cell><cell>java.io.File</cell><cell>temporary directory <more>The <idf>File</idf> 
					provided by this attribute points to a directory that your web application can use to store temporary files.</more></cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.request.cipher_suite</cell><cell>String</cell><cell>for SSL requests only: name of cipher</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.request.key_size</cell><cell>Integer</cell><cell>for SSL requests only: key size in bits</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.request.X509Certificate</cell><cell><javadoc>X509Certificate</javadoc>[]</cell><cell>for SSL requests only: array of client certificates</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.include.request_uri</cell><cell>String</cell><cell>included servlets only: included request URI (<javadoc>getRequestURI</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.include.context_path</cell><cell>String</cell><cell>included servlets only: included context path (<javadoc>getContextPath</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.include.servlet_path</cell><cell>String</cell><cell>included servlets only: included context path (<javadoc>getServletPath</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.include.path_info</cell><cell>String</cell><cell>included servlets only: included path info (<javadoc>getPathInfo</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.include.query_string</cell><cell>String</cell><cell>included servlets only: included query string (<javadoc>getQueryString</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.forward.request_uri</cell><cell>String</cell><cell>forwarded servlets only: original request URI (<javadoc>getRequestURI</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.forward.context_path</cell><cell>String</cell><cell>forwarded servlets only: original context path (<javadoc>getContextPath</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.forward.servlet_path</cell><cell>String</cell><cell>forwarded servlets only: original context path (<javadoc>getServletPath</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.forward.path_info</cell><cell>String</cell><cell>forwarded servlets only: original path info (<javadoc>getPathInfo</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.forward.query_string</cell><cell>String</cell><cell>forwarded servlets only: original query string (<javadoc>getQueryString</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.error.status_code</cell><cell>Integer</cell><cell>for error pages only: HTTP status code</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.error.exception_type</cell><cell>Class</cell><cell>for error pages only: exception class</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.error.message</cell><cell>String</cell><cell>for error pages only: error message</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.error.exception</cell><cell>Throwable</cell><cell>for error pages only: exception</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.error.request_uri</cell><cell>String</cell><cell>for error pages only: original request URI (<javadoc>getRequestURI</javadoc>)</cell></row>
					<row><cell>ServletRequest</cell><cell>javax.servlet.error.servlet_name</cell><cell>String</cell><cell>for error pages only: servlet name</cell></row>
				</table> 
				
			</content>
		</collapsedSubSection>		
	
		<collapsedSubSection anchor="getlastmodified">
			<head>getLastModified</head>
			<summary>How to Use HttpServlet.getLastModified to Improve Client-Side Caching</summary>
			<content>
				<explanation>HTTP <em>clients often use a local cache</em> to avoid requesting the same files again and again.
				To validate that the cache is not outdated and update the cache with a single request,
				the client can send <em>a conditional GET</em>: the <idf>If-Modified-Since</idf> header attribute tells the server
				to <em>send the document only if it has been modified since the value given in <idf>If-Modified-Since</idf></em>. Otherwise
				the server responds with the status code 304 (Not Modified). 
				</explanation>
				<explanation>It's easy to implement <idf>If-Modified-Since</idf> with the Servlet API: just override the method
				<javadoc>getLastModified</javadoc> to return the last modification date of the requested document, and the container
				will transparently take care of conditional GETs for you:</explanation>
				
				<code>
<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
<line>import <javadoc>java.io.*</javadoc>;</line>
<line>import <javadoc>java.util.*</javadoc>;</line>
<emptyLine/>
<line><plainCmt>Servlets that shows the current date</plainCmt></line>
<line>public class DateServlet extends <javadoc>HttpServlet</javadoc> {</line>
<emptyLine/>
<line>    protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
<line>      throws <javadoc>IOException</javadoc> {</line>
<emptyLine/>   
<line>        response.<javadoc>setContentType</javadoc>("text/html; charset=UTF-8");</line>
<line>        response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line> 
<emptyLine/>   
<line>        <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
<line>        writer.<javadoc>print</javadoc>("&lt;html>&lt;head>&lt;title>Time&lt;/title>&lt;/head>&lt;body>");</line>
<line>        writer.<javadoc>printf</javadoc>("The current date is: %tF", new Date());<cmt>'%tF': format as yyyy-mm-dd</cmt></line>
<line>        writer.<javadoc>print</javadoc>("&lt;/body>&lt;/html>");</line>
<line>    }</line>
<emptyLine/>
<line>    protected long <javadoc><em>getLastModified</em></javadoc>(<javadoc>HttpServletRequest</javadoc> request) {</line>
<line>        <plainCmt>the date changes every day at midnight!</plainCmt></line>
<line>        <javadoc>GregorianCalendar</javadoc> cal = new <javadoc>GregorianCalendar</javadoc>();<cmt>current time</cmt></line>
<line>        cal.<javadoc>set</javadoc>(<javadoc>Calendar.HOUR</javadoc>, 0);<cmt>set to midnight</cmt></line>
<line>        cal.<javadoc>set</javadoc>(<javadoc>Calendar.MINUTE</javadoc>, 0);</line>
<line>        cal.<javadoc>set</javadoc>(<javadoc>Calendar.SECOND</javadoc>, 0);</line>
<line>        cal.<javadoc>set</javadoc>(<javadoc>Calendar.MILLISECOND</javadoc>, 0);</line>
<line>        return cal.<javadoc>getTimeInMillis</javadoc>();<cmt>convert to ms since 1970</cmt></line>
<line>    }</line>
<line>}</line>
			</code>
			</content>
		</collapsedSubSection>
		
		
		<collapsedSubSection anchor="contentlength">
			<head>Content Length</head>
			<summary>How to Set the Content Length</summary>
			<content>
				<explanation>
					If you already know the size of your response body before you start writing
					to the <javadoc>OutputStream</javadoc> (e.g. you have the response as a byte array or file), then
					you can <em>help container and client by calling the 
					<javadoc to="javax/servlet/ServletResponse.html#setContentLength(int)">setContentLength</javadoc></em> method:
				</explanation>
				<code>
					<line>request.<javadoc to="javax/servlet/ServletResponse.html#setContentLength(int)"><em>setContentLength</em></javadoc>(1024);<cmt>set length in bytes</cmt></line>
				</code>
				<explanation>
					The method sets the <idf>Content-Length</idf> header value in the response and allows various optimizations in both server and client.
					Note that <em>the server will automatically close</em> the <javadoc>OutputStream</javadoc> as soon as you wrote the specified amount of bytes.
				</explanation>
				<explanation>Setting the content length is usually <em>no good idea when using a <javadoc>PrintWriter</javadoc></em> for output, as
				you can't know the content length in bytes without encoding the characters first (and if you already have an encoded
				result, just use an <javadoc>OutputStream</javadoc>).</explanation>
			</content>
		</collapsedSubSection>
	
		<collapsedSubSection anchor="fileupload">	
			<head>File Upload</head>
			<summary>How to Receive File Uploads (Multi-Part File Upload)</summary>
			<content>
				<explanation>
					Unfortunately the Servlet API 2.5 does not support file upload yet (3.0 does). Handling file uploads from
					a form is rather complicated, so you <em>should use a library to parse the upload</em>. The most popular
					choice for this is <link to="http://commons.apache.org/fileupload/">Apache Commons FileUpload</link>, as it is
					free, flexible and fairly easy to use.
				</explanation>
				<explanation>
					The following example should give you an idea of how to use Apache Commons FileUpload. For details you should
					consult the documentation provided by the project. 
				</explanation>

				<code>
					<line>import org.apache.commons.fileupload.*;</line>
					<line>import org.apache.commons.fileupload.disk.*;</line>
					<line>import org.apache.commons.fileupload.servlet.*;</line>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<line>import <javadoc>java.nio.*</javadoc>;</line>
					<line>import <javadoc>java.io.*</javadoc>;</line>
					<line>import <javadoc>java.util.*</javadoc>;</line>
					<emptyLine/>
					<line><plainCmt>Show form to let user upload a text file. Then print content as ASCII.</plainCmt></line>
					<line>public class UploadServlet extends <javadoc>HttpServlet</javadoc> {</line>
					<emptyLine/>
					<line>    private void doGet(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>        response.<javadoc>setContentType</javadoc>("text/html; charset=US-ASCII");</line>
					<line>        response.<javadoc>setCharacterEncoding</javadoc>("US-ASCII");</line>
					<emptyLine/>
					<line>        <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;html>&lt;head>&lt;title>Calculator&lt;/title>&lt;/head>&lt;body>");</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;form method='POST' <em>enctype='multipart/form-data'</em>>&lt;br>");</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;input <em>type='file'</em> name='file'>&lt;input type='submit'>");</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;/form>&lt;/html>");</line>
					<line>    }</line>
					<emptyLine/>
					<line>    private void doPost(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
					<emptyLine/>
					<line>        if (!ServletFileUpload.isMultipartContent(request)) {</line>
					<line>            throw new <javadoc>ServletException</javadoc>("file missing");</line>
					<emptyLine/>
					<line>        try {</line>
					<line>            response.<javadoc>setContentType</javadoc>("text/plain; charset=US-ASCII");</line>
					<line>            response.<javadoc>setCharacterEncoding</javadoc>("US-ASCII");</line>
					<emptyLine/>
					<line>            <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<line>            writer.<javadoc>println</javadoc>("Processing upload:\n");</line>
					<emptyLine/>
					<line>            ServletFileUpload upload = new ServletFileUpload(new DiskFileItemFactory());</line>
					<line>            List&lt;FileItem> items = (List&lt;FileItem>) upload.<em>parseRequest</em>(request);</line>
					<line>            for (FileItem item: items) {</line>
					<line>                w.printf("File '%s' for field '%s':\n", item.getName(), item.getFieldName());</line>
					<line>                byte[] content = item.get(); <cmt>warning: use streams for long files</cmt></line>
					<emptyLine/>
					<line>                <plainCmt>this line decodes the byte array content as ASCII into a char array:</plainCmt></line>
					<line>                char[] decoded = <javadoc to="http://java.sun.com/javase/6/docs/api/java/nio/charset/Charset.html#forName(java.lang.String)">Charset.forName</javadoc>("US-ASCII")</line>
					<line>                    .<javadoc to="http://java.sun.com/javase/6/docs/api/java/nio/charset/Charset.html#decode(java.nio.ByteBuffer)">decode</javadoc>(<javadoc to="http://java.sun.com/javase/6/docs/api/java/nio/ByteBuffer.html#wrap(byte[])">ByteBuffer.wrap</javadoc>(content)).<javadoc to="http://java.sun.com/javase/6/docs/api/java/nio/CharBuffer.html#array()">array</javadoc>();</line>
					<emptyLine/>
					<line>                w.<javadoc to="http://java.sun.com/javase/6/docs/api/java/io/PrintWriter.html#print(char[])">print</javadoc>(decoded);</line>
					<line>                w.<javadoc>print</javadoc>("\n\n");</line>
					<line>            }</line>
					<line>        }</line>
					<line>        catch (FileUploadException e) {</line>
					<line>            throw new <javadoc>ServletException</javadoc>(e);</line>
					<line>        }</line>
					<line>    }</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="browserdetection">	
			<head>Browser Detection</head>
			<summary>How to Detect the User's Web Browser</summary>
			<content>
				<explanation>Browsers usually identify themselves using the <em>user-agent</em> header. For example,
				Firefox 3.6 sends this value (split into two lines because it is so long):</explanation>
				<config>Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2) 
      Gecko/20100115 Firefox/3.6 (.NET CLR 3.5.30729)</config>
      			<explanation>
				While Internet Explorer 8.0 sends this:
				</explanation>
				<config>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; SLCC1; 
      .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729)</config>
      			<explanation>Both strings start with "Mozilla" to claim compatibility with
      			the old <link to="http://en.wikipedia.org/wiki/Netscape_Navigator">Netscape Navigator</link>, but also include the
      			operating system ("Windows NT 6.0" = Windows Vista), browser's internal rendering 
      			engine ("Gecko/20100115" and "Trident/4.0") as well as the browser itself ("Firefox/3.6" and "MSIE 8.0").
      			There is <em>no definite way of identifying the browser</em>, as there is no exact format for the user agent string. Another problem is that
      			browsers try to improve compatibility by including the names of similar browsers into their user agent. Some obscure browsers even copy popular browser's
      			user agent string (usually Internet Explorer's) to prevent sites from rejecting them.</explanation>
      			<explanation>When you really need to identify the exact browser version, use a library like
      			<link to="http://code.google.com/p/user-agent-utils/">user-agent-utils</link>. Those libraries usually come
      			with large collections of known user agents and add some browser-specific forensics.</explanation>
      			<explanation>Otherwise I would suggest to be pragmatic: identify strings in the user agent
      			that look unique for that particular browser, and check whether the user agent strings contains them. This simple
      			example checks for Internet Explorers and Firefoxes:</explanation>
      			<code>
      				<line>String ua = request.<javadoc>getHeader</javadoc>("user-agent");</line>
      				<line>if (ua.contains("Firefox"))</line>
      				<line>    log("User seems to use Firefox");</line>
      				<line>else if (ua.contains("MSIE"))</line>
      				<line>    log("User seems to use Internet Explorer");</line>
      				<line>else</line>
      				<line>    log("User seems to use unknown browser.");</line>
      			</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="contentlanguage">
			<head>Content Language</head>
			<summary>How to Declare the Content Language</summary>
			<content>
				<explanation>The <javadoc>ServletResponse</javadoc> interface has a method <em><javadoc>setLocale</javadoc></em>
				that allows you to <em>set the content's locale</em>. It has two effects:</explanation>
				<list><li>It <em>sets the <idf>Content-Language</idf></em> header field to declare the page's language.</li>
				<li>If you are using a <idf>Writer</idf> <em>and don't set the character encoding</em> explicitly with 
				<javadoc>setCharacterEncoding</javadoc>, the <em>container will choose an appropriate encoding</em> for your locale <more>It is up to the container to
				determine the right enconding for your locale if you set a locale but no encoding. However, you can override the 
				container's choice with the	<idf>locale-encoding-mapping-list</idf> element in the <idf>web.xml</idf>, which allows 
				you to specify an encoding for each locale.</more>. In most cases you <em>should call 
				<javadoc>setCharacterEncoding</javadoc></em> for more predictable behaviour.</li></list>
				<explanation>Note that the <em><idf>Content-Language</idf> is hardly used</em> in browsers, but may be important for search engines.
				</explanation>
				<explanation>The following example prints the time in German language and declares it accordingly.</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>    response.<javadoc>setContentType</javadoc>("text/html; charset=UTF-8");</line>
					<line>    response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<line>    response.<javadoc><em>setLocale</em></javadoc>(<javadoc>Locale.GERMAN</javadoc>);</line>
					<emptyLine/>
					<line>    <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<line>    writer.<javadoc>print</javadoc>("&lt;html>&lt;head>&lt;title>Zeit&lt;/title>&lt;/head>&lt;body>");</line>
					<line>    writer.<javadoc to="http://java.sun.com/javase/6/docs/api/java/io/PrintWriter.html#format(java.util.Locale, java.lang.String, java.lang.Object...)">printf</javadoc>(<javadoc><em>Locale.GERMAN</em></javadoc>, "Die aktuelle Zeit ist: %tc", new Date());</line>
					<line>    writer.<javadoc>print</javadoc>("&lt;/body>&lt;/html>");</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="acceptedlanguages">
			<head>Accepted Languages</head>
			<summary>How to Detect the Client's Preferred Languages</summary>
			<content>
				<explanation>Browsers <em>send a list of the user's preferred languages</em> in the <idf>Accept-Language</idf> header field. 
				The Servlet API	helps you using it with two methods in the <javadoc>ServletRequest</javadoc>:</explanation>
				<list>
					<li><javadoc>getLocale</javadoc> returns the client's preferred language</li>
					<li><javadoc>getLocales</javadoc> returns all language the client accepts in order of preference</li>
				</list>
				
				<explanation>This example greets a visitor either in German or English, depending on what the user prefers:</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>    <plainCmt>Locales supported by the servlet:</plainCmt></line>
					<line>    List&lt;<javadoc>Locale</javadoc>> supported = <javadoc>Arrays.asList</javadoc>(<javadoc>Locale.ENGLISH</javadoc>, <javadoc>Locale.GERMAN</javadoc>);</line>
					<emptyLine/>
					<line>    <plainCmt>Locales supported by the client (ordered by preference):</plainCmt></line>
					<line>    List&lt;<javadoc>Locale</javadoc>> accepted = <javadoc>Collections.list</javadoc>(<em>request.getLocales()</em>);</line>
					<emptyLine/>
					<line>    <plainCmt>determine best locale for the client</plainCmt></line>
					<line>    <javadoc>Locale</javadoc> locale = <javadoc>Locale.ENGLISH</javadoc>;<cmt>fallback default</cmt></line>
					<line>    for (<javadoc>Locale</javadoc> a: accepted)</line>
					<line>        for (<javadoc>Locale</javadoc> s: supported)</line>
					<line>            if (s.equals(a)) {</line>
					<line>                locale = a;</line>
					<line>                break;</line>
					<line>            }</line>
					<emptyLine/>
					<line>    response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");</line>
					<line>    response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<line>    response.<em><javadoc>setLocale</javadoc>(locale)</em>;<cmt>declare content language</cmt></line>
					<emptyLine/>
					<line>    <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<line>    if (locale.equals(<javadoc>Locale.ENGLISH</javadoc>))</line>
					<line>        writer.<javadoc>println</javadoc>("Hello, visitor!");</line>
					<line>    else</line>
					<line>        writer.<javadoc>println</javadoc>("Hallo, Besucher!");</line>
					<line>    else</line>
					<line>        assert false;<cmt>can't happen</cmt></line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="sendingxml">
			<head>Sending XML</head>
			<summary>How to Send XML as Response</summary>
			<content>
				<explanation>You can use practially any XML API to create XML, just <em>set the content type 
				correctly and write the XML to the <javadoc>OuputStream</javadoc></em>. Alternatively you can also use a 
				<topic>JSP</topic> to create the XML, which can sometimes be more convenient.</explanation>
				
				<explanation>The following example shows you how to send XML with the <topic>JAXB</topic> API:</explanation>
				
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>    throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>    MovieLibrary library = <abstract>...</abstract>;<cmt>example tree from the <link to="/guide/jaxb/">JAXB Guide</link></cmt></line>
					<emptyLine/>
					<line>    response.<javadoc>setContentType</javadoc>("<em>text/xml</em>");<cmt>generic XML content type <more><idf>text/xml</idf> is a generic
						content type for XML. If possible, you should use a specific type for your response, for example
						<idf>application/xhtml+xml</idf> for XHTML.</more></cmt></line>
					<line>    <em><javadoc to="http://java.sun.com/javase/6/docs/api/javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.File)">JAXB.marshal</javadoc></em>(library, response.<em><javadoc>getOutputStream</javadoc></em>());<cmt>write XML with JAXB</cmt></line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="dynamicimages">
			<head>Dynamic Images</head>
			<summary>How to Generate Images as Response</summary>
			<content>
				<explanation>You can use the <link to="http://java.sun.com/products/java-media/2D/index.jsp">Java 2D API</link>
				to create images dynamically, encode them as PNG or JPEG and send them to the client. The following servlet
				draws a simple clock with the current time and sends it as response:</explanation>
				<code>
					<line>import <javadoc>java.awt.*</javadoc>;</line>
					<line>import <javadoc>java.awt.image.*</javadoc>;</line>
					<line>import <javadoc>javax.imageio.*</javadoc>;</line>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<line>import <javadoc>java.io.*</javadoc>;</line>
					<line>import <javadoc>java.util.*</javadoc>;</line>
					<emptyLine/>
					<line><plainCmt>Servlet that draws a clock</plainCmt></line>
					<line>public class ClockServlet extends <javadoc>HttpServlet</javadoc> {</line>
					<emptyLine/>
					<line>    <plainCmt>create the image</plainCmt></line>
					<line>    private BufferedImage createClockImage() {</line>
					<line>        <javadoc>GregorianCalendar</javadoc> cal = new <javadoc>GregorianCalendar</javadoc>();</line>
					<emptyLine/>
					<line>        <javadoc>BufferedImage</javadoc> img = <em>new <javadoc>BufferedImage</javadoc></em>(400, 400, <javadoc>BufferedImage.TYPE_3BYTE_BGR</javadoc>);</line>
					<line>        <javadoc>Graphics2D</javadoc> g = img.<javadoc>createGraphics</javadoc>();</line>
					<emptyLine/>
					<line>        <plainCmt>white background</plainCmt></line>
					<line>        g.<javadoc>setColor</javadoc>(<javadoc>Color.WHITE</javadoc>);</line>
					<line>        g.<javadoc>fillRect</javadoc>(0, 0, 400, 400);</line>
					<emptyLine/>
					<line>        <plainCmt>draw black circle around clock</plainCmt></line>
					<line>        g.<javadoc>setColor</javadoc>(<javadoc>Color.BLACK</javadoc>);</line>
					<line>        g.<javadoc>setStroke</javadoc>(new <javadoc>BasicStroke</javadoc>(5));</line>
					<line>        g.<javadoc>drawOval</javadoc>(20, 20, 360, 360);</line>
					<emptyLine/>
					<line>        <plainCmt>draw hour hand</plainCmt></line>
					<line>        double hourRad = cal.<javadoc>get</javadoc>(<javadoc>Calendar.HOUR</javadoc>) * 2 * Math.PI / 12 - 0.5 * Math.PI;</line>
					<line>        g.<javadoc>drawLine</javadoc>(200, 200, 200 + (int) (100 * Math.cos(hourRad)), </line>
					<line>                   200 + (int) (100 * Math.sin(hourRad)));</line>
					<emptyLine/>
					<line>        <plainCmt>draw minute hand</plainCmt></line>
					<line>        double minuteRad = cal.get(<javadoc>Calendar.MINUTE</javadoc>) * 2 * Math.PI / 60 - 0.5 * Math.PI;</line>
					<line>        g.<javadoc>drawLine</javadoc>(200, 200, 200 + (int) (170 * Math.cos(minuteRad)), </line>
					<line>                   200 + (int) (170 * Math.sin(minuteRad)));</line>
					<line>        return img;</line>
					<line>    }</line>
					<emptyLine/>				
					<line>    protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>          throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>        response.<javadoc>setContentType</javadoc>("image/png");</line>
					<emptyLine/>
					<line>        OutputStream os = response.<javadoc>getOutputStream</javadoc>();</line>
					<line>        <javadoc><em>ImageIO.write</em></javadoc>(createClockImage(), "PNG", os);<cmt>write image as PNG <more>All the 'magic' is done here: <idf>ImageIO.write</idf> takes the <idf>BufferedImage</idf> and writes it as PNG into the <idf>OutputStream</idf>.</more></cmt></line>
					<line>    }</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>



		<collapsedSubSection anchor="jspforward">
			<head>JSP Forward</head>
			<summary>How to Use a JSP as Template</summary>
			<content>
				<explanation>
					It's easy to <em>use a <topic>JSP</topic> to create your servlet's response</em> and even pass arguments to the
					JSP.
					<br/>The following JSP is stored in "/WEB-INF/jsps/time.jsp" and expects a variable 'myTime' containing a <idf>java.util.Date</idf>:
				</explanation>
				<config>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;%@ page language="java" contentType="text/html" pageEncoding="UTF-8"%>
&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
&lt;html xmlns="http://www.w3.org/1999/xhtml">
	&lt;head>&lt;title>Time&lt;/title>&lt;/head>
	&lt;body>
		Time: &lt;fmt:formatDate value="${<em>myTime</em>}" pattern="yyyy-MM-dd HH:mm:ss"/>
	&lt;/body>
&lt;/html>
				</config>
				<explanation>
					To invoke the JSP, get a <javadoc>RequestDispatcher</javadoc> instance for the JSP from your <javadoc>ServletContext</javadoc>
					and tell the dispatcher to forward to the JSP. Variables are passed to the JSP by setting request attributes <more>Note 
					that this example violates the Servlet API guideline to prefix attributes with your package name, but doing so would be quite cumbersome 
					and is not really recommended for a simple application. </more>.
				</explanation>
				
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>    throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
					<emptyLine/>
					<line>    <javadoc>RequestDispatcher</javadoc> rd = <javadoc>getServletContext</javadoc>().<em><javadoc>getRequestDispatcher</javadoc>("/WEB-INF/jsps/time.jsp")</em>;</line>
					<emptyLine/>
					<line>    request.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#setAttribute(java.lang.String, java.lang.Object)">setAttribute</javadoc>("<em>myTime</em>", new Date());<cmt>pass current time</cmt></line>
					<emptyLine/>
					<line>    rd.<em><javadoc>forward</javadoc></em>(request, response);<cmt>invoke JSP and return <more>After invoking <idf>forward</idf> the response has been
					generated and you should usually return from the <idf>service</idf> method immediately. It is a common
					error to forget that <idf>forward</idf> finished the response, but does not end the method and all
					following code will still be executed.</more></cmt></line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		
		<collapsedSubSection anchor="requestdispatcher">
			<head>RequestDispatcher</head>
			<summary>How to Invoke Servlets and JSPs with the RequestDispatcher</summary>
			<content>
				<explanation>
					The <javadoc>RequestDispatcher</javadoc> allows your servlet to <em>invoke other servlets, JSPs or static pages</em>. You can either 
					<em><annotated><title>forward</title><explanation>Forwarding means that you give your request and response objects
					to another servlet and let it handle the request. This is only possible if you haven't comitted your response yet.
					Beside servlets you can also forward to any other page supported by the container, including JSPs.</explanation></annotated> 
					to them or only <annotated><title>include</title><explanation>When including, the invoked servlet
					appends its output to your reponse's body, but does not modify the response headers. 
					Beside servlets you can also include any other static page or JSP supported by the container.</explanation></annotated></em>
					their output.
				</explanation>
				<miniHeadline>Getting the RequestDispatcher</miniHeadline>
				<explanation>There are three ways to obtain a <javadoc>RequestDispatcher</javadoc>:</explanation>
				<list>
					<li><javadoc>ServletContext</javadoc>.<javadoc>getNamedDispatcher</javadoc> returns a <em>dispatcher for a servlet with
					the specified <annotated><title>name</title><explanation>This is the servlet name defined in the
					<idf>web.xml</idf> deployment descriptor with a &lt;servlet>/&lt;servlet-name> element.</explanation></annotated></em>.</li>
					<li><javadoc>ServletContext</javadoc>.<javadoc>getRequestDispatcher</javadoc> looks up a <em>dispatcher that handles the given path</em>.
					The path must start with '/' and is relative to the web application root. It can be located in '/WEB-INF/'.
					If the path contains a query (like '/path?param1=value'), those value will be available in the invoked servlet's
					request parameters.</li>
					<li><javadoc>ServletRequest</javadoc>.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getRequestDispatcher(java.lang.String)">getRequestDispatcher</javadoc> works like
					the method in <javadoc>ServletContext</javadoc>, but it also allows <em>paths relative to the original request path</em>.</li>
				</list>
				
				<miniHeadline>Request Attributes</miniHeadline>
				<explanation>
				If a servlet's <javadoc>RequestDispatcher</javadoc> was obtained using one of the <javadoc>getRequestDispatcher</javadoc>
				methods (and <em>not using <javadoc>getNamedDispatcher</javadoc></em>), the following <em>attributes are available</em> in the
				<javadoc>ServletRequest</javadoc>:</explanation>
				<table>
					<head><cell>When?</cell><cell>Name</cell><cell>Description</cell></head>
					<row><cell>forward</cell><cell>javax.servlet.forward.request_uri</cell><cell>original request URI (see <javadoc>getRequestURI</javadoc>)</cell></row>
					<row><cell>forward</cell><cell>javax.servlet.forward.context_path</cell><cell>original context path (see <javadoc>getContextPath</javadoc>)</cell></row>
					<row><cell>forward</cell><cell>javax.servlet.forward.servlet_path</cell><cell>original context path (see <javadoc>getServletPath</javadoc>)</cell></row>
					<row><cell>forward</cell><cell>javax.servlet.forward.path_info</cell><cell>original path info (see <javadoc>getPathInfo</javadoc>)</cell></row>
					<row><cell>forward</cell><cell>javax.servlet.forward.query_string</cell><cell>original query string (see <javadoc>getQueryString</javadoc>)</cell></row>
					<row><cell>include</cell><cell>javax.servlet.include.request_uri</cell><cell>included request URI (see <javadoc>getRequestURI</javadoc>)</cell></row>
					<row><cell>include</cell><cell>javax.servlet.include.context_path</cell><cell>included context path (see <javadoc>getContextPath</javadoc>)</cell></row>
					<row><cell>include</cell><cell>javax.servlet.include.servlet_path</cell><cell>included context path (see <javadoc>getServletPath</javadoc>)</cell></row>
					<row><cell>include</cell><cell>javax.servlet.include.path_info</cell><cell>included path info (see <javadoc>getPathInfo</javadoc>)</cell></row>
					<row><cell>include</cell><cell>javax.servlet.include.query_string</cell><cell>included query string (see <javadoc>getQueryString</javadoc>)</cell></row>
				</table> 
				
				
				<miniHeadline>Forwarding</miniHeadline>
				<explanation>Forwards are often useful if you need to return different pages depending on user input.
				This example displays a simple form in its GET method, and parses submitted values in its POST method. Depending
				on the input values, it will either forward to an error JSP or a result servlet (the JSP and result servlet are not shown here):
				</explanation>
				<code>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<emptyLine/>
					<line>public class SumServlet extends <javadoc>HttpServlet</javadoc> {</line>
					<emptyLine/>
					<line>    private void doGet(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>        response.<javadoc>setContentType</javadoc>("text/html; charset=UTF-8");</line>
					<line>        response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<emptyLine/>
					<line>        <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;html>&lt;head>&lt;title>Calculator&lt;/title>&lt;/head>&lt;body>");</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;form method='POST'>&lt;input name='x'> + &lt;input name='y'> ");</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;input type='submit' value='='>&lt;/form>");</line>
					<line>        writer.<javadoc>print</javadoc>("&lt;/body>&lt;/html>");</line>
					<line>    }</line>
					<emptyLine/>
					<line>    private void doPost(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>        String x = request.<javadoc>getParameter</javadoc>("x");</line>
					<line>        String y = request.<javadoc>getParameter</javadoc>("y");</line>
					<emptyLine/>
					<line>        <plainCmt>find target</plainCmt></line>
					<line>        <javadoc>RequestDispatcher</javadoc> disp;</line>
					<line>        if (x != null &amp;&amp; y != null &amp;&amp;  x.<javadoc>matches</javadoc>("[0-9]+") &amp;&amp; y.<javadoc>matches</javadoc>("[0-9]+"))</line>
					<line>            disp = <javadoc>getServletContext</javadoc>().<javadoc><em>getNamedDispatcher</em></javadoc>("result-servlet");<cmt>by servlet name</cmt></line>
					<line>        else</line>
					<line>            disp = request.<javadoc><em>getRequestDispatcher</em></javadoc>("/WEB-INF/jsps/error.jsp");</line>
					<emptyLine/>
					<line>        <plainCmt>forward to target</plainCmt></line>
					<line>        disp.<javadoc><em>forward</em></javadoc>(request, response);</line>
					<line>    }</line>
					<line>}</line>
				</code>
				
				
				<miniHeadline>Forward to Static Content</miniHeadline>
				<explanation>
				You can also forward to static files. Here is a much shorter implementation of the <idf>AmPmFileServlet</idf>
				<link anchor="responsebinary">shown above</link>:
				</explanation>
				<code>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<emptyLine/>
					<line><plainCmt>Servlet that sends one of two PNG images, depending on time of day</plainCmt></line>
					<line>public class AmPmFileServlet extends <javadoc>HttpServlet</javadoc> {</line>
					<emptyLine/>
					<line>    protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>           throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
	    			<emptyLine/>
	    			<line>        <plainCmt>before or after noon? determine path to the right image in the WAR</plainCmt></line>
	    			<line>        boolean isPM = new <javadoc>GregorianCalendar</javadoc>().get(<javadoc>Calendar.AM_PM</javadoc>) == <javadoc>Calendar.PM</javadoc>; </line>
	    			<line>        String resName = "/WEB-INF/images/time" + (isPM ? "PM" : "AM") + ".png";</line>
	    			<emptyLine/>
	    			<line>        <javadoc>getServletContext</javadoc>().<javadoc>getRequestDispatcher</javadoc>(resName).<javadoc><em>forward</em></javadoc>(request, response);</line>
	    			<line>    }</line>
	    			<line>}</line>
				</code>
			
				<miniHeadline>Including Content</miniHeadline>
				<explanation>When including a servlet, JSP or static content, <em>their output is written to including servlet's output</em>, but any
				changes to the header will be discarded:</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>      throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
					<emptyLine/>
					<line>    response.<javadoc>setContentType</javadoc>("text/html; charset=UTF-8");</line>
					<line>    response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<line>    <javadoc>PrintWriter</javadoc> writer = response.<javadoc>getWriter</javadoc>();</line>
					<emptyLine/>
	    			<line>    request.<javadoc>getRequestDispatcher</javadoc>("header.jsp").<javadoc><em>include</em></javadoc>(request, response);</line>
	    			<line>    writer.<javadoc>println</javadoc>((new Date()).toString());</line>
	    			<line>    request.<javadoc>getRequestDispatcher</javadoc>("footer.jsp").<javadoc><em>include</em></javadoc>(request, response);</line>
	    			<line>}</line>
				</code>
				
				<miniHeadline>sendRedirect vs RequestDispatcher</miniHeadline>
				<explanation>The difference between a <javadoc>RequestDispatcher</javadoc> <javadoc>forward</javadoc> and the <javadoc>sendRedirect</javadoc>
				method is that with a <idf>forward</idf>, everything happens on the server-side. <em>POST parameters will not be lost</em> and 
				<em>the client will not notice</em> that it is being forwarded.<br/>
				With a redirect, the server <em>tells the client to request the new URL</em>, and thus the clients notices that it is being
				redirected. From the perspective of a web browser's user, the difference is that with a redirection she sees the new URL in 
				the location bar. In many browsers going back to a page with redirection means that the user is being redirected again,
				effectively breaking the 'back' button.</explanation>			
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="virtualhosts">
			<head>Virtual Hosts</head>
			<summary>How to Handle Virtual Hosts and Multiple IP Addresses?</summary>
			<content>
				<explanation>
				A <em>web server may listen on several IP addresses</em>, and <em>each IP address may be used for several host names</em> (virtual
				hosts). The Servlet Specification established the following rules for virtual hosts:</explanation> 
				<list>
					<li><em>Virtual servers can not share <javadoc>ServletContext</javadoc>s</em>. If you configure your server 
					to use virtual hosts, you usually need to deploy your application for each virtual host separately.</li>
					<li>A web container can use a single <javadoc>ServletContext</javadoc> for several addresses or names <em>if they all 
					behave identically</em> (and thus behave like a single server).</li>
					<li>Use the <javadoc>ServletRequest</javadoc>'s <javadoc>getLocalAddr</javadoc> method to find out on
					which address a request has been received.</li>
					<li>Read the <idf>Host</idf> header value with <javadoc>getHeader</javadoc> to find out which virtual host name
					was requested by the client (note that some primitive clients may not send a <idf>Host</idf>).</li>
				</list> 
			</content>
		</collapsedSubSection>		
		
		<collapsedSubSection anchor="filters">
			<head>Filters</head>
			<summary>How to Write Filters</summary>
			<content>
				<explanation>By writing a <javadoc>Filter</javadoc> class you can <em>analyze and modify a <javadoc>ServletRequest</javadoc></em> before 
				it is processed by the container's regular dispatcher, and then <em>analyze and modify the resulting <javadoc>ServletResponse</javadoc></em>.
				Filters can be chained, meaning the request and response may run through several filters before being processed by the original
				handler (which may be a servlet, JSP or the container's handler for static content).
				<br/>
				The following filter writes all request parameters to the log:
				</explanation>
				
				<code>
					<line>package com.jarfiller.example;</line>
					<line>import <javadoc>javax.servlet.*</javadoc>;</line>
					<line>import <javadoc>java.io.*</javadoc>;</line>
					<line>import <javadoc>java.util.*</javadoc>;</line>
					<emptyLine/>
					<line><plainCmt>Logs parameters of every request</plainCmt></line>
					<line>public class LoggingFilter implements <javadoc>Filter</javadoc> {</line>
					<line>    private <javadoc>ServletContext</javadoc> ctx;</line>
					<emptyLine/>
					<line>    public void <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/Filter.html#init(javax.servlet.FilterConfig)">init</javadoc>(<javadoc>FilterConfig</javadoc> config) {</line>
					<line>        ctx = config.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/FilterConfig.html#getServletContext()">getServletContext</javadoc>();</line>
					<line>        ctx.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#log(java.lang.String)">log</javadoc>("LoggingFilter started");</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public void <javadoc>doFilter</javadoc>(<javadoc>ServletRequest</javadoc> request, <javadoc>ServletResponse</javadoc> response, <javadoc>FilterChain</javadoc> chain) </line>
					<line>        throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
					<emptyLine/>
					<line>        for (String name: <javadoc>Collections.list</javadoc>((<javadoc>Enumeration</javadoc>&lt;String>)request.<javadoc>getParameterNames</javadoc>()))</line>
					<line>            ctx.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#log(java.lang.String)">log</javadoc>(String.<javadoc>format</javadoc>("%s=%s", name, request.<javadoc>getParameter</javadoc>(name)));</line>
					<emptyLine/>
					<line>        chain.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/FilterChain.html#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)"><em>doFilter</em></javadoc>(request, response);<cmt><em>important!</em> invoke the dispatcher <more>Calling
					<idf>doFilter</idf> on the <javadoc>FilterChain</javadoc> is required to invoke either the next filter or the original handler
					of the request.</more></cmt></line>
					<line>    }</line>
					<emptyLine/>
					<line>    public void <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/Filter.html#destroy()">destroy</javadoc>() {</line>
					<line>        ctx.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#log(java.lang.String)">log</javadoc>("LoggingFilter will destroyed now");</line>
					<line>    }</line>
					<line>}</line>
				</code>
				<explanation>The filter's <javadoc>doFilter</javadoc> method is invoked for every filtered request. It allows the filter to 
				manipulate the request and response
				before either the original handler or the next filter in the chain is being invoked explicitly via <javadoc>FilterChain</javadoc>.</explanation>
				
				<explanation>Like servlets, filters need to be <em>declared and mapped in your <idf>web.xml</idf></em>:</explanation>
				<config><tag>filter</tag>                                  <cmt><em>declares the <javadoc>Filter</javadoc> class</em></cmt>
    <tag>filter-name</tag><em>logfilter</em><ctag/>  <cmt>name must be unique</cmt>
    <tag>filter-class</tag>com.jarfiller.example.LoggingFilter<ctag/>
<ctag/>


<tag>filter-mapping</tag>                          <cmt><em>maps the LoggingFilter</em></cmt>
    <tag ref="doc-filter-mapping-name">filter-name</tag><em>logfilter</em><ctag/>  <cmt>must be the same as filter-name above</cmt>
    
    <tag ref="doc-filter-mapping-url-pattern">url-pattern</tag>*.jsp<ctag/>      <cmt>match all JSPs, </cmt>
    <tag ref="doc-filter-mapping-url-pattern">url-pattern</tag>/work/*<ctag/>    <cmt>plus everything in /work, </cmt>
    <tag ref="doc-filter-mapping-servlet-name">servlet-name</tag>counter<ctag/>  <cmt>plus the 'counter' servlet</cmt>
    
    <tag>dispatcher</tag>REQUEST<ctag/>      <cmt>filter regular requests (default if omitted),</cmt>
    <tag>dispatcher</tag>FORWARD<ctag/>      <cmt>filter forwards,</cmt>
    <tag>dispatcher</tag>INCLUDE<ctag/>      <cmt>filter includes,</cmt>
    <tag>dispatcher</tag>ERROR<ctag/>        <cmt>and filter errors</cmt>
<ctag/>
</config>
				<explanation>If several filter mappings match a request, they will be <em>processed in the order of their declaration</em>. 
				Mappings for URL patterns are always processed before servlet name mappings.</explanation>

				<miniHeadline>Request/Response Wrapping</miniHeadline>
				<explanation>You can modify the request passed down the filter chain as well as the generated
                response by <em>wrapping the request and response objects</em>. The API provides you with two
				<annotated><title>call-through wrappers</title><explanation>The wrappers provided by the API
				wrap the original object by passing all method invocations to the underlying object,
				without modifying the arguments, and return the original return value.</explanation></annotated>,
				<javadoc>HttpServletRequestWrapper</javadoc> and <javadoc>HttpServletResponseWrapper</javadoc>, that you
				can extend. Note that even with those helper classes, <em>writing a wrapper can be quite complex</em>, especially
				if you want to modify the content body and thus also need to wrap the 
				<javadoc>InputStream</javadoc> or <javadoc>OutputStream</javadoc>.</explanation>
				<explanation>This example filter uses wrappers to remove all cookies from the request and also blocks
				any cookies the handler tries to set in the response:</explanation>
				<code>
					<line>package com.jarfiller.example;</line>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<line>import <javadoc>javax.servlet.*</javadoc>;</line>
					<line>import <javadoc>java.io.*</javadoc>;</line>
					<emptyLine/>
					<line><plainCmt>Removes cookies from request and response</plainCmt></line>
					<line>public class CookieFilter implements <javadoc>Filter</javadoc> {</line>
					<line>    private <javadoc>ServletContext</javadoc> ctx;</line>
					<emptyLine/>
					<line>    public void <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/Filter.html#init(javax.servlet.FilterConfig)">init</javadoc>(<javadoc>FilterConfig</javadoc> config) {</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public void <javadoc>doFilter</javadoc>(<javadoc>ServletRequest</javadoc> request, <javadoc>ServletResponse</javadoc> response, <javadoc>FilterChain</javadoc> chain) </line>
					<line>        throws <javadoc>IOException</javadoc>, <javadoc>ServletException</javadoc> {</line>
					<emptyLine/>
					<line>        chain.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/FilterChain.html#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse)">doFilter</javadoc>(new NonCookieRequest(request), new NonCookieResponse(response));</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public void <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/Filter.html#destroy()">destroy</javadoc>() {</line>
					<line>    }</line>
					<emptyLine/>
					<line>    static class CookieRemovingServletRequest extends <javadoc>HttpServletRequestWrapper</javadoc> {</line>
					<line>        public CookieRemovingServletRequest(<javadoc>ServletRequest</javadoc> request) {</line>
					<line>            super((<javadoc>HttpServletRequest</javadoc>)request);</line>
					<line>        }</line>
					<emptyLine/>
					<line>        public <javadoc>Cookie</javadoc>[] <javadoc>getCookies</javadoc>() {</line>
					<line>            return null;<cmt>no cookies visible</cmt></line>
					<line>        }</line>
					<line>    }</line>
					<emptyLine/>
					<line>    static class CookieRemovingServletResponse extends <javadoc>HttpServletResponseWrapper</javadoc> {</line>
					<line>        public CookieRemovingServletResponse(<javadoc>ServletResponse</javadoc> response) {</line>
					<line>            super((<javadoc>HttpServletResponse</javadoc>)response);</line>
					<line>        }</line>
					<emptyLine/>
					<line>        public void <javadoc>addCookie</javadoc>(<javadoc>Cookie</javadoc> cookie) {</line>
					<line>            <plainCmt>ignore!</plainCmt></line>
					<line>        }</line>
					<line>    }</line>
					<line>}</line>
				</code>
				<explanation>Like <javadoc>Servlet</javadoc> implementations, <em>filter classes can use the <javadoc>@Resource</javadoc> annotation</em>.</explanation>
			</content>

		</collapsedSubSection>
		
	</singleColumnSection>
	
	
	
	<singleColumnSection anchor="howtosessionssecurity" multipage="true">
		<head>How to... Sessions and Security</head>
		
		<collapsedSubSection anchor="usermanagement">	
			<head>Authentication</head>
			<summary>How to Authenticate and Manage Users</summary>
			<content>
				<explanation>The Servlet API requires the container to offer a <em>rudimentary security system</em> which
				should be sufficient for most internal and corporate sites, but 
				<em>not for consumer-oriented internet sites</em> <more>For a consumer-oriented site it lacks features
				like letting user create their own accounts, change password by email, remembering the user's identity
				and many more. For a corporate application this is not important, since generally new users are only created by administrators.
				Also, most containers support authentification via external databases or LDAP directories, which is perfect
				in a corporate setting.</more>.</explanation>
				<list>
					<li><em>Authentication mechanisms</em>:
					<list>
						<li><link to="http://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic Authentication</link></li>
						<li><link to="http://en.wikipedia.org/wiki/Digest_access_authentication">HTTP Digest Authentication</link> (optional)</li>
						<li><annotated><title>SSL Client Authentication</title><explanation>This form of authentication requires that the user
				installs a SSL certificate into the client/browser. The certificate may either be obtained from a 
				well-known certificate authority, or created by the owner of the server. In any case, it is a very secure but also
				cumbersome way of authentication that's not practical for most end-users. It may be useful in a 
				corporate setting though.</explanation></annotated></li>
						<li>Simple <annotated><title>form-based authentication</title><explanation>The built-in form authentication
				only allows you to specify a HTML page with two fields for username and password. Users are then tracked 
				using <idf>HttpSession</idf>s.<br/>
				Form-based authentication lacks basic features
				expected from a consumer-oriented site, such as being able to retrieve the password by mail or
				a 'keep me signed in' function. </explanation></annotated></li>
					</list> 
					</li>
					<li><em>User management is container-specific</em> <more>The container may either store users in a 
					private file or database (and bring its own tools for user management), or is able to access an external 
					source for authentication data, such as a database or <topic>LDAP</topic> directory</more>. In any case, a web application
					can <em>only get the request user's name and role</em>, but not any additional information, from the container.</li>
					<li>Security is mostly role-based. A <em>web application declares security roles</em> in its <idf>web.xml</idf>,
					and the application defines the rights each role has. Each user can be in one or more roles. The mapping between 
					users and their roles is container specific and must be done by an administrator or the deployer.</li>
				</list>
				 
				 <explanation>
				 	In order to use the security system, the application needs to <em>declare roles and authentication mechanism</em>
				 	in its <idf>web.xml</idf> deployment descriptor. 
				 </explanation>
				 <miniHeadline>Declaring Roles</miniHeadline>
				 <explanation>All roles used by the application must be declared using the <tag>security-role</tag> element in
				 	the <idf>web.xml</idf> deployment descriptor. 
				 </explanation>
				 <config><tag>security-role</tag>
    <tag>description</tag>Administrator Role<ctag />
    <tag>role-name</tag><em>admin</em><ctag />
<ctag />

<tag>security-role</tag>
    <tag>description</tag>Privileged User<ctag />
    <tag>role-name</tag><em>privileged</em><ctag />
<ctag />

<tag>security-role</tag>
    <tag>description</tag>Guest User<ctag />
    <tag>role-name</tag><em>guest</em><ctag />
<ctag />
				 </config>
				 <miniHeadline>Basic Authentication</miniHeadline>
				 <explanation>For basic authentication, add this to your <idf>web.xml</idf> deployment descriptor:</explanation>
				 <config><tag>login-config</tag>
    <tag>auth-method</tag>BASIC<ctag />
    <tag>realm-name</tag>My Realm<ctag />       <cmt>shown to the user</cmt>
<ctag />
				 </config>
				 <miniHeadline>Digest Authentication</miniHeadline>
				 <explanation><idf>DIGEST</idf> authentication is optional and not supported by older browsers, but more secure than
				 <idf>BASIC:</idf></explanation>
				 <config><tag>login-config</tag>
    <tag>auth-method</tag>DIGEST<ctag />
<ctag />
</config>
				 <miniHeadline>Form-based Authentication</miniHeadline>
				 <explanation>For <idf>FORM</idf> authentication you need to create two pages containing the actual authentication screens:</explanation>
				 <config><tag>login-config</tag>
    <tag>auth-method</tag>FORM<ctag />

    <tag>form-login-config</tag>
        <tag>form-login-page</tag>/login.jsp<ctag />           <cmt>login form</cmt>
        <tag>form-error-page</tag>/login-error.html<ctag />    <cmt>error page</cmt>
    <ctag />
<ctag />
				 </config>
				 <explanation>
				 	The login page <em>must have a HTML form</em> using the POST method, with a form action 'j_security_check'
				 	and two fields 'j_username' and 'j_password'. The form looks like this:
				 </explanation>
				 <config>&lt;form method="POST" action="j_security_check">
    &lt;input type="text" name="j_username" />
    &lt;input type="password" name="j_password" />
&lt;/form>				 </config>
				<explanation></explanation>
				
				<miniHeadline>SSL Client Authentication</miniHeadline>
				<explanation>To require authentication with a SSL client certificate, add this in your <idf>web.xml</idf> deployment descriptor:</explanation>
				<config><tag>login-config</tag>
    <tag>auth-method</tag>CLIENT-CERT<ctag />
<ctag />	 
</config>
				<explanation>When a client authenticated itself with a SSL client certificate, you can retrieve the certificate
				chain from the <link anchor="attributes">request attribute</link> <idf>javax.servlet.request.X509Certificate</idf>. 
				It contains an array 
				of <javadoc to="http://java.sun.com/javase/6/docs/api/javax/security/cert/X509Certificate.html">java.security.cert.X509Certificate</javadoc> instances.</explanation>
			</content>
		</collapsedSubSection>

		
		<collapsedSubSection anchor="declarativesecurity">	
			<head>Declarative Security</head>
			<summary>How to Restrict Access to a Web Application (Declarative Security)</summary>
			<content>
				<explanation>By default, <em>access to web applications is not restricted</em>. If you
				want to restrict access to your web application or parts thereof, including static content,
				you need to <em>declare those restrictions in your <idf>web.xml</idf></em> deployment descriptor.
				When a user requests a restricted page, the container will automatically ask her to log in
				using the mechanism set with <tag>login-config</tag> (see <link anchor="usermanagement">authentication and user management</link>).
				</explanation>
				<explanation>The following <idf>web.xml</idf> snippet allows access to several sub-folders only to users
				who have either the 'admin' or the 'privileged' role.</explanation>
				<config><tag>security-constraint</tag>
    <tag>web-resource-collection</tag>
        <tag>web-resource-name</tag>Privileged area<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/restricted/*<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/premium/*<ctag /> 
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/dyn/stats/*<ctag /> 
    <ctag />
    
    <tag>auth-constraint</tag>
        <tag ref="doc-auth-constraint-role-name">role-name</tag>admin<ctag />
        <tag ref="doc-auth-constraint-role-name">role-name</tag>privileged<ctag />
    <ctag /> 
<ctag /></config>
			<explanation>The user can access the resource <em>if at least one <tag>security-constraint</tag> permits it</em>. Requiring
			two roles for accessing a resource is not possible with declarative security (but you
			can do this with <link anchor="programmaticsecurity">programmatic security</link>).</explanation>
			<miniHeadline>Allowing All Roles</miniHeadline>
			<explanation>The special role name '*' stands for all declared roles. Unauthenticated users do not have access.</explanation>
			<config><tag>security-constraint</tag>
    <tag>web-resource-collection</tag>
        <tag>web-resource-name</tag>User area<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/user/*<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/settings/*<ctag /> 
    <ctag />
    
    <tag>auth-constraint</tag>
        <tag ref="doc-auth-constraint-role-name">role-name</tag><em>*</em><ctag />       <cmt>allow all roles</cmt>
    <ctag /> 
<ctag /></config>

			<miniHeadline>Forbid Access to All Roles</miniHeadline>
			<explanation>If you want to forbid access for all roles (e.g. for data files used by the servlet), leave the 
			<tag>auth-constraint</tag> empty:</explanation>
			<config><tag>security-constraint</tag>
    <tag>web-resource-collection</tag>
        <tag>web-resource-name</tag>Data area<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/data/*<ctag />
    <ctag />
    
    <tag>auth-constraint</tag>       <cmt>empty constraint: forbid all access</cmt>
    <ctag /> 
<ctag /></config>

			<miniHeadline>Restricting Access by HTTP Method</miniHeadline>
			<explanation>By default, a <tag>web-resource-collection</tag> applies to all HTTP methods. You can also limit access by method:
			</explanation>
			<config><tag>security-constraint</tag>
    <tag>web-resource-collection</tag>
        <tag>web-resource-name</tag>Resource Modification<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/*<ctag />
        
        <tag>http-method</tag><em>DELETE</em><ctag />
        <tag>http-method</tag><em>PUT</em><ctag />
    <ctag />
    
    <tag>auth-constraint</tag>   <cmt>Only admins can delete and put</cmt>
        <tag ref="doc-auth-constraint-role-name">role-name</tag>admin<ctag />
    <ctag /> 
<ctag /></config>
			
			<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="requiringssl">
			<head>SSL</head>
			<summary>How to Require HTTPS / SSL</summary>
			<content>
				<explanation>To require <link to="http://en.wikipedia.org/wiki/HTTP_Secure">HTTPS (SSL)</link> for a resource define a security constraint with <tag>transport-guarantee</tag>. Then any attempt
			to access it without SSL will be <em>redirected to a <idf>https</idf> URL</em>.
			</explanation><explanation>
			This example requires SSL for two directories:</explanation>
			<config><tag>security-constraint</tag>
    <tag>web-resource-collection</tag>
        <tag>web-resource-name</tag>User Preferences<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/prefs/*<ctag />
        <tag ref="doc-web-resource-collection-url-pattern">url-pattern</tag>/settings/*<ctag /> 
    <ctag />
    
    <tag>user-data-constraint</tag>
        <tag>transport-guarantee</tag>CONFIDENTIAL<ctag /> <cmt>"CONFIDENTIAL" means SSL</cmt>
    <ctag />
<ctag /></config>
			<explanation>You can also combine the <tag>user-data-constraint</tag> element with <tag>auth-constraint</tag> to
			require HTTPS for restricted resources.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="programmaticsecurity">	
			<head>Programmatic Security</head>
			<summary>How to Use Authentication Data in Servlets</summary>
			<content>
				<explanation>When a user is logged in, servlets can <em>get the user's name and check her roles</em>. 
				This is only possible in combination with <link anchor="declarativesecurity">declarative security</link>, 
				because the container <em>authenticates users only for restricted resources</em> <more>The Servlet
				API specifies several authentication modes (described above), but they all prompt the
				user only for authentication when the user has not authenticated yet and tries to access
				a restricted resource. <em>Without restricted resources users can not log in</em> and thus
				servlets won't get any authentication data.</more>.
 				</explanation><explanation>
				The <javadoc>ServletRequest</javadoc> provides you with three methods to access authentication data:</explanation>
				<list>
					<li><javadoc>getUserPrincipal</javadoc> returns the user's <javadoc>Principal</javadoc> object <more>The Principal
					class is very simple and offers you nothing more than the user's name (which you can easily
					get with <idf>getRemoteUser</idf>). Web containers may return a sub-class of <idf>Principal</idf> offering 
					additional information, but this is container-specific.</more>, or null if
					no user is logged in</li>
					<li><javadoc>getRemoteUser</javadoc> returns the user's login name, or null if no user is logged in</li>
					<li><javadoc>isUserInRole</javadoc> checks whether the current user is in the given role</li>
				</list>
				
				<miniHeadline>Getting the User's Identity</miniHeadline>
				<explanation>
				This example logs the authenticated user:
				</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>      throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>    <javadoc>Principal</javadoc> p = request.<javadoc><em>getUserPrincipal</em></javadoc>();</line>
					<line>    if (p == null)</line>
					<line>        <javadoc>log</javadoc>("No user logged in.");</line>
					<line>    else {</line>
					<line>        <javadoc>log</javadoc>("Principal: " + p.<javadoc to="http://java.sun.com/javase/6/docs/api/java/security/Principal.html#getName()">getName</javadoc>());</line>
					<line>        <javadoc>log</javadoc>("User name: " + request.<javadoc><em>getRemoteUser</em></javadoc>());</line>
					<line>    }</line>
					<emptyLine/>
					<line>    <plainCmt><abstract>...</abstract></plainCmt></line>
	    			<line>}</line>
				</code>
				<miniHeadline>Role Checking</miniHeadline>
				<explanation>You can use <javadoc>isUserInRole</javadoc> to check whether the user is in the specified
				role. This code checks the user's roles:</explanation>
				<code>
					<line><javadoc>HttpServletRequest</javadoc> request = <abstract>...</abstract>;</line>
					<line>if ( request.<javadoc>isUserInRole</javadoc>("root") || </line>
					<line>     (request.<javadoc>isUserInRole</javadoc>("privileged") &amp;&amp;</line>
					<line>      request.<javadoc>isUserInRole</javadoc>("merchandise")) ) {</line>
					<line>    <plainCmt><abstract>user authenticated</abstract></plainCmt></line>
					<line>}</line>
				</code>
				<explanation>By default, the argument to <javadoc>isUserInRole</javadoc> is a <em>role decared 
				in the <idf>web.xml</idf></em> deployment descriptor using
				<tag>security-role</tag> (see <link anchor="usermanagement">user management</link>). If your servlet needs
				different names, it map the name in its declaration:</explanation>
				<config><tag>servlet</tag>
    <tag>servlet-name</tag>adminServlet<ctag/>
    <tag>servlet-class</tag>com.jarfiller.example.AdminServlet<ctag/>
        
    <tag>security-role-ref</tag>
        <tag ref="doc-security-role-ref-role-name">role-name</tag>root<ctag/>          <cmt>the servlet's internal name</cmt>
        <tag ref="doc-security-role-ref-role-link">role-link</tag>admin<ctag/>         <cmt>the application's name in <idf>&lt;security-role></idf></cmt>
    <ctag/>
    <tag>security-role-ref</tag>
        <tag ref="doc-security-role-ref-role-name">role-name</tag>privileged<ctag/>    <cmt>the servlet's internal name</cmt>
        <tag ref="doc-security-role-ref-role-link">role-link</tag>super-user<ctag/>    <cmt>the application's name in <idf>&lt;security-role></idf></cmt>
    <ctag/>
    <tag>security-role-ref</tag>
        <tag ref="doc-security-role-ref-role-name">role-name</tag>merchandise<ctag/>   <cmt>the servlet's internal name</cmt>
        <tag ref="doc-security-role-ref-role-link">role-link</tag>merch-user<ctag/>    <cmt>the application's name in <idf>&lt;security-role></idf></cmt>
    <ctag/>
<ctag/>
				</config>
				
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="cookielessessions">
			<head>Cookie-less Sessions</head>
			<summary>How to Use HttpSessions and Authentication without Cookies?</summary>
			<content>
				<explanation>If a user does not accept cookies, the <em>Servlet API offers URL rewriting</em> as a last 
				resort to track users. This means that the web application's URLs need to be modified to
				include the session id. A URL with session id looks like this:</explanation>
				<config>   http://www.example.com/myapp/index.html<em>;jsessionid=1234</em></config>
				<explanation>In order to convert a regular URL into a URL with session id you need to encode it
				with the HttpServletResponse method <javadoc to="javax/servlet/http/HttpServletResponse.html#encodeURL(java.lang.String)">encodeURL</javadoc>.
				<em>Every URL returned by the application</em> as part of the response needs to be encoded, including links on HTML pages,
				actions in HTML forms and URLs used by JavaScript.</explanation>
				<explanation>Note that the server <em>can not rewrite the URLs of static content</em>. A user will always get a new session when she
				visits a static page and then clicks on any link on it. Thus if you rely on sessions
				and want to allow URL rewriting to support cookie-less sessions, don't mix static pages with dynamic
				(URL-rewriting) pages.
				</explanation>
			</content>
		</collapsedSubSection>

	</singleColumnSection>	
	
	
	
	<singleColumnSection anchor="howtogeneral" multipage="true">
		<head>How to... General</head>
				
		<collapsedSubSection anchor="addinglibraries">
			<head>Libraries</head>
			<summary>How to Add Libraries to a Web Application / WAR</summary>
			<content>
				<explanation>
				To include a library to your web application, just <em>add the <topic>JAR</topic> file(s) into the "/WEB-INF/lib/" directory</em>
				of your web application.  They must have a "*.jar" extension, sub-directories are not supported.
				</explanation>
				<explanation>	
				Many web containers also have a way of adding shared libraries that can be used for all applications. For example, to add
				a shared library to <link to="http://tomcat.apache.org/">Tomcat</link> just copy the JARs into its <idf>/lib</idf> directory.
				</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="addingresourcefiles">
			<head>Resources</head>
			<summary>How to Read Files Contained in a Web Application / WAR</summary>
			<content>
				<explanation>
					If your servlet requires any additional files, <em>put those data files into /WEB-INF/</em> <more>The reason for putting them in 
					<idf>WEB-INF</idf> is that data files should usually not be served as static content. <idf>/WEB-INF/</idf>
					and <idf>/META-INF/</idf> are the only directories in a web application that the container will never show to the user.<br/>
					You can	also create a sub-directory in <idf>WEB-INF</idf> to organize your files.</more>. <javadoc>ServletContext</javadoc> offers three ways of reading
					them:</explanation>
					<table>
						<head><cell>Method</cell><cell>Returns</cell><cell>Required?</cell></head>
						<row><cell><javadoc>getResourceAsStream</javadoc></cell><cell><javadoc>InputStream</javadoc> to read the file</cell><cell>Yes</cell></row>
						<row><cell><javadoc>getResource</javadoc></cell><cell><javadoc>URL</javadoc> of the file</cell><cell>Yes</cell></row>
						<row><cell><javadoc>getRealPath</javadoc></cell><cell>Path to file (<idf>String</idf>)</cell><cell><annotated><title>No</title><explanation>Containers are not required to
						support this, as not every web container will extract WAR archives and put them into the file system. But most do this and thus can support the method.</explanation></annotated></cell></row>
					</table>
				<explanation>
					Usually <javadoc>getResourceAsStream</javadoc> is the most useful of the three. The following example uses it to 
					read a <javadoc>Properties</javadoc> file:
				</explanation>
				
				<code>
					<line><javadoc>Properties</javadoc> config = new <javadoc>Properties</javadoc>();</line>
					<line>config.<javadoc to="http://java.sun.com/javase/6/docs/api/java/util/Properties.html#load(java.io.InputStream)">load</javadoc>(<javadoc>getServletContext</javadoc>().<javadoc><em>getResourceAsStream</em></javadoc>("/WEB-INF/config.properties"));</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="throwingexceptions">
			<head>Exceptions</head>
			<summary>How to Throw Exceptions in Servlets</summary>
			<content>
				<explanation>If a servlet <em>encounters an unhandled problem</em>, it can <em>throw a <javadoc>ServletException</javadoc></em> (for
				expected problems, such as an errornous user input, you should show a error message to the user). Alternatively, you can also throw
				a <javadoc>RuntimeException</javadoc>. On both types of exceptions <em>the container will return the HTTP status code 500</em>
				(internal error).
				</explanation>
				<explanation>A special kind of <javadoc>ServletException</javadoc> is the <javadoc>UnavailableException</javadoc>, which
				 <em>tells the server that the servlet is currently or permanently unavailable</em>. You can either specify the
				 number of seconds the application will be unavailable, causing the server to respond with a HTTP status code 503
				 (service unavailable) during that time. Or you create the exception without a duration, and the server will
				 remove the servlet and start returning HTTP status code 404 (not found).</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc>, <javadoc><em>ServletException</em></javadoc> {</line>
					<line>    if (<abstract>permanentlyUnavailable</abstract>)</line>
					<line>        throw new <javadoc><em>UnavailableException</em></javadoc>("Servlet is gone");</line>
					<line>    if (<abstract>temporarilyUnavailable</abstract>)</line>
					<line>        throw new <javadoc><em>UnavailableException</em></javadoc>("Try again later..", <em>60</em>);<cmt>unavailable for 60s</cmt></line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="initparameters">
			<head>Parameters</head>
			<summary>Configure your Servlet with Initialization Parameters</summary>
			<content>	
				<explanation>It is possible to <em>pass parameters</em> from the <idf>web.xml</idf> deployment descriptor to your Servlets.
				You can either use <em>application-wide context parameters</em> or <em>servlet-specific initialization parameters</em>.<br/>
				The following <idf>web.xml</idf> uses both to configure a servlet:</explanation>
				
				<config>&lt;?xml version="1.0" encoding="UTF-8"?>
<tag>web-app <doc>xmlns</doc>="http://java.sun.com/xml/ns/j2ee"
         <doc>xmlns:xsi</doc>="http://www.w3.org/2001/XMLSchema-instance"
         <doc>xsi:schemaLocation</doc>="http://java.sun.com/xml/ns/j2ee
                             http://java.sun.com/xml/ns/j2ee/web-app_2_5.xsd"
         <doc>version</doc>="2.5"</tag>

    <tag>context-param</tag>                         <cmt><em>application-wide</em> settings</cmt>
        <tag>param-name</tag>appName<ctag/>
        <tag>param-value</tag>Example.com<ctag/>
    <ctag/>
     <tag>context-param</tag>
        <tag>param-name</tag>webmaster<ctag/>
        <tag>param-value</tag>tim@example.com<ctag/>
    <ctag/>
    

    <tag>servlet</tag>
        <tag>servlet-name</tag>mainServlet<ctag/>
        <tag>servlet-class</tag>com.jarfiller.example.MainServlet<ctag/>
        
        <tag ref="doc-servlet-init-param">init-param</tag>                        <cmt><em>servlet-specific</em> settings</cmt>
            <tag>param-name</tag>background-color<ctag/>
            <tag>param-value</tag>black<ctag/>
        <ctag/>
        <tag ref="doc-servlet-init-param">init-param</tag>
            <tag>param-name</tag>foreground-color<ctag/>
            <tag>param-value</tag>white<ctag/>
        <ctag/>
    <ctag/>
<ctag/>
				</config>
				<explanation>Here is a <javadoc>init</javadoc> method that reads from the initialization parameters:</explanation>
				
				<code>
					<line>public void <javadoc>init</javadoc>(<javadoc>ServletConfig</javadoc> config) throws <javadoc>ServletException</javadoc> {</line>
					<line>  super.<javadoc>init</javadoc>(config); <plainCmt>important for <javadoc>getServletContext</javadoc> and <javadoc>getServletConfig</javadoc> <more>If your
					servlet class extends <idf>HttpServlet</idf> or its super class <idf>GenericServlet</idf>, then
					<idf>getServletContext</idf> and <idf>getServletConfig</idf> will only work if the original
					<javadoc>init</javadoc> method has been invoked! Otherwise the <idf>GenericServlet</idf> will
					not be able to store the context reference.</more></plainCmt></line>
					<emptyLine/>
					<line>    <javadoc>log</javadoc>(String.<javadoc>format</javadoc>(</line>
					<line>         "Configuration:\nappName=%s\nwebmaster=%s\nbg-color=%s\nfg-color=%s\n",</line>
					<line>         <javadoc><em>getServletContext</em></javadoc>().<javadoc>getInitParameter</javadoc>("appName"), <cmt>application-wide parameters</cmt></line>
					<line>         <javadoc>getServletContext</javadoc>().<javadoc>getInitParameter</javadoc>("webmaster"), </line>
					<line>         <javadoc><em>getServletConfig</em></javadoc>().<javadoc to="javax/servlet/ServletConfig.html#getInitParameter(java.lang.String)">getInitParameter</javadoc>("background-color"), <cmt>servlet parameters</cmt></line>
					<line>         <javadoc>getServletConfig</javadoc>().<javadoc to="javax/servlet/ServletConfig.html#getInitParameter(java.lang.String)">getInitParameter</javadoc>("foreground-color") </line>
					<line>         ));</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		

		<collapsedSubSection anchor="logging">
			<head>Logging</head>
			<summary>How to Log</summary>
			<content>
				<explanation>While you can use full-blown logging solutions such as Java's 
				<link to="http://java.sun.com/javase/6/docs/api/java/util/logging/package-summary.html">logging facilities</link>
				and <link to="http://logging.apache.org/log4j/">log4j</link> in servlets, the Servlet API offers a very simple but convenient way of logging.
				The methods <javadoc to="javax/servlet/ServletContext.html#log(java.lang.String)">log(String)</javadoc>
				and <javadoc to="javax/servlet/ServletContext.html#log(java.lang.String, java.lang.Throwable)">log(String,Throwable)</javadoc>
				in <javadoc>ServletContext</javadoc> allow you to <em>add a line to the server's event log</em>, optionally with an Exception as second
				argument. For convenience, <javadoc>HttpServlet</javadoc> (and its super-class <javadoc>GenericServlet</javadoc>) also provides 
				you with two identical <javadoc>log</javadoc> methods that call the implementations in <javadoc>ServletContext</javadoc>. So in
				order to log something in a <javadoc>HttpServlet</javadoc> sub-class you only need to write this:
				</explanation>
				<code>
					<line>protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>    <javadoc><em>log</em></javadoc>("I am in the log!");</line>
					<line>    <plainCmt><abstract>...</abstract></plainCmt></line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
				
		<collapsedSubSection anchor="errorpages">	
			<head>Error Pages</head>
			<summary>How to Replace the Default Error Page</summary>
			<content>
				<explanation>If the web server sends an HTTP error status code to the client, it sends its
				own error page to the client by default. This default page is rarely what you want for a polished application,
				so you often need to replace it with custom error pages.</explanation>
				<explanation><em>Replace the default error page with the <tag>error-page</tag> element</em> in
				the <idf>web.xml</idf> deployment descriptor:</explanation>
				<config><tag>error-page</tag>
    <tag>error-code</tag>404<ctag />               <cmt>HTTP status code</cmt>
    <tag>error-page</tag>/error404.html<ctag />    <cmt>static page, servlet URL or JSP</cmt>
<ctag /></config>
				<explanation>You can only specify one error code per <tag>error-page</tag> element. Repeat 
				<tag>error-page</tag> to provide pages for other error codes. It is <em>not possible to declare a page for all error codes</em>.</explanation>
				<explanation>You can also declare a special error page for an exception:</explanation>
				<config><tag>error-page</tag>
    <tag>exception-type</tag>java.lang.NullPointerException<ctag />  <cmt>best match <more>If you
define several error pages for exceptions, and more than one of them matches an exception, then the declaration
with <em>the closest match in the class hierarchy wins</em>.</more></cmt>
    <tag>error-page</tag>/errors/errorNPE.jsp<ctag />
<ctag /></config>
				<explanation>If you provide an <tag>error-page</tag> URL that is handled by a servlet or a JSP, then the
				container will provide the servlet with the following attributes in the request:</explanation>
					<table>
						<head><cell>Name</cell><cell>Type</cell><cell>Description</cell></head>
						<row><cell>javax.servlet.error.status_code</cell><cell>Integer</cell><cell>HTTP status code (<idf>500</idf> for exceptions)</cell></row>
						<row><cell>javax.servlet.error.message</cell><cell>String</cell><cell>error message</cell></row>
						<row><cell>javax.servlet.error.request_uri</cell><cell>String</cell><cell>original request URI (see <javadoc>getRequestURI</javadoc>)</cell></row>
						<row><cell>javax.servlet.error.servlet_name</cell><cell>String</cell><cell>name of servlet that caused the error</cell></row>
						<row><cell>javax.servlet.error.exception_type</cell><cell>Class</cell><cell>exception class (<idf>null</idf> for status code errors)</cell></row>
						<row><cell>javax.servlet.error.exception</cell><cell>Throwable</cell><cell>exception (<idf>null</idf> for status code errors)</cell></row>
					</table>
					
					<explanation>Here is a simple servlet that returns some information about an error:</explanation>
				<code>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<line>import <javadoc>java.io.*</javadoc>;</line>
					<emptyLine/>
					<line>public class ErrorHandlerServlet extends <javadoc>HttpServlet</javadoc> {</line>
					<emptyLine/>
					<line>    private void doGet(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>        response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");</line>
					<line>        response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<emptyLine/>
					<line>        <javadoc>PrintWriter</javadoc> w = response.<javadoc>getWriter</javadoc>();</line>
					<line>        w.<javadoc>printf</javadoc>("Error Code: %d\n", request.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getAttribute()"><em>getAttribute</em></javadoc>("javax.servlet.error.status_code"));</line>
					<line>        w.<javadoc>printf</javadoc>("Message: %s\n", request.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getAttribute()"><em>getAttribute</em></javadoc>("javax.servlet.error.message"));</line>
					<line>        w.<javadoc>printf</javadoc>("URL: %s\n", request.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getAttribute()"><em>getAttribute</em></javadoc>("javax.servlet.error.request_uri"));</line>
					<line>        w.<javadoc>printf</javadoc>("Name: %s\n", request.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletRequest.html#getAttribute()"><em>getAttribute</em></javadoc>("javax.servlet.error.servlet_name"));</line>
					<line>    }</line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="temporarydirectory">
			<head>Temporary Directory</head>
			<summary>How to Get a Temporary Directory</summary>
			<content>
				<explanation>The web container <em>provides every web application with a private temporary
				directory</em>. Its location is stored in the context attribute <idf>javax.servlet.context.tempdir</idf>. 
				The specification leaves it open whether the server deletes the directory's content after a restart,
				so your application should be prepared for both cases.</explanation>
				<code>
					<line><javadoc>File</javadoc> tmpDir = (<javadoc>File</javadoc>) <javadoc>getServletContext</javadoc>().<em><javadoc>getAttribute</javadoc>("javax.servlet.context.tempdir")</em>;</line>
					<line><javadoc>File</javadoc> privFile = new <javadoc>File</javadoc>(tmpDir, "myTempFile");</line>
					<line>privFile.<javadoc>delete</javadoc>();<cmt>delete file in case it already exists</cmt></line>
					<emptyLine/>
					<line><plainCmt><abstract>do something with privFile</abstract></plainCmt></line>
					<emptyLine/>
					<line>privFile.<javadoc>delete</javadoc>(); <cmt>clean up (possibly in <javadoc>destroy</javadoc>)</cmt></line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="ejbinvocation">	
			<head>EJB Invocation</head>
			<summary>How to Access an EJB</summary>
			<content>
				<explanation>If you run your servlet in a EJB 3.x capable container, accessing EJBs from a servlet is very easy. 
				Similar to the <link anchor="resources">@Resource annotation</link>, you only need to declare a <em>field or property</em> with the
				<em>EJB interface as type and an <javadoc>@EJB</javadoc> annotation</em>. The container will automatically inject the
				value after the servlet's construction. Filters and listeners are also suported.</explanation>
				<explanation>Let's take this simple EJB interface:</explanation>
				<code>
					<line>import <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/ejb/Local.html">javax.ejb.Local</javadoc>;</line>
					<emptyLine/>
					<line><javadoc>@Local</javadoc></line>
					<line>public interface HelloBeanLocal {</line>
					<line>    String hello();</line>
					<line>}</line>
				</code>
				<explanation>
					The following servlet uses the <javadoc>@EJB</javadoc> annotation to acquire a reference to a <idf>HelloBeanLocal</idf> bean
					and invokes it in its <javadoc>doGet</javadoc> method:
				</explanation>
				<code>
					<line>import <javadoc to="http://java.sun.com/javaee/5/docs/api/javax/ejb/EJB.html">javax.ejb.EJB</javadoc>;</line>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<line>import <javadoc>java.io.*</javadoc>;</line>
					<emptyLine/>
					<line>public class EjbUsingServlet extends <javadoc>HttpServlet</javadoc> {</line>
					<emptyLine/>
					<line>    <javadoc><em>@EJB</em></javadoc></line>
					<line>    private HelloBeanLocal helloBean;</line>
					<emptyLine/>
					<line>    private void doGet(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response)</line>
					<line>        throws <javadoc>IOException</javadoc> {</line>
					<emptyLine/>
					<line>        response.<javadoc>setContentType</javadoc>("text/plain; charset=UTF-8");</line>
					<line>        response.<javadoc>setCharacterEncoding</javadoc>("UTF-8");</line>
					<emptyLine/>
					<line>        String v = <em>helloBean.hello()</em>;<cmt>invoke the EJB</cmt></line>
					<line>        response.<javadoc>getWriter</javadoc>().<javadoc>println</javadoc>("The EJB says " + v);</line>
					<line>    }</line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="distributedapps">
			<head>Distributed Applications</head>
			<summary>How to Create a Distributed Application</summary>
			<content>
				<explanation>
				A distributed web application is an application that is capable of <em>running in a cluster 
				of web containers</em>. It's not very difficult to create a distributable application,
				as long as you follow these rules:</explanation>
				<list>
					<li><javadoc>HttpSession</javadoc> can be moved across cluster nodes. You must 
					<em>store only <topic>serializable</topic> objects in <javadoc>HttpSession</javadoc></em> (most 
					<em>EJB-capable container allow EJB references</em> as well).</li>
					<li>The application has a <em>separate <javadoc>ServletContext</javadoc> instance on every cluster node</em>. 
					Any attributes that you set in the context are local to the node that set them.</li>
					<li>As each node runs a separate Java VM, <em>static fields are not distributed</em> and thus any values stored in them are
					local to the cluster node.</li>
				</list>
				<explanation>In practice, that means if your application needs to keep data longer than for handling the current request,
				it needs to store it either <em>in the <javadoc>HttpSession</javadoc> or in a database shared by all cluster nodes</em>.
				</explanation>
				<explanation>In order to mark your web application as distributable, <em>you must put an <tag>distributable</tag>
				element in your <idf>web.xml</idf></em>. The element is always empty, you only need to add the following line:</explanation>
				<config><tag stand-alone="true">distributable</tag>
</config>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		
		<collapsedSubSection anchor="listeners">
			<head>Listeners</head>
			<summary>How to Be Notified about Events (Listeners)</summary>
			<content>
				<explanation>The Servlet API provides a number of <em>listener interfaces</em> that you can implement
				to be notified about various events. You only need to implement the interface in a class and
				<em>declare that class as listener</em> in the <idf>web.xml</idf> deployment descriptor.</explanation>
				<explanation>The Servlet API defines the following listener interfaces for applications:</explanation>
				<table>
					<head><cell>Interface</cell><cell>Events</cell></head>
					<row><cell><javadoc package="javax.servlet">ServletContextListener</javadoc></cell><cell>Initialization and destruction of the application</cell></row>
					<row><cell><javadoc package="javax.servlet">ServletContextAttributeListener</javadoc></cell><cell>Changes in context attributes</cell></row>
					<row><cell><javadoc package="javax.servlet">ServletRequestListener</javadoc></cell><cell>Creation and destruction of requests</cell></row>
					<row><cell><javadoc package="javax.servlet">ServletRequestAttributeListener</javadoc></cell><cell>Changes in request attributes</cell></row>
					<row><cell><javadoc>HttpSessionListener</javadoc></cell><cell>Creation and destruction of sessions</cell></row>
					<row><cell><javadoc>HttpSessionAttributeListener</javadoc></cell><cell>Changes in session attributes</cell></row>
				</table>
				<explanation>Note that the interfaces <javadoc>HttpSessionActivationListener</javadoc> and <javadoc>HttpSessionBindingListener</javadoc>
				are not listener interfaces to be implemented at the application level, but are implemented by objects being bound
				to a session.
				</explanation>
				<explanation>The following <idf>web.xml</idf> snippet shows how to declare a listener (any listener - it <em>does not matter
				which interface(s) it implements</em>):</explanation>
				<config><tag>listener</tag>
    <tag>listener-class</tag>com.jarfiller.example.SessionLogger<ctag/>
<ctag/>				
				</config>
				<explanation>This is an example shows the implementation of a simple listener:</explanation>
				<code>
					<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
					<emptyLine/>
					<line>public class SessionLogger <em>implements <javadoc>HttpSessionListener</javadoc></em> {</line>
					<emptyLine/>
					<line>    public void <javadoc><em>sessionCreated</em></javadoc>(<javadoc>HttpSessionEvent</javadoc> event) {</line>
					<line>        event.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSessionEvent.html#getSession()">getSession</javadoc>().<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSession.html#getServletContext()">getServletContext</javadoc>().<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#log(java.lang.String)">log</javadoc>("Created new session");</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public void <javadoc><em>sessionDestroyed</em></javadoc>(<javadoc>HttpSessionEvent</javadoc> event) {</line>
					<line>        event.<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSessionEvent.html#getSession()">getSession</javadoc>().<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpSession.html#getServletContext()">getServletContext</javadoc>().<javadoc to="http://java.sun.com/javaee/5/docs/api/javax/servlet/ServletContext.html#log(java.lang.String)">log</javadoc>("Session will be destroyed");</line>
					<line>    }</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		

		<collapsedSubSection anchor="servlet24">	
			<head>Servlet 2.4</head>
			<summary>New Features Since Servlet API 2.4</summary>
			<content>
				<explanation>New features in Servlet API 2.5:</explanation>
				<list>
					<li>Support for <javadoc>@Resource</javadoc> and other <topic>Common Annotations</topic> (see <link anchor="resources">Resources</link>)</li>
					<li>Simplified declaration of servlet and filter mappings in <idf>web.xml</idf> (see <link to="../../reference/webxml2x/#diffs25">Web.xml reference</link>)</li>
				</list>
			</content>
		</collapsedSubSection>
	</singleColumnSection>	

	<singleColumnSection anchor="andnow">
		<head>And now...?</head>
		<subSection anchor="nextsteps">
			<head>Next Steps</head>
			<explanation>This tutorial intends to give you a quick start on using Servlets, and maybe give answers for some questions
			that are hard to figure out. But now you are on you own. If you need to find out more, try to find
			it in the <link to="http://java.sun.com/javaee/5/docs/api/javax/servlet/package-summary.html">API Documents</link>
			and the <link to="/reference/webxml2x/">Jarfiller Web.xml Reference</link>.
			For a more thorough understanding of the Servlet API you should take the time to read 
			the <link to="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html">Servlet Specification</link>.
			 </explanation>
		</subSection>
	</singleColumnSection>
  </body>
  
  <sidebar>
    	<box>
	  		<title>Useful Links</title>
	  		<content>
	  			<link to="http://java.sun.com/products/servlet/">Servlet Homepage</link><br/>
	  			<link to="http://en.wikipedia.org/wiki/Java_Servlet">Servlet on Wikipedia</link><br/>
	  			<link to="http://java.sun.com/javaee/5/docs/api/javax/servlet/package-summary.html">javax.servlet API Docs</link><br/>
	  			<link to="http://java.sun.com/javaee/5/docs/api/javax/servlet/package-summary.html">javax.servlet.http API Docs</link><br/>
	  			<link to="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html">Servlet 2.5 Specification</link><br/>
	  		</content>
  		</box>
  		
  		<box>
	  		<title>Related Documents</title>
	  		<subTitleLine>(on Jarfiller.com)</subTitleLine>
	  		<content>
	  			<link to="/reference/webxml2x/">Web.xml Reference</link><br/>
	  		</content>
  		</box>
  	
  </sidebar>
  </article>
</page>


