<?xml version="1.0" encoding="UTF-8"?>
<page xmlns="http://tjansen.de/refPage" 
	xmlns:inc="http://tjansen.de/refPageInclude" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://tjansen.de/refPage ../../../schemas/page.xsd 
	                    http://tjansen.de/refPageInclude ../../../schemas/include.xsd">

  <path>/guide/jdbc/</path>
  <title>JDBC Guide</title>
  <titleIntro>Use JDBC to Access Relational Database</titleIntro>
 
  <license>cc-by-free-src</license>

  <multipage/>
  
  <topicConfig>
	<inc:includeContent file="../srcContent/shared/topics.inc.xml"/>
  </topicConfig>
 
  <javadocConfig>
	<baseURL>http://java.sun.com/javase/6/docs/api/</baseURL>
	<defaultPackage>java.sql</defaultPackage>
	<defaultAnnotationPackage>javax.annotations</defaultAnnotationPackage>
	<shortcuts>		
		<shortcut name="javax.servlet.*" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/package-summary.html"/>
		<shortcut name="javax.servlet.http.*" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/package-summary.html"/>
		<shortcut name="java.io.*" uri="http://java.sun.com/javase/6/docs/api/java/io/package-summary.html"/>
		<shortcut name="java.nio.*" uri="http://java.sun.com/javase/6/docs/api/java/nio/package-summary.html"/>
		<shortcut name="java.util.*" uri="http://java.sun.com/javase/6/docs/api/java/util/package-summary.html"/>
		<shortcut name="java.sql.*" uri="http://java.sun.com/javase/6/docs/api/java/sql/package-summary.html"/>
		<shortcut name="javax.sql.*" uri="http://java.sun.com/javase/6/docs/api/javax/sql/package-summary.html"/>
		<shortcut name="javax.naming.*" uri="http://java.sun.com/javase/6/docs/api/javax/naming/package-summary.html"/>
		<shortcut name="javax.annotations.*" uri="http://java.sun.com/javaee/5/docs/api/javax/annotations/package-summary.html"/>
		<shortcut name="java.sql.Date" uri="http://java.sun.com/javase/6/docs/api/java/sql/Date.html"/> 
	
		<shortcut name="RuntimeException" uri="http://java.sun.com/javase/6/docs/api/java/lang/RuntimeException.html" />
		<shortcut name="HttpServlet" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServlet.html"/>
		<shortcut name="HttpServletRequest" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletRequest.html"/>
		<shortcut name="HttpServletResponse" uri="http://java.sun.com/javaee/5/docs/api/javax/servlet/http/HttpServletResponse.html"/>
		<shortcut name="DataSource" uri="http://java.sun.com/javase/6/docs/api/javax/sql/DataSource.html" />
		<shortcut name="close" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#close()" />
		<shortcut name="getConnection" uri="http://java.sun.com/javase/6/docs/api/javax/sql/DataSource.html#getConnection()"/> 
		<shortcut name="executeUpdate" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#executeUpdate()"/> 
		<shortcut name="executeQuery" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#executeQuery()"/> 
		<shortcut name="execute" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#execute()"/> 
		<shortcut name="commit" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#commit()"/>
		<shortcut name="rollback" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#rollback()"/>
		<shortcut name="setAutoCommit" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#setAutoCommit(boolean)"/>
		<shortcut name="prepareStatement" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#prepareStatement(java.lang.String)"/>
		<shortcut name="prepareCall" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#prepareCall(java.lang.String)"/>
		<shortcut name="createStatement" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#createStatement()"/>
		<shortcut name="getMetaData" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#getMetaData()"/>
		
		<shortcut name="next" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#next()"/> 
		<shortcut name="previous" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#previous()"/> 
		<shortcut name="last" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#last()"/> 
		<shortcut name="absolute" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#absolute(int)"/> 
		<shortcut name="getDate" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getDate(java.lang.String)"/> 
		<shortcut name="getInt" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getInt(java.lang.String)"/> 
		<shortcut name="getLong" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getLong(java.lang.String)"/> 
		<shortcut name="getString" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getString(java.lang.String)"/> 
		<shortcut name="getBigDecimal" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getBigDecimal(java.lang.String)"/> 
		<shortcut name="getSQLXML" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getSQLXML(java.lang.String)"/> 
		<shortcut name="getObject" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getObject(java.lang.String)"/> 
		<shortcut name="BigDecimal" uri="http://java.sun.com/javase/6/docs/api/java/math/BigDecimal.html"/>
		<shortcut name="setBigDecimal" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#setBigDecimal(int, java.math.BigDecimal)"/>
		<shortcut name="setString" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#setString(int, java.lang.String)"/>
		<shortcut name="setDate" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#setString(int, java.sql.Date)"/>
		<shortcut name="setObject" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#setObject(int, java.lang.Object)"/>
		<shortcut name="intValue" uri="http://java.sun.com/javase/6/docs/api/java/math/BigDecimal.html#intValue()"/>
		<shortcut name="GregorianCalendar" uri="http://java.sun.com/javase/6/docs/api/java/util/GregorianCalendar.html"/>
		<shortcut name="Calendar" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html"/>
		<shortcut name="Calendar.JANUARY" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#JANUARY"/>
		<shortcut name="Calendar.JULY" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#JULY"/>
		<shortcut name="Calendar.JUNE" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#JUNE"/>
		<shortcut name="getTimeInMillis" uri="http://java.sun.com/javase/6/docs/api/java/util/Calendar.html#getTimeInMillis()"/>
		<shortcut name="TRANSACTION_NONE" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#TRANSACTION_NONE"/>
		<shortcut name="TRANSACTION_READ_UNCOMMITTED" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#TRANSACTION_READ_UNCOMMITTED"/>
		<shortcut name="TRANSACTION_READ_COMMITTED" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#TRANSACTION_READ_COMMITTED"/>
		<shortcut name="TRANSACTION_REPEATABLE_READ" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#TRANSACTION_REPEATABLE_READ"/>
		<shortcut name="TRANSACTION_SERIALIZABLE" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#TRANSACTION_SERIALIZABLE"/>
		<shortcut name="Connection.TRANSACTION_SERIALIZABLE" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#TRANSACTION_SERIALIZABLE"/>
		<shortcut name="setTransactionIsolation" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#setTransactionIsolation(int)"/>
		<shortcut name="getSource" uri="http://java.sun.com/javase/6/docs/api/java/sql/SQLXML.html#getSource(java.lang.Class)"/>
		<shortcut name="setResult" uri="http://java.sun.com/javase/6/docs/api/java/sql/SQLXML.html#setResult(java.lang.Class)"/>
		<shortcut name="registerOutParameter" uri="http://java.sun.com/javase/6/docs/api/java/sql/CallableStatement.html#registerOutParameter(int, int)"/>
		<shortcut name="Types.DECIMAL" uri="http://java.sun.com/javase/6/docs/api/java/sql/Types.html#DECIMAL"/>
		<shortcut name="setFetchSize" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#setFetchSize(int)"/>
		<shortcut name="setQueryTimeout" uri=""/>
		<shortcut name="addBatch" uri="http://java.sun.com/javase/6/docs/api/java/sql/Statement.html#addBatch(java.lang.String)"/>
		<shortcut name="executeBatch" uri="http://java.sun.com/javase/6/docs/api/java/sql/Statement.html#executeBatch()"/>
		<shortcut name="createArrayOf" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#createArrayOf(java.lang.String, java.lang.Object[])"/>
		<shortcut name="setArray" uri="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html#setArray(int, java.sql.Array)"/>
		<shortcut name="getArray" uri="http://java.sun.com/javase/6/docs/api/java/sql/ResultSet.html#getArray(java.lang.String)"/>
		<shortcut name="createStruct" uri="http://java.sun.com/javase/6/docs/api/java/sql/Connection.html#createStruct(java.lang.String, java.lang.Object[])"/>
		<shortcut name="getAttributes" uri="http://java.sun.com/javase/6/docs/api/java/sql/Struct.html#getAttributes()"/>
		<shortcut name="Statement.RETURN_GENERATED_KEYS" uri="http://java.sun.com/javase/6/docs/api/java/sql/Statement.html#RETURN_GENERATED_KEYS"/>
		<shortcut name="getGeneratedKeys" uri="http://java.sun.com/javase/6/docs/api/java/sql/Statement.html#getGeneratedKeys()"/>
		<shortcut name="" uri=""/>
		<shortcut name="" uri=""/>
		<shortcut name="" uri=""/>
		<shortcut name="" uri=""/>
		<shortcut name="" uri=""/>
		<shortcut name="" uri=""/>
		<shortcut name="" uri=""/>
		<shortcut name="" uri=""/>
	</shortcuts>
  </javadocConfig>

  <article>
  <body>
	<singleColumnSection anchor="overview">
	  	<head>Overview</head>
		<subSection anchor="intro">
			<head>Intro</head>
			<explanation>
				JDBC is a <em>low-level API</em> to work with <em><topic>SQL</topic>-based 
				<link to="http://en.wikipedia.org/wiki/Relational_database_management_system">relational databases</link></em> in Java. Practically all
				high-level persistence APIs, such as <topic>JPA</topic>, are built-on top of JDBC. 
			</explanation><explanation>
				To access a database via JDBC you <em>need a JDBC driver</em> for it. JDBC drivers are widely available for practically
				all relational databases and usually consist of a single JAR that you need to put into your classpath.
			</explanation><explanation>
				JDBC offers you various ways to <em>execute SQL statements</em> and 
				retrieve their results. The <link anchor="escape">escape syntax</link> helps you to
				write database-independent SQL. A <link anchor="types">type-mapping</link> defines how to
				set and retrieve SQL types in Java. 
			</explanation>
		</subSection>
		<collapsedSubSection anchor="usecases">
			<head>Use cases</head>
			<summary>When should you use JDBC for?</summary>
			<content>
				<explanation>Use JDBC when you..</explanation>
				<list>
					<li>want to write a simple application that just issues some SQL statements, and using a framework causes more trouble that it's worth</li>
					<li>want full control over the database (e.g. for performance reasons)</li>
					<li>need to access an existing legacy database that can not be easily map onto Java classes or requires
					you to call stored procedures etc</li>
					<li>want to write something that works with any database schema, such as a database viewer</li>
				</list>
				
				<miniHeadline>Alternatives</miniHeadline>
				<explanation>
					There are many frameworks which make database access less tedious for large and medium applications. Almost all of them are
					using JDBC internally, and require you to know at least something about JDBC (you need to configure the <javadoc>DataSource</javadoc>).
					These are the most important alternatives:</explanation>
				<list>
					<li><topic>JPA</topic> is the latest persistence API for Java. It provides
					a <link to="http://en.wikipedia.org/wiki/Object-relational_mapping">object-relational mapping</link>, but still allows
					direct database access with SQL. JPA is a part of EJB 3.0 and higher.</li>
					<li><link to="http://ibatis.apache.org">iBATIS</link> is a 'data mapper' which is similar to object-relational
					mapping, but more flexible. It is a good choice when object-relational mapping is not possible.</li>
					<li><link to="http://en.wikipedia.org/wiki/Java_Data_Objects">JDO</link> is an older API to store objects. Like JPA it offers
					object-relational mapping, but can also be used with non-relational databases.</li>
				</list>
				<explanation>Note that when you write code to run in a framework (such as <link to="http://www.springsource.org/">Spring</link>), the framework
					may provide its own persistence system which you should consider then.
				</explanation>
			</content>
		</collapsedSubSection>
		<collapsedSubSection anchor="requirements">
			<head>Requirements</head>
			<summary>What do you need for JDBC?</summary>
			<content>
				<explanation><em>Java ships with JDBC</em> 3.0 since J2SE 1.4, and with JDBC 4.0 since Java SE 6.0, so you will always have a JDBC implementation.
				Beside that, you only need a database. <em>Java SE 6.0 includes Java DB</em> which is fine for embedded use.   
				</explanation>
			</content>
		</collapsedSubSection>
	</singleColumnSection>

	<singleColumnSection anchor="connecting">
		<head>Connecting</head>
		<subSection anchor="standalone">
			<head>Stand-Alone</head>
			<more>In a stand-alone application, the easiest way to connect to get a connection is using the <idf>DriverManager</idf>
			class. Unless you have a JDBC 4.0 implementation with JDBC 4.0 driver, you need to initialize the driver by loading its class.
			Then you can acquire a connection from the <idf>DriverManager</idf>, using the driver's own JDBC URL scheme.<br/>
			In order to use a driver, you need to know the name of its class (in pre-4.0 systems) and learn how to write a JDBC URL for it.
			In the later section, this is shown for several common drivers and databases.</more>
			<code>
				<line><plainCmt>Connecting in a stand-alone application (not for EJBs or web applications)</plainCmt></line>
				<emptyLine/>
				<line>Class.forName("org.apache.derby.jdbc.EmbeddedDriver"); <cmt><warn>driver-specific</warn>, for JDBC &lt;= 3.0 <more>
This line loads the driver's class so it can register itself. It is <em>not needed for JDBC 4.0 drivers</em> anymore.<br/>
The name of the class to load is different for every driver, so you need to find it in the driver's documentation.</more></cmt></line>
				<emptyLine/>
				<line>String url = "jdbc:derby:JarfillerDB;create=true"; <cmt><warn>driver-specific</warn> <more>Every driver has its own
URL schema for describing connections. Here, the schema for JavaDB (also known as 'Derby') is being shown. The schema always starts with
"jdbc:", followed by the name of the driver and another colon. The follow driver-specific data, such as the DB name and possibly
the server address.</more></cmt></line>
				<line><javadoc>Connection</javadoc> connection = <javadoc>DriverManager</javadoc>.<javadoc to="java/sql/DriverManager.html#getConnection(java.lang.String)"><em>getConnection</em></javadoc>(url);</line>
				<line>try {</line>
				<line>    <plainCmt>use connection ...</plainCmt></line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc><em>close</em></javadoc>();</line>
				<line>}</line>
			</code>
		</subSection>
		
		<subSection anchor="jeecontainer">
			<head>JEE Container</head>
			<more>When writing an EJB, a Servlet or any other managed bean in a JEE container, you should <em>let the container manage
			your database connection</em>. The container takes care of connection pooling (for performance) and usually also helps you
			with enterprisy-features like distributed transactions. Since JEE 5 it is usually enough to add a <idf>@Resource</idf>
			annotation to a member of an EJB or Servlet, and then make sure that the containers is properly configured.
			</more>

			<code>
				<line><plainCmt>In EJBs and servlets, <em>use the <javadoc>DataSource</javadoc></em> provided by the container!</plainCmt></line>
				<line>package com.jarfiller.example;</line>
				<emptyLine/>
				<line>import <javadoc>javax.sql.*</javadoc>;</line>
				<line>import <javadoc>java.sql.*</javadoc>;</line>
				<line>import <javadoc>javax.servlet.http.*</javadoc>;</line>
				<line>import <javadoc>javax.annotation.*</javadoc>;</line>
				<emptyLine/>
				<line>public class DBServlet extends <javadoc>HttpServlet</javadoc> {</line>
				<emptyLine/>
				<line>    <em><javadoc>@Resource</javadoc>(name="jdbc/db")</em></line>
				<line>    private <javadoc><em>DataSource</em></javadoc> db;<cmt>inject database connection <more><idf>@Resource</idf> tells the container that the
servlet <em>requires a JDBC <idf>DataSource</idf> with the JNDI name 'jdbc/db'</em>. The deployer is responsible for configuring the
container to provide it. The container will <em>inject the value</em> into the field after instantiation.</more></cmt></line>
				<emptyLine/>
				<line>    protected void <javadoc>doGet</javadoc>(<javadoc>HttpServletRequest</javadoc> request, <javadoc>HttpServletResponse</javadoc> response) {</line>
				<line>        try {</line>
				<line>            <javadoc>Connection</javadoc> connection = <em>db.<javadoc>getConnection</javadoc>()</em>;<cmt>use injected <idf>DataSource</idf></cmt></line>
				<emptyLine/>
				<line>            <plainCmt><abstract>do something with the connection ...</abstract></plainCmt></line>
				<emptyLine/>
				<line>        }</line>
				<line>        catch (<javadoc>SQLException</javadoc> e) {</line>
				<line>            throw new <javadoc>RuntimeException</javadoc>(e); <cmt>simple error handling <more id="more-servletexception">The easiest way
				to handle an unexpected problem is to throw a <idf>ServletException</idf>. The server will return an error
				page with HTTP status code 500 (internal error).</more></cmt></line>
				<line>        }</line>
				<line>        finally {</line>
				<line>            con.<javadoc><em>close</em></javadoc>();<cmt>close when done</cmt></line>
				<line>        }</line>
				<line>    }</line>
				<line>}</line>
			</code>
		</subSection>
		
		<collapsedSubSection anchor="javadb">
			<head>Java DB</head>
			<summary>Connecting to Java DB</summary>
			<content>
				<explanation>Java DB is a version of Apache Derby that ships with Java SE since version 6. It can be either used
				as <annotated ref="docs-embedded-db"/> running inside your application, or as stand-alone <annotated ref="docs-server-db"/>
				which can be accessed by several clients simultanously.</explanation>
				<miniHeadline>Embedded Driver</miniHeadline>
				<explanation>
					To use Java DB in embedded mode, you only need to <em>add derby.jar to your classpath</em>. When you installed
					Java DB with Java SE, you can find it in a separate directory (default on Windows would be "C:\Program Files\Sun\JavaDB").
					The class name of the driver is <idf>org.apache.derby.jdbc.EmbeddedDriver</idf>:
				</explanation>
				<code>
					<line>Class.forName("<em>org.apache.derby.jdbc.EmbeddedDriver</em>");<cmt>optional for JDBC 4.0</cmt></line>
					<emptyLine/>
					<line>String url = "<em>jdbc:derby:c:\\tmp\\JarfillerDB;create=true</em>";</line>
					<line><javadoc>Connection</javadoc> connection = <javadoc>DriverManager</javadoc>.<javadoc to="java/sql/DriverManager.html#getConnection(java.lang.String)">getConnection</javadoc>(url);</line>
				</code>
				<explanation>
					This is the format of the JDBC URL for embedded use:</explanation>
				<svgImage alt="Derby URL Schema (Embedded)" fileBase="jdbc-derby-url" height="124" width="564"/>
				
				<miniHeadline>Connecting to a Java DB Server (Client Driver)</miniHeadline>
				<explanation>
					The client driver allows you to connect to a Java DB server <more>To start your database in
					server mode, just go to the <idf>bin</idf> directory of your Java DB installations and start <idf>startNetworkServer</idf>.</more>.
					Just add <em>add derby.jar to your classpath</em> and use <idf>org.apache.derby.jdbc.ClientDriver</idf>
					as driver class:
				</explanation>
				<code>
					<line>Class.forName("<em>org.apache.derby.jdbc.ClientDriver</em>");<cmt>optional for JDBC 4.0</cmt></line>
					<emptyLine/>
					<line>String url = "<em>jdbc:derby://localhost:1527/JarFillerDB2;create=true</em>";</line>
					<line><javadoc>Connection</javadoc> connection = <javadoc>DriverManager</javadoc>.<javadoc to="java/sql/DriverManager.html#getConnection(java.lang.String)">getConnection</javadoc>(url, "<abstract>user</abstract>", "<abstract>password</abstract>");</line>
				</code>
				<explanation>
					This is the format of the JDBC URL for clients:</explanation>
				<svgImage alt="Derby URL Schema (Client)" fileBase="jdbc-derby-client-url" height="124" width="564"/>
				
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="postgresql">
			<head>PostgreSQL</head>
			<summary>Connecting to PostgreSQL</summary>
			<content>
				<explanation><link to="http://www.postgresql.org/">PostgreSQL</link> is one of the oldest open-source database servers. You can find the JDBC driver and documentation
				as <link to="http://jdbc.postgresql.org/">jdbc.postgresql.org</link>.</explanation>
				<explanation>
					The JDBC driver is available in versions for JDBC 3.0 (for Java 5) and JDBC (for Java 6). Just put the appropriate JAR into your
					classpath.  
					The class name of the driver is <idf>org.postgresql.Driver</idf>:
				</explanation>
				<code>
					<line>Class.forName("<em>org.postgresql.Driver</em>");<cmt>optional for JDBC 4.0</cmt></line>
					<emptyLine/>
					<line>String url = "<em>jdbc:postgresql://localhost/JarFillerDB</em>";</line>
					<line><javadoc>Connection</javadoc> connection = <javadoc>DriverManager</javadoc>.<javadoc to="java/sql/DriverManager.html#getConnection(java.lang.String)">getConnection</javadoc>(url);</line>
				</code>
				<explanation>
					This is the format of PostgreSQL's JDBC URL:</explanation>
					<svgImage alt="PostgreSQL URL Schema" fileBase="jdbc-postgresql-url" height="124" width="564"/>
				
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="oracle">
			<head>Oracle</head>
			<summary>Connecting to Oracle Database</summary>
			<content>
				<explanation><link to="http://www.oracle.com">Oracle Database</link> is the most important proprietary database.
				Three JDBC drivers are available:</explanation>
				<list>
				<li>The <em>Thin driver is a pure Java JDBC driver</em>. It is the driver shown here.</li>
				<li>The <em>OCI driver requires a SQL*Net installation</em> on the machine and uses native code for access.</li>
				<li>KPRB is only used for writing stored procedures and similar database extensions in Java</li>
				</list>
				<explanation>You can <em>download the JDBC driver on <link to="http://www.oracle.com">oracle.com</link></em>. Currently there are two
				major versions, <idf>ojdbc5.jar</idf> for JDBC 3.0 / Java 5, and <idf>ojdbc6.jar</idf> for JDBC 4.0 / Java 6. Put the
				appropriate version in to your class path. The class name of the driver is <idf>oracle.jdbc.OracleDriver</idf>:
				</explanation>
				<code>
					<line>Class.forName("<em>oracle.jdbc.OracleDriver</em>");<cmt>optional for JDBC 4.0</cmt></line>
					<emptyLine/>
					<line>String url = "<em>jdbc:oracle:thin:@localhost:XE</em>";</line>
					<line><javadoc>Connection</javadoc> connection = <javadoc>DriverManager</javadoc>.<javadoc to="java/sql/DriverManager.html#getConnection(java.lang.String)">getConnection</javadoc>(url);</line>
				</code>
				<explanation>This is the format of Oracle's JDBC URL:</explanation>
				<svgImage alt="Oracle URL Schema" fileBase="jdbc-oracle-url" height="124" width="564"/>
				
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="exampleschema">
			<head>Example Schema</head>
			<summary>Database Schema for the Following Examples</summary>
			<content>
				<explanation>The following <em>examples are based on this database schema</em> (in Java DB syntax):
				</explanation>
				<config>CREATE TABLE Movie (
  id          INT <annotated><title>GENERATED BY DEFAULT AS IDENTITY</title><explanation>This definition means
that the database will generate a unique value for <idf>id</idf> automatically, if no value was given.</explanation></annotated>,
  title       VARCHAR (255),
  budget   DECIMAL,
  releaseDate DATE,
  PRIMARY KEY(id)
)
</config>
				<explanation>Unless noted, examples in this document have been written and tested for Java DB, but should work in pratically any
				other SQL database. Some advanced examples have been written for PostgreSQL, because it is the only wide-spread open-source
				database that supports all JDBC features.</explanation>
			</content>
		</collapsedSubSection>


		
	</singleColumnSection>
	
	<singleColumnSection anchor="updatesandqueries">
		<head>Updates and Queries</head>
		
		<subSection anchor="update">
			<head>Update</head>
			<more>To execute a statement, you need to <em>get a statement first</em>. Then you can use
			this statement to execute your SQL command.<br/> 
			Use <idf>executeUpdate</idf>, as shown here, when you plan to execute statements that return a number as only result,
			such as an <idf>UPDATE</idf> statement.</more>
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    String sql = "UPDATE Movie SET budget=9000000 WHERE title='Jaws'";</line>
				<line>    <javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc><em>prepareStatement</em></javadoc>(sql);</line>
				<line>    int changeCount = stmt.<javadoc><em>executeUpdate</em></javadoc>();</line>
				<line>    System.out.println(changeCount + " records modified.");</line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
			</code>
		</subSection>
		
		<subSection anchor="query">
			<head>Query</head>
			<more>When you execute an SQL command such as <idf>SELECT</idf>, which returns tabular data, you need to execute it
			with <idf>executeQuery</idf>. It returns a <idf>ResultSet</idf> instance that allows you to iterate through the results.</more>
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    String sql = "SELECT id, title, releaseDate, budget FROM Movie";</line>
				<line>    <javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<line>    <javadoc><em>ResultSet</em></javadoc> rs = stmt.<javadoc><em>executeQuery</em></javadoc>();</line>
				<emptyLine/>
				<line>    while (rs.<javadoc><em>next</em></javadoc>()) {<cmt>iterate through results</cmt></line>
				<line>        int id = rs.<javadoc><em>getInt</em></javadoc>("id");<cmt>get row value <em>by name</em></cmt></line>
				<line>        String title = rs.<javadoc><em>getString</em></javadoc>("title");</line>
				<line>        <javadoc>Date</javadoc> date = rs.<javadoc><em>getDate</em></javadoc>("releaseDate");<cmt><em>returns <idf>java.sql.Date</idf></em>, not <idf>java.util.Date</idf></cmt></line>
				<line>        <javadoc>BigDecimal</javadoc> budget = rs.<javadoc ><em>getBigDecimal</em></javadoc>("budget");</line>
				<emptyLine/>
				<line>        System.out.printf("id=%d title=%s date=%s budget=%s\n", id, title, date, budget);</line>
				<line>    }</line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
			</code>
		</subSection>
		
		<subSection anchor="valueconversion">
			<head>Value Conversion</head>
			<more>Where possible, JDBC will automatically convert values from the result set into any type of value you want.
			You can read almost any value type into a string. Other types can also be converted if there is a useful conversion.</more>
			<code>

				<line><javadoc>ResultSet</javadoc> rs = <abstract>...</abstract> ;</line>
				<line>while (rs.<javadoc><em>next</em></javadoc>()) {<cmt>iterate through results</cmt></line>
				<line>        long id = rs.<javadoc><em>getLong</em></javadoc>("id");<cmt><em>automatic conversion</em> (<idf>id</idf> is <idf>INT</idf>)</cmt></line>
				<line>        String title = rs.<javadoc>getString</javadoc>("title");</line>
				<line>        String date = rs.<javadoc><em>getString</em></javadoc>("releaseDate");<cmt><em>automatic conversion</em> (<idf>releaseDate</idf> is <idf>DATE</idf>)</cmt></line>
				<line>        String budget = rs.<javadoc><em>getString</em></javadoc>("budget");</line>
				<emptyLine/>
				<line>        System.out.printf("id=%d title=%s date=%s budget=%s\n", id, title, date, budget);</line>
				<line>}</line>
			</code>
		</subSection>
		
		<subSection anchor="colindex">
			<head>Column Index</head>
			<more>Instead of refering to columns in the <idf>ResultSet</idf> with names, you can also use numbers. 1 is the first column.
			Sometimes this can be more convenient, but it becomes unreadable pretty quickly with larger result sets.</more>
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    String sql = "SELECT id, title, releaseDate, budget FROM Movie";</line>
				<line>    <javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<line>    <javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
				<emptyLine/>
				<line>    while (rs.<javadoc>next</javadoc>()) {<cmt>iterate through results</cmt></line>
				<line>        int id = rs.<javadoc to="java/sql/ResultSet.html#getInt(int)">getInt</javadoc>(<em>1</em>);<cmt>get value <em>by index</em></cmt></line>
				<line>        String title = rs.<javadoc to="java/sql/ResultSet.html#getString(int)">getString</javadoc>(<em>2</em>);</line>
				<line>        <javadoc>Date</javadoc> date = rs.<javadoc to="java/sql/ResultSet.html#getDate(int)">getDate</javadoc>(<em>3</em>);</line>
				<line>        <javadoc>BigDecimal</javadoc> budget = rs.<javadoc to="java/sql/ResultSet.html#getBigDecimal(int)"><em>getBigDecimal</em></javadoc>(4);</line>
				<emptyLine/>
				<line>        System.out.printf("id=%d title=%s date=%s budget=%s\n", id, title, date, budget);</line>
				<line>    }</line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
			</code>
		</subSection>
	</singleColumnSection>
	
	<singleColumnSection anchor="parameters">
		<head>Parameters</head>
		
		<subSection anchor="parameters1">
			<head>Parameters</head>
			<more>Parameters allow you to use '?' as placeholders in a SQL, and set them using <idf>PreparedStatement</idf>'s
			methods before execution. The main reason for this is that parameters are easier and safer than dynamically constructing 
			SQL statements in any way. It also allows the database to cache its execution plan for the statement.</more>
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    String sql = "SELECT title, releaseDate, budget FROM Movie"+</line>
				<line>         " WHERE title LIKE <em>?</em> AND budget >= <em>?</em>";<cmt><idf>?</idf> is <em>parameter placeholder</em></cmt></line>
				<line>    <javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<emptyLine/>
				<line>    stmt.<em><javadoc>setString</javadoc>(1, "Jaws%")</em>; <cmt>set parameters</cmt></line>
				<line>    stmt.<em><javadoc>setBigDecimal</javadoc>(2, new <javadoc>BigDecimal</javadoc>(10000000))</em>;<cmt><idf>BigDecimal</idf> for currency <more>Using <idf>BigDecimal</idf>
				for currency is a good idea, because unlike the floating point types does not have any rounding errors.</more></cmt></line>
				<emptyLine/>
				<line>    <javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
				<emptyLine/>
				<line>    while (rs.<javadoc>next</javadoc>()) {<cmt>iterate through results</cmt></line>
				<line>        String title = rs.<javadoc>getString</javadoc>("title");</line>
				<line>        <javadoc>BigDecimal</javadoc> title = rs.<javadoc>getBigDecimal</javadoc>("budget");</line>
				<line>        <javadoc>Date</javadoc> date = rs.<javadoc>getDate</javadoc>("releaseDate");</line>
				<emptyLine/>
				<line>        System.out.printf("title=%s date=%s budget=%s\n", title, date, budget);</line>
				<line>    }</line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
			</code>
		</subSection>
		
		<subSection anchor="reusing">
			<head>Reusing Statements</head>
			<more>You can reuse any statement that you created and execute it several times. This is especially useful 
			for <idf>PreparedStatement</idf>'s with parameters, because <idf>PreparedStatement</idf> remembers any previously 
			set parameters. It also may help the database to execute your statements, because it needs to compile and analyze
			it only once.</more>
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    String sql = "INSERT INTO Movie (title, budget, releaseDate) VALUES(<em>?, ?, ?</em>)";</line>
				<line>    <javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<emptyLine/>
				<line>    <plainCmt>Insert movies released on July 13 1984:</plainCmt></line>
				<line>    <javadoc>Date</javadoc> july13 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1984, <javadoc>Calendar.JULY</javadoc>, 13).<javadoc>getTimeInMillis</javadoc>());</line>
				<line>    stmt.<em><javadoc>setDate</javadoc>(3, july13)</em>;<cmt><em>re-used parameter</em> <more>You can execute
				a statement more than once. If you don't modify a parameter after an execution, the value is used
				for the next execution as well. In this example, the third parameter is being re-used for two executions.</more></cmt></line>
				<emptyLine/>
				<line>    <plainCmt>Execute statement once per movie</plainCmt></line>
				<line>    stmt.<javadoc>setString</javadoc>(1, "The Last Starfighter");</line>
				<line>    stmt.<javadoc>setBigDecimal</javadoc>(2, new <javadoc>BigDecimal</javadoc>(15000000));</line>
				<line>    stmt.<javadoc><em>executeUpdate</em></javadoc>();</line>
				<emptyLine/>
				<line>    stmt.<javadoc>setString</javadoc>(1, "The Muppets Take Manhattan");</line>
				<line>    stmt.<javadoc>setBigDecimal</javadoc>(2, new <javadoc>BigDecimal</javadoc>(8000000));</line>
				<line>    stmt.<javadoc><em>executeUpdate</em></javadoc>();</line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
			</code>
		</subSection>
		
	</singleColumnSection>

	<singleColumnSection anchor="workstatements">
		<head>Working with Statements</head>
		
		<subSection anchor="transactions">
			<head>Transactions</head>
			<more>To use transactions you need to turn off the <idf>Connection</idf>'s auto-commit mode with
			<idf>setAutoCommit</idf>. Then every statement you issue is part of the same transaction, until you call
			<idf>commit</idf> or <idf>rollback</idf>, which start a new transaction.<br/>
			This built-in transaction mechanism can only be used for transactions within the database. Distributed
			transactions, over several databases, require an external transaction manager.</more>
			<explanation>Connections are in <em><annotated><title>auto-commit</title>
			<explanation>Auto-commit means that every statement is automatically committed right after executing it.
			In order to have transactions with JDBC in a stand-alone application, you need to disable the auto-commit mode 
			and then invoke <idf>commit</idf> or <idf>rollback</idf> expliticly. In an application server,
			you should let the container manage transactions.</explanation></annotated>
			mode by default</em>. You can automatically <em>begin a <annotated><title>transaction</title><explanation>When you execute
			a writing statement (such as an <idf>UPDATE</idf> or <idf>INSERT</idf>) in a transaction, the database will not be permanently modified
			yet. <em>Only after calling <idf>commit</idf></em> the changes will be visible to other transactions. Alternatively you
			can also call <idf>rollback</idf> and all changes will be forgotten.<br/>
			Transactions are important, for example, when you have a table representing bank accounts, and you transfer money from
			one account to another. You need to deduct the amount from the first account and add it to the second. This can only 
			be done using two <idf>UPDATE</idf> statements. But it must never happen that only the first statement
			succeeds and then the second fails - otherwise the money would just disappear. So you put it in a transaction, and then it
			is guaranteed that either both statements are executed, or none at all.</explanation></annotated>
			by turning it off</em> (there is no explicit <idf>begin</idf> method). The transaction runs until you call 
			<javadoc>commit</javadoc> or <javadoc>rollback</javadoc>, which will end the current transaction and start a new one.</explanation>
			
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    connection.<em><javadoc>setAutoCommit</javadoc>(false)</em>;<cmt><em>begin transaction</em></cmt></line>
				<emptyLine/>
				<line>    String sql = "UPDATE Movie SET title=? WHERE title=?";</line>
				<line>    <javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<emptyLine/>
				<line>    stmt.<javadoc>setString</javadoc>(1, "Jaws 3-D");</line>
				<line>    stmt.<javadoc>setString</javadoc>(2, "Jaws 3");</line>
				<line>    stmt.<javadoc>executeUpdate</javadoc>();</line>
				<emptyLine/>
				<line>    stmt.<javadoc>setString</javadoc>(1, "Amityville 3-D");</line>
				<line>    stmt.<javadoc>setString</javadoc>(2, "Amityville 3");</line>
				<line>    stmt.<javadoc>executeUpdate</javadoc>();</line>
				<emptyLine/>
				<line>    connection.<javadoc><em>commit</em></javadoc>();</line>
				<line>}</line>
				<line>catch (RuntimeException e) {</line>
				<line>    connection.<javadoc><em>rollback</em></javadoc>();<cmt>rollback on unhandled error</cmt></line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
			</code>
			<explanation>Note that code running in an application server should <em>let the server manage transactions</em> (<link anchor="appservertransactions">see below</link>).</explanation>
		</subSection>
		
		<subSection anchor="closing"> 
			<head>Closing Resources</head>
			<more>
			Database resources are expensive and limited. You can improve performance by closing resources manuallly, instead of waiting
			for the garbage collection.<br/>
			Closing a resource closes all constituent objects. So if you close a <idf>Statement</idf>, its <idf>ResultSet</idf>s
			will be closed automatically. And if you close a <idf>Connection</idf>, its <idf>Statement</idf>s and 
			<idf>ResultSet</idf>s will be closed.</more>
			<explanation>
				When you close a <javadoc>Collection</javadoc>, all dependent resources will be freed as well. Often this is sufficient, but
				in a <em>long running connection</em>, save resources by <em>closing <idf>Statement</idf>s and
				<idf>ResultSet</idf>s explicitly</em>.
			</explanation>
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    String sql = "SELECT * FROM Movie";</line>
				<line>    <javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<emptyLine/>
				<line>    <javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
				<line>    while (rs.<javadoc>next</javadoc>()) {</line>
				<line>        <plainCmt>...</plainCmt></line>
				<line>    }</line>
				<line>    rs.<javadoc to="java/sql/ResultSet.html#close()"><em>close</em></javadoc>();<cmt><idf>rs</idf> not needed anymore</cmt></line>
				<emptyLine/>
				<line>    <javadoc>ResultSet</javadoc> rs2 = stmt.<javadoc>executeQuery</javadoc>();</line>
				<line>    while (rs2.<javadoc>next</javadoc>()) {</line>
				<line>        <plainCmt>...</plainCmt></line>
				<line>    }</line>
				<line>    stmt.<javadoc to="java/sql/Statement.html#close()"><em>close</em></javadoc>();<cmt>also closes <idf>rs2</idf> <more>When you close a statement,
				its current <idf>ResultSet</idf> will be closed as well.</more></cmt></line>
				<emptyLine/>
				<line>    connection.<javadoc>prepareStatement</javadoc>("DELETE FROM Movie WHERE budget &lt; 1000000").<javadoc>executeUpdate</javadoc>();</line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();<cmt>also closes its <idf>Statement</idf>s</cmt></line>
				<line>}</line>
			</code>
		</subSection>
	</singleColumnSection>
	
	<singleColumnSection anchor="plainstatements">
		<head>Plain Statements</head>
		
		<subSection anchor="plainstatements1">
			<head>Plain Statement</head>
			<explanation>The plain <javadoc>Statement</javadoc> is similar to <javadoc>PreparedStatement</javadoc>, but 
			does <em>not support parameters</em> and is often slower <more><idf>PreparedStatement</idf> is often faster because
			prepared statements make it easier for the database to re-use the results of the statement's compilation. 
			When you execute a <idf>PreparedStatement</idf> once, there may be some initialization penalty in some databases though. 
			So if your statements do not need parameters and you only execute each SQL command once, then <idf>Statement</idf> 
			can (but does not have to be) faster.</more>. Even though it is quite common in JDBC code, <em>there is little reason
			to use <javadoc>Statement</javadoc></em> instead of <javadoc>PreparedStatement</javadoc>.</explanation>
			<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    String sql = "UPDATE Movie SET title='Jaws 3-D' WHERE title='Jaws 3'";</line>
				<line>    <javadoc><em>Statement</em></javadoc> stmt = connection.<javadoc><em>createStatement</em></javadoc>();</line>
				<line>    stmt.<em><javadoc>executeUpdate</javadoc>(sql)</em>;</line>
				<emptyLine/>
				<line>    String sql2 = "SELECT title, budget, releaseDate FROM Movie";</line>
				<line>    <javadoc>ResultSet</javadoc> rs = stmt.<em><javadoc>executeQuery</javadoc>(sql2)</em>;</line>
				<emptyLine/>
				<line>    while (rs.<javadoc>next</javadoc>()) {</line>
				<line>        String title = rs.<javadoc>getString</javadoc>("title");</line>
				<line>        <javadoc>BigDecimal</javadoc> title = rs.<javadoc>getBigDecimal</javadoc>("budget");</line>
				<line>        <javadoc>Date</javadoc> date = rs.<javadoc>getDate</javadoc>("releaseDate");</line>
				<emptyLine/>
				<line>        System.out.printf("title=%s date=%s budget=%s\n", title, date, budget);</line>
				<line>    }</line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
			</code>
		</subSection>
		
	</singleColumnSection>
	
	<singleColumnSection anchor="escape">
		<head>SQL Escape Syntax</head>
		<subSection anchor="escapesyntax">
			<head>Escape Syntax</head>
			<explanation>JDBC offers a <em>escape syntax for database-independent SQL</em>. SQL statements can
			contain special <em>macros in curly braces ("{}")</em> that will be replaced by the JDBC driver with
			database-specific SQL constructs.</explanation>
		</subSection>
		
		<subSection anchor="dateliterals">
			<head>Date Literals</head>
			<more>Date literals offer a database-independent way of specifying a date, time or timestamp. Without them you'd need
			to know each database's syntax (which often depends on the database's locale).</more>
			<table>
				<head><cell>Syntax</cell><cell>Example</cell><cell>Description</cell></head>
				<row><cell>{d 'yyyy-mm-dd'}</cell><cell>{d '2010-06-30'}</cell><cell>Date</cell></row>
				<row><cell>{t 'hh:mm:ss'}</cell><cell>{t '17:30:00')</cell><cell>Time</cell></row>
				<row><cell>{ts 'yyyy-mm-dd hh:mm:ss'}</cell><cell>{ts '2000-12-24 18:00:00'}</cell><cell>Timestamp (second precision)</cell></row>
				<row><cell>{ts 'yyyy-mm-dd hh:mm:ss.fff'}</cell><cell>{ts '2006-10-06 09:34:15.51712'}</cell><cell>Timestamp (with fractional second)</cell></row>
			</table>
			<explanation>Example:</explanation>
			<code>
				<line>String sql = "SELECT title FROM Movie WHERE releaseDate > <em>{d '1980-01-01'}</em>";</line>
				<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
			</code>
			<explanation></explanation>
		</subSection>
		
		<subSection anchor="escapefunctions">
			<head>Functions</head>
			<more>JDBC's escape syntax allows you to invoke many common functions in a database-independent way. The driver will
			translate them into a function that the underlying database supports. Note that a JDBC driver is not required
			to support a function if the database does not provide a native equivalent.</more>
			<table>
				<head><cell>Syntax</cell><cell>Example</cell><cell>Description</cell></head>
				<row><cell>{fn <abstract>function-name</abstract>(<abstract>argument-list</abstract>)}</cell><cell>{fn CONCAT('a', 'b')]</cell><cell>Call function (<em>see list of supported functions below</em>)</cell></row>
			</table>
			<explanation>Example:</explanation>
			<code>
				<line>String sql = "SELECT <em>{fn UCASE(title)}</em> as title FROM Movie WHERE <em>{fn YEAR(releaseDate)}</em>=1984";</line>
				<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
			</code>
			<explanation></explanation>
		</subSection>

		<collapsedSubSection anchor="escapefunctionlist">
			<summary>List of Supported Functions</summary>
			<content>
				<miniHeadline>Strings</miniHeadline>
				<table>
					<head><cell>Function</cell><cell>Description</cell></head>
					<row><cell>ASCII(string)</cell><cell>ASCII number of first character</cell></row>
					<row><cell>CHAR(integer)</cell><cell>Character with given ASCII number (0-255)</cell></row>
					<row><cell>CHAR_LENGTH(number)</cell><cell>String length (including trailing spaces, <em>since JDBC 4.0</em>)</cell></row>
					<row><cell>CHARACTER_LENGTH(number)</cell><cell>String length (including trailing spaces, <em>since JDBC 4.0</em>)</cell></row>
					<row><cell>CONCAT(string, string)</cell><cell>Returns concatonated strings (null handling undefined)</cell></row>
					<row><cell>DIFFERENCE(string, string)</cell><cell><link to="http://en.wikipedia.org/wiki/Soundex">Soundex</link> difference</cell></row>
					<row><cell>INSERT(string1, start, len, string2)</cell><cell>Replace <idf>len</idf> characters from <idf>string1</idf> at position <idf>start</idf> (1-based) with <idf>string</idf></cell></row>
					<row><cell>LCASE(string)</cell><cell>Convert to lower case</cell></row>
					<row><cell>LEFT(string, integer)</cell><cell>Return <idf>integer</idf> leftmost characters</cell></row>
					<row><cell>LENGTH(string)</cell><cell>String length (without trailing spaces)</cell></row>
					<row><cell>LOCATE(string1, string2)</cell><cell>Finds first occurrence of <idf>string1</idf> in <idf>string1</idf>, returns position (1-based) or 0 if not found</cell></row>
					<row><cell>LOCATE(string1, string2, start)</cell><cell>Finds first occurrence of <idf>string1</idf> in <idf>string1</idf> starting at <idf>start</idf>, returns position (1-based) or 0 if not found</cell></row>
					<row><cell>LTRIM(string)</cell><cell>Return <idf>string</idf> without leading spaces</cell></row>
					<row><cell>OCTET_LENGTH(string)</cell><cell>String length in bytes (<em>since JDBC 4.0</em>)</cell></row>
					<row><cell>POSITION(string1 IN string2)</cell><cell>Position of first occurrence of <idf>string1</idf> in <idf>string2</idf> (<em>since JDBC 4.0</em>, use <idf>LOCATE</idf> for 3.0 compatibility)</cell></row>
					<row><cell>REPEAT(string, integer)</cell><cell>Returns <idf>string</idf> repeated <idf>integer</idf> times</cell></row>
					<row><cell>REPLACE(string1, string2, string3)</cell><cell>Replace all occurrences of <idf>string2</idf> in <idf>string1</idf> with <idf>string3</idf></cell></row>
					<row><cell>RIGHT(string,integer)</cell><cell>Return <idf>integer</idf> rightmost characters</cell></row>
					<row><cell>RTRIM(string)</cell><cell>Return <idf>string</idf> without trailing spaces</cell></row>
					<row><cell>SOUNDEX(string)</cell><cell><link to="http://en.wikipedia.org/wiki/Soundex">Soundex</link> value (exact content undefined)</cell></row>
					<row><cell>SPACE(integer)</cell><cell>Returns <idf>integer</idf> spaces</cell></row>
					<row><cell>SUBSTRING(string, start, len)</cell><cell>Returns substring from <idf>start</idf> (1-based)</cell></row>
					<row><cell>UCASE(string)</cell><cell>Convert to upper case</cell></row>
				</table>
			
				<miniHeadline>Date and Time</miniHeadline>
				<table>
					<head><cell>Function</cell><cell>Description</cell></head>
					<row><cell>CURRENT_DATE()</cell><cell>Current date (<em>since JDBC 4.0</em>, use <idf>CURDATE</idf>() for 3.0 compatibility)</cell></row>
					<row><cell>CURRENT_TIME()</cell><cell>Current time (<em>since JDBC 4.0</em>, use <idf>CURTIME</idf>() for 3.0 compatibility)</cell></row>
					<row><cell>CURRENT_TIMESTAMP()</cell><cell>Current timestamp (<em>since JDBC 4.0</em>, use <idf>NOW</idf>() for 3.0 compatibility)</cell></row>
					<row><cell>CURDATE()</cell><cell>Current date</cell></row>
					<row><cell>CURTIME()</cell><cell>Current time</cell></row>
					<row><cell>DAYNAME(date)</cell><cell>Weekday name (exact value undefined)</cell></row>
					<row><cell>DAYOFMONTH(date)</cell><cell>Day of month (1-31)</cell></row>
					<row><cell>DAYOFWEEK(date)</cell><cell>Day of week (1-7, 1 is Sunday)</cell></row>
					<row><cell>DAYOFYEAR(date)</cell><cell>Day of year (1-366)</cell></row>
					<row><cell>EXCTRACT(field FROM timestamp)</cell><cell>Get field from time/date/timestamp. <idf>field</idf> is
					<idf>YEAR</idf>, <idf>MONTH</idf>, <idf>DAY</idf>, <idf>HOUR</idf>, <idf>MINUTE</idf> or <idf>SECOND</idf> (<em>since JDBC 4.0</em>)</cell></row>
					<row><cell>HOUR(time)</cell><cell>Hour of time (0-23)</cell></row>
					<row><cell>MINUTE(time)</cell><cell>Minute of time (0-59)</cell></row>
					<row><cell>MONTH(date)</cell><cell>Month of date (1-12)</cell></row>
					<row><cell>MONTHNAME(date)</cell><cell>Name of month (exact value undefined)</cell></row>
					<row><cell>NOW()</cell><cell>Current timestamp</cell></row>
					<row><cell>QUARTER(date)</cell><cell>Quarter of year (1-4)</cell></row>
					<row><cell>SECOND(time)</cell><cell>Second of time (0-59)</cell></row>
					<row><cell>TIMESTAMPADD(unit,integer,timestamp)</cell><cell>Add <idf>integer</idf> to <idf>timestamp</idf>. <idf>unit</idf>
					can be 
					<idf>SQL_TSI_FRAC_SECOND</idf>, <idf>SQL_TSI_SECOND</idf>, <idf>SQL_TSI_MINUTE</idf>,
					<idf>SQL_TSI_HOUR</idf>, <idf>SQL_TSI_DAY</idf>, <idf>SQL_TSI_WEEK</idf>, <idf>SQL_TSI_MONTH</idf>,
					<idf>SQL_TSI_QUARTER</idf> or <idf>SQL_TSI_YEAR</idf>.</cell></row>
					<row><cell>TIMESTAMPDIFF(unit,timestamp,timestamp)</cell><cell>Difference between first and second timestamp. <idf>unit</idf>
					can be 
					<idf>SQL_TSI_FRAC_SECOND</idf>, <idf>SQL_TSI_SECOND</idf>, <idf>SQL_TSI_MINUTE</idf>,
					<idf>SQL_TSI_HOUR</idf>, <idf>SQL_TSI_DAY</idf>, <idf>SQL_TSI_WEEK</idf>, <idf>SQL_TSI_MONTH</idf>,
					<idf>SQL_TSI_QUARTER</idf> or <idf>SQL_TSI_YEAR</idf>.</cell></row>
					<row><cell>WEEK(date)</cell><cell>Week of date (1-53, algorithm undefined)</cell></row>
					<row><cell>YEAR(date)</cell><cell>Year of date (4 digit)</cell></row>
				</table>
			
				<miniHeadline>Numbers</miniHeadline>
				<table>
					<head><cell>Function</cell><cell>Description</cell></head>
					<row><cell>ABS(number)</cell><cell>Absolute value</cell></row>
					<row><cell>ACOS(float)</cell><cell>Arc cosine of argument (radians)</cell></row>
					<row><cell>ASIN(float)</cell><cell>Arc sine of argument (radians)</cell></row>
					<row><cell>ATAN(float)</cell><cell>Arc tangent of argument (radians)</cell></row>
					<row><cell>ATAN2(f1, f2)</cell><cell>Arc tangent of <idf>f2</idf>/<idf>f1</idf> (radians)</cell></row>
					<row><cell>CEILING(number)</cell><cell>Smallest integer >= argument (rounds up)</cell></row>
					<row><cell>DEGREES(number)</cell><cell>Convert argument from radians to degrees</cell></row>
					<row><cell>FLOOR(float)</cell><cell>Largest integer &lt;= argument (rounds down)</cell></row>
					<row><cell>LOG(float)</cell><cell>Base e logarithm of argument</cell></row>
					<row><cell>LOG(float)</cell><cell>Base 10 logarithm of argument</cell></row>
					<row><cell>MOD(i1, i2)</cell><cell>Remainder of <idf>i1</idf>/<idf>i2</idf></cell></row>
					<row><cell>PI()</cell><cell>PI</cell></row>
					<row><cell>POWER(number, integer)</cell><cell><idf>number</idf>^<idf>integer</idf></cell></row>
					<row><cell>RADIANS(number)</cell><cell>Convert argument from degrees to radians</cell></row>
					<row><cell>RAND(integer)</cell><cell>Random floating point, argument is seed </cell></row>
					<row><cell>ROUND(number, integer)</cell><cell>Round number, 2nd argument specified places</cell></row>
					<row><cell>SIGN(number)</cell><cell>-1 for negative, 1 for positive, 0 for 0 argument</cell></row>
					<row><cell>SIN(float)</cell><cell>Sine of argument (radians)</cell></row>
					<row><cell>TAN(float)</cell><cell>Tangent of argument (radians)</cell></row>
					<row><cell>TRUNCATE(number, integer)</cell><cell>Truncate number, 2nd argument specified places</cell></row>
				</table>
				
				<miniHeadline>Other Functions</miniHeadline>
				<table>
					<head><cell>Function</cell><cell>Description</cell></head>
					<row><cell>CONVERT(value, type)</cell><cell>Convert value. Type can be 
					<idf>SQL_BIGINT</idf>, <idf>SQL_BINARY</idf>, <idf>SQL_BIT</idf>, <idf>SQL_BLOB</idf>, <idf>SQL_BOOLEAN</idf>,
					<idf>SQL_CHAR</idf>, <idf>SQL_CLOB</idf>, <idf>SQL_DATE</idf>, <idf>SQL_DECIMAL</idf>, <idf>SQL_DATALINK</idf>,
					<idf>SQL_DOUBLE</idf>, <idf>SQL_FLOAT</idf>, <idf>SQL_INTEGER</idf>, <idf>SQL_LONGVARBINARY</idf>,
					<idf>SQL_LONGNVARCHAR</idf>, <idf>SQL_LONGVARCHAR</idf>, <idf>SQL_NCHAR</idf>,
					<idf>SQL_NCLOB</idf>, <idf>SQL_NUMERIC</idf>, <idf>SQL_NVARCHAR</idf>, <idf>SQL_REAL</idf>,
					<idf>SQL_ROWID</idf>, <idf>SQL_SQLXML</idf>, <idf>SQL_SMALLINT</idf>, <idf>SQL_TIME</idf>,
					<idf>SQL_TIMESTAMP</idf>, <idf>SQL_TINYINT</idf>, <idf>SQL_VARBINARY</idf> or <idf>SQL_VARCHAR</idf>.
					</cell></row>
					<row><cell>DATABASE()</cell><cell>Name of the current database</cell></row>
					<row><cell>IFNULL(expression, value)</cell><cell>If <idf>expression</idf> is <idf>NULL</idf>, returns <idf>value</idf>,
					otherwise <idf>expression</idf></cell></row>
					<row><cell>USER()</cell><cell>Name of the current database user</cell></row>
				</table>
			</content>
		</collapsedSubSection>
		
		<subSection anchor="storedproceduresescape">
			<head>Stored Procedures</head>
			<more>This escape gives you a database-independent way of calling stored procedures. Two syntaxes allow you to call
			them either with or without expected return value.</more>
			
			<table>
				<head><cell>Syntax</cell><cell>Example</cell><cell>Description</cell></head>
				<row><cell>{call <abstract>procedure-name</abstract>}</cell><cell>{call preProcessing}</cell><cell>Call stored procedure</cell></row>
				<row><cell>{call <abstract>procedure-name</abstract>(<abstract>argument-list</abstract>)}</cell><cell>{call postProcessing(2, 'abc')}</cell><cell>...with arguments</cell></row>
				<row><cell>{?= call <abstract>procedure-name</abstract>}</cell><cell>{?= call recalc}</cell><cell>...with result parameter</cell></row>
				<row><cell>{?= call <abstract>procedure-name</abstract>(<abstract>argument-list</abstract>)}</cell><cell>{?=call compute(?, ?)}</cell><cell>...with arguments and result</cell></row>
			</table>
			<explanation>Arguments can be <em>literals or parameter markers ('?')</em>: 
			</explanation>
			<code>
				<line>String call = "<em>{call convert('USD', ?)}</em>";</line>
				<line><javadoc>CallableStatement</javadoc> stmt = connection.<javadoc>prepareCall</javadoc>(call);</line>
				<line>stmt.<javadoc>setString</javadoc>(1, "EUR");</line>
				<line>stmt.<javadoc>execute</javadoc>();</line>
			</code>
			<explanation>Stored procedures are discussed <link anchor="storedprocedures">in detail below</link>.</explanation>
		</subSection>
		
		<subSection anchor="likeescape">
			<head>LIKE Escape</head>
			<more>While all databases support the wildcard characters '%' and '_' in <idf>LIKE</idf> clauses, there is no common way 
				to escape them. JDBC allows you to specify an escape character at the end of the <idf>LIKE</idf> clause.</more>
			<table>
				<head><cell>Syntax</cell><cell>Example</cell><cell>Description</cell></head>
				<row><cell>{escape '<abstract>character</abstract>'}</cell><cell>{escape '\\'}</cell><cell>LIKE escape character</cell></row>
			</table>
			<explanation>The escape character must be declared at the end of the <idf>LIKE</idf> clause: 
			</explanation>
			<code>
				<line><plainCmt>Find titles ending with '%'</plainCmt></line>
				<line>String sql = "SELECT title FROM Movie WHERE title LIKE <em>'$%%' {escape '$'}</em>";</line>
				<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
			</code>
			<explanation></explanation>
		</subSection>
		
		<subSection anchor="outerjoinsescape">
			<head>Outer Joins</head>
			<more>For databases that support outer joins, the escape syntax gives you a database-independent way of
			specifying it.</more>
			
			<table>
				<head><cell>Syntax</cell><cell>Example</cell><cell>Description</cell></head>
				<row><cell>{oj <abstract>leftTable</abstract> OUTER JOIN <abstract>rightTable</abstract> ON <abstract>condition</abstract>}</cell><cell>SELECT * FROM {oj table1 OUTER JOIN table2 ON table1.id=table2.ref</cell><cell>Left outer join</cell></row>
				<row><cell>{oj <abstract>leftTable</abstract> LEFT OUTER JOIN <abstract>rightTable</abstract> ON <abstract>condition</abstract>}</cell><cell>SELECT * FROM {oj table1 LEFT OUTER JOIN table2 ON table1.id=table2.ref</cell><cell>Left outer join</cell></row>
				<row><cell>{oj <abstract>leftTable</abstract> RIGHT OUTER JOIN <abstract>rightTable</abstract> ON <abstract>condition</abstract>}</cell><cell>SELECT * FROM {oj table1 RIGHT OUTER JOIN table2 ON table1.id=table2.ref</cell><cell>Right outer Join</cell></row>
				<row><cell>{oj <abstract>leftTable</abstract> FULL OUTER JOIN <abstract>rightTable</abstract> ON <abstract>condition</abstract>}</cell><cell>SELECT * FROM {oj table1 FULL OUTER JOIN table2 ON table1.id=table2.ref</cell><cell>Full outer join</cell></row>
			</table>
			<explanation>Example:</explanation>
			<code>
				<line>String sql = "SELECT * FROM <em>{oj MoviePicture </em>" +</line>
				<line>   "<em>OUTER JOIN MovieMeta ON MoviePicture.movieRef=MovieMeta.movieRef}</em>";</line>
				<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
				<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
			</code>
			<explanation></explanation>
		</subSection>
	</singleColumnSection>
	

	
	<singleColumnSection anchor="howto" multipage="true">
		<head>How to...</head>

		<collapsedSubSection anchor="storedprocedures">
			<head>Stored Procedures</head>
			<summary>How to Invoke Stored Procedures (CallableStatement)</summary>
			<content>
				<explanation>
					JDBC offers support for <em>stored proceduces using the <javadoc>CallableStatement</javadoc></em> interface. <javadoc>CallableStatement</javadoc> extends <javadoc>PreparedStatement</javadoc> and adds 
					support for parameters. Stored procedures can either be invoked using the database's native syntax, or with a 
					database-independent <link anchor="storedproceduresescape">escape macro</link>.
				</explanation>
				<miniHeadline>Example Stored Procedures</miniHeadline>
				<explanation>
					The following examples are based on these four stored procedures and functions, here defined in PostgreSQL syntax:
				</explanation>
				<config>-- Deletes all movies in the given date range. No return value.
CREATE FUNCTION deleteMovies(minAge DATE, maxAge DATE) RETURNS void AS '
    DELETE FROM Movie WHERE releaseDate >= $1 and releaseDate &lt; $2
' LANGUAGE SQL;

-- Return average budget of all movies.
CREATE FUNCTION averageBudget() RETURNS decimal AS '
    SELECT avg(budget) from Movie
' LANGUAGE SQL;

-- Return min and max budget of movies of the given year.
CREATE FUNCTION minMaxBudget(year int, OUT minBudget decimal, OUT maxBudget decimal) AS '
    SELECT min(budget), min(budget) from Movie 
    WHERE extract(year from releaseDate)=$1
' LANGUAGE SQL;

-- Returns a table with title and release date of all movies released in
-- the given year.
CREATE FUNCTION getMoviesByYear(year int) RETURNS TABLE(title varchar, releaseDate date) AS '
    SELECT title, releaseDate from Movie 
    WHERE extract(year from releaseDate)=$1
' LANGUAGE SQL;
</config>
				<miniHeadline>Native Invocation</miniHeadline>
				<explanation>
					If you call a stored procedure without return or <idf>OUT</idf> values, you can use <javadoc>CallableStatement</javadoc> almost like <javadoc>PreparedStatement</javadoc>. 
					This example invokes <idf>deleteMovies</idf> <em>in native PostgreSQL syntax</em>:
				</explanation>
				<code>
					<line>String call = "<em>SELECT deleteMovies(?,?)</em>";</line>
					<line><em><javadoc>CallableStatement</javadoc></em> stmt = connection.<em><javadoc>prepareCall</javadoc></em>(call);</line>
					<line><javadoc>Date</javadoc> y1940 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1940, <javadoc>Calendar.JANUARY</javadoc>, 1).<javadoc>getTimeInMillis</javadoc>());</line>
					<line><javadoc>Date</javadoc> y1960 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1960, <javadoc>Calendar.JANUARY</javadoc>, 1).<javadoc>getTimeInMillis</javadoc>());</line>

					<line>stmt.<javadoc>setDate</javadoc>(1, y1940);<cmt>values for the placeholders ('?')</cmt></line>
					<line>stmt.<javadoc>setDate</javadoc>(2, y1960);</line>
					<line>stmt.<javadoc>execute</javadoc>();</line>
				</code>
				<explanation>Note that the code above won't work in many other databases. Another common syntax to invoke a stored procedure would
				be "CALL deleteMovies(?,?)".</explanation>
				
				<miniHeadline>Escape Syntax</miniHeadline>
				<explanation>
					The <em>JDBC escape syntax</em> allows you to invoke a store-procedure or function in a <em>database-independent</em> way:
				</explanation>
				<code>
					<line>String call = "<em>{call deleteMovies(?,?)}</em>";</line>
					<line><javadoc>CallableStatement</javadoc> stmt = connection.<javadoc>prepareCall</javadoc>(call);</line>
					<line><javadoc>Date</javadoc> y1940 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1940, <javadoc>Calendar.JANUARY</javadoc>, 1).<javadoc>getTimeInMillis</javadoc>());</line>
					<line><javadoc>Date</javadoc> y1960 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1960, <javadoc>Calendar.JANUARY</javadoc>, 1).<javadoc>getTimeInMillis</javadoc>());</line>
					<line>stmt.<javadoc>setDate</javadoc>(1, y1940);<cmt>values for the placeholders ('?')</cmt></line>
					<line>stmt.<javadoc>setDate</javadoc>(2, y1960);</line>
					<line>stmt.<javadoc>execute</javadoc>();</line>
				</code>
				
				<miniHeadline>Literals</miniHeadline>
				<explanation>
					Instead of placeholders you can also <em>pass literals to store procedures</em> or mix literals with placeholders. The 
					<em>parameter number refers to the placeholder</em>, not the parameter.
				</explanation>
				<code>
					<line>String call = "{call deleteMovies(<em>1940</em>, ?)}";</line>
					<line><javadoc>CallableStatement</javadoc> stmt = connection.<javadoc>prepareCall</javadoc>(call);</line>
					<line><javadoc>Date</javadoc> y1960 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1960, <javadoc>Calendar.JANUARY</javadoc>, 1).<javadoc>getTimeInMillis</javadoc>());</line>
					<line>stmt.<javadoc>setDate</javadoc>(<em>1</em>, y1960);<cmt>value for the placeholder ('?')</cmt></line>
					<line>stmt.<javadoc>execute</javadoc>();</line>
				</code>

				<miniHeadline>OUT Parameters</miniHeadline>
				<explanation>
					<idf>OUT</idf> parameters are represented by parameter placeholders ('?'), just like <idf>IN</idf> parameters. You need to
					<em>register the types of all <idf>OUT</idf> parameters</em> with <javadoc>registerOutParameter</javadoc> before execution. After the execution there are getter methods to retrieve
					the values.
				</explanation>
				<code>
					<line>String call = "{call minMaxBudget(?, ?, ?)}";<cmt>second and third placeholder is <idf>OUT</idf></cmt></line>
					<line><javadoc>CallableStatement</javadoc> stmt = connection.<javadoc>prepareCall</javadoc>(call);</line>
					<line>stmt.<javadoc>setInt</javadoc>(1, 1984);</line>
					<line>stmt.<javadoc><em>registerOutParameter</em></javadoc>(2, <javadoc>Types.DECIMAL</javadoc>);<cmt>declare return value types</cmt></line>
					<line>stmt.<javadoc><em>registerOutParameter</em></javadoc>(3, <javadoc>Types.DECIMAL</javadoc>);</line>
					<line>stmt.<javadoc>execute</javadoc>();</line>
					<line><javadoc>BigDecimal</javadoc> min = stmt.<javadoc to="java/sql/CallableStatement.html#getBigDecimal(int)"><em>getBigDecimal</em></javadoc>(2);<cmt>read <idf>OUT</idf> values</cmt></line>
					<line><javadoc>BigDecimal</javadoc> max = stmt.<javadoc to="java/sql/CallableStatement.html#getBigDecimal(int)"><em>getBigDecimal</em></javadoc>(3);</line>
					<line>System.out.println("Budget is between " + min + " and " + max);</line>
				</code>
				<explanation>For <idf>INOUT</idf> parameters you would need to <em>set the value as well as register the output type</em>.</explanation>
				
				<miniHeadline>Return Values</miniHeadline>
				<explanation>When calling functions with a return value, put a '?=' in front of the <idf>call</idf> macro. It declares a 
				parameter placeholder which will contain the return value:</explanation>
				<code>
					<line>String call = "{<em>?=</em> call averageBudget()}";</line>
					<line>stmt.<javadoc><em>registerOutParameter</em></javadoc>(1, <javadoc>Types.DECIMAL</javadoc>);<cmt>declare return value type</cmt></line>
					<line>stmt.<javadoc>execute</javadoc>();</line>
					<line><javadoc>BigDecimal</javadoc> avg = stmt.<javadoc to="java/sql/CallableStatement.html#getBigDecimal(int)"><em>getBigDecimal</em></javadoc>(1);<cmt>read the value</cmt></line>
					<line>System.out.println("Average budget is " + avg);</line>
				</code>
				
				<miniHeadline>Table Returns</miniHeadline>
				<explanation>If the stored procedure returns a table, you can <em>invoke the <javadoc>CallableStatement</javadoc> with <javadoc>executeQuery</javadoc></em>
				and handle the result just like you would with a regular statement:</explanation>
				<code>
					<line>String call = "{call getMoviesByYear(?)}";</line>
					<line><javadoc>CallableStatement</javadoc> stmt = connection.<javadoc>prepareCall</javadoc>(call);</line>
					<line>stmt.<javadoc>setInt</javadoc>(<em>1</em>, 1984);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc><em>executeQuery</em></javadoc>();</line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    String title = rs.<javadoc to="java/sql/ResultSet.html#getString(int)">getString</javadoc>(1);</line>
					<line>    <javadoc>Date</javadoc> date = rs.<javadoc to="java/sql/ResultSet.html#getDate(int)">getDate</javadoc>(2);</line>
					<emptyLine/>
					<line>    System.out.println(title + '(' + date + ')');</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>			
		
		<collapsedSubSection anchor="readingnull">
			<head>Reading NULL</head>
			<summary>How to Find Out Whether a ResultSet Column is NULL</summary>
			<content>
				<explanation>How to find out whether a <javadoc>ResultSet</javadoc> column is <idf>NULL</idf> depends on its type:</explanation>
				<list>
				<li>Getters returning <em>objects (like <idf>String</idf>, <javadoc>Time</javadoc> or <javadoc>Date</javadoc>) will return
				<idf>null</idf></em>.</li>
				<li>Getters returning <em>numbers (<idf>int</idf>, <idf>float</idf>...) will return 0</em>. You can <em>call 
				<javadoc to="java/sql/ResultSet.html#wasNull()">wasNull</javadoc> afterwards</em> to find out whether
				the value is <idf>NULL</idf> or 0.</li>
				<li><javadoc to="java/sql/ResultSet.html#getObject(java.lang.String)">getObject</javadoc> will always return <idf>null</idf>
				if the column is <idf>NULL</idf>.</li>
				</list> 
				
				<code>
				    <line><javadoc>ResultSet</javadoc> rs = <abstract>...</abstract>;</line>
				    <line>String title = rs.<javadoc>getString</javadoc>("title");</line>
				    <line>if (<em>title == null</em>) <cmt><idf>getString</idf> returns <idf>null</idf> for <idf>NULL</idf> columns</cmt></line>
				    <line>    System.out.println("Title is NULL");</line>
				    <emptyLine/>
				    <line>int budget = rs.<javadoc>getInt</javadoc>("budget");</line>
				    <line>if (rs.<javadoc to="java/sql/ResultSet.html#wasNull()"><em>wasNull</em></javadoc>()) <cmt><em>call <idf>wasNull</idf> directly after <idf>getInt</idf>!</em></cmt></line>
				    <line>    System.out.println("Budget is NULL");</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="cursors">
			<head>Cursors</head>
			<summary>How to Navigate in the ResultSet (Cursors)</summary>
			<content>
				<explanation>In all previous examples, the <javadoc>ResultSet</javadoc> has been read from
				beginning to the end. You can also configure your statement to return a <javadoc>ResultSet</javadoc>
				that allows you to <em>navigate in any order through the <javadoc>ResultSet</javadoc></em>, backward and forward,
				and to <em>jump to any position</em>. The current position in the <javadoc>ResultSet</javadoc> is
				also called the result set's <em>cursor</em>. A <javadoc>ResultSet</javadoc> that allows you to navigate in any direction
				is called <em>scrollable</em>.</explanation>
				<explanation>You can chose the following three types of <javadoc>ResultSet</javadoc>s:</explanation>
				<list>
					<li><em><javadoc to="java/sql/ResultSet.html#TYPE_FORWARD_ONLY">TYPE_FORWARD_ONLY</javadoc></em> - cursor can only move forward (<em>default</em>)</li>
					<li><em><javadoc to="java/sql/ResultSet.html#TYPE_SCROLL_INSENSITIVE">TYPE_SCROLL_INSENSITIVE</javadoc></em> - cursor can seek and go in any direction</li>
					<li><em><javadoc to="java/sql/ResultSet.html#TYPE_SCROLL_SENSITIVE">TYPE_SCROLL_SENSITIVE</javadoc></em> - like <javadoc to="java/sql/ResultSet.html#TYPE_SCROLL_INSENSITIVE">TYPE_SCROLL_INSENSITIVE</javadoc>,
					but the <javadoc>ResultSet</javadoc> changes if the underlying data changes</li>
				</list>
				<explanation>While the exact performance depends on the database and the driver, generally <javadoc to="java/sql/ResultSet.html#TYPE_FORWARD_ONLY">TYPE_FORWARD_ONLY</javadoc>
					is the fastest type and <javadoc to="java/sql/ResultSet.html#TYPE_SCROLL_SENSITIVE">TYPE_SCROLL_SENSITIVE</javadoc> the slowest.
				</explanation>
				<explanation>
					This example creates a scrollable <javadoc>ResultSet</javadoc> to navigate through an ordered result:
				</explanation>
				<code>
					<line>String sql = "SELECT title, budget FROM Movie <em>ORDER BY budgetMio DESC</em>";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc to="java/sql/Connection.html#prepareStatement(java.lang.String, int, int)">prepareStatement</javadoc>(sql, </line>
					<line>       <javadoc to="java/sql/ResultSet.html#TYPE_SCROLL_INSENSITIVE"><em>ResultSet.TYPE_SCROLL_INSENSITIVE</em></javadoc>, <javadoc to="java/sql/ResultSet.html#CONCUR_READ_ONLY">ResultSet.CONCUR_READ_ONLY</javadoc>);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<emptyLine/>
					<line>System.out.println("Top 5 Movies with highest budget");</line>
					<line>int highest5Counter = 5;</line>
					<line>while (rs.<javadoc>next</javadoc>() &amp;&amp; highest5Counter-- > 0)<cmt>going forward</cmt></line>
					<line>    System.out.printf("%s %d\n", rs.<javadoc>getString</javadoc>("title"), rs.<javadoc>getInt</javadoc>("budget"));</line>
					<emptyLine/>
					<line>System.out.println("Top 5 Movies with lowest budget");</line>
					<line>rs.<javadoc><em>last</em></javadoc>(); <cmt>jump to end of ResultSet</cmt></line>
					<line>int lowest5Counter = 5;</line>
					<line>while (rs.<javadoc><em>previous</em></javadoc>() &amp;&amp; lowest5Counter-- > 0)<cmt>going backwards</cmt></line>
					<line>    System.out.printf("%s %d\n", rs.<javadoc>getString</javadoc>("title"), rs.<javadoc>getInt</javadoc>("budget"));</line>
					<emptyLine/>
					<line>System.out.println("15th most expensive movie");</line>
					<line>if (rs.<javadoc><em>absolute</em></javadoc>(15)) <cmt>absolute positioning</cmt></line>
					<line>    System.out.printf("%s %d\n", rs.<javadoc>getString</javadoc>("title"), rs.<javadoc>getInt</javadoc>("budget"));</line>
					<emptyLine/>
					<line>System.out.println("15th least expensive movie");</line>
					<line>if (rs.<javadoc><em>absolute</em></javadoc>(-15)) <cmt>relative to end</cmt></line>
					<line>    System.out.printf("%s %d\n", rs.<javadoc>getString</javadoc>("title"), rs.<javadoc>getInt</javadoc>("budget"));</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="holdablers">
			<head>Holdability</head>
			<summary>How to Control ResultSet Holdability</summary>
			<content>
				<explanation>When you create a <javadoc>ResultSet</javadoc> inside a transaction, 
				it <em>depends on the driver whether you can still use the <javadoc>ResultSet</javadoc> after the <javadoc>commit</javadoc></em>. You can find out
				the driver's default with <javadoc to="java/sql/DatabaseMetaData.html#getResultSetHoldability()">getResultSetHoldability</javadoc>. However, <em>you can override
				the default behaviour</em> by specifying the holdability as a fourth argument to
				<javadoc to="java/sql/Connection.html#prepareStatement(java.lang.String, int, int, int)">prepareStatement</javadoc>:</explanation>
				<list>
					<li><javadoc to="java/sql/ResultSet.html#CLOSE_CURSORS_AT_COMMIT"><em>CLOSE_CURSORS_AT_COMMIT</em></javadoc> - close cursor after commit</li>
					<li><javadoc to="java/sql/ResultSet.html#HOLD_CURSORS_OVER_COMMIT"><em>HOLD_CURSORS_OVER_COMMIT</em></javadoc> - keep cursor open after commit</li>
				</list>
				<explanation>Specify the holdability like this:
				</explanation>
				<code>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc to="java/sql/Connection.html#prepareStatement(java.lang.String, int, int, int)">prepareStatement</javadoc>(sql, </line>
					<line>       <javadoc to="java/sql/ResultSet.html#TYPE_SCROLL_INSENSITIVE">ResultSet.TYPE_SCROLL_INSENSITIVE</javadoc>, <javadoc to="java/sql/ResultSet.html#CONCUR_READ_ONLY">ResultSet.CONCUR_READ_ONLY</javadoc>,</line>
					<line>       <javadoc to="java/sql/ResultSet.html#CLOSE_CURSORS_AT_COMMIT"><em>ResultSet.CLOSE_CURSORS_AT_COMMIT</em></javadoc>);</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="arrays">
			<head>Arrays</head>
			<summary>How to Handle SQL Arrays</summary>
			<content>
				<explanation>Some databases support storing arrays in columns, either only as part of custom types (Oracle) or also as regular type (PostgreSQL). 
				The following definition in PostgreSQL syntax creates a table containing an array of <idf>TIME</idf> objects:</explanation>
				<config>CREATE TABLE ShowTimes (
  movieRef    int,
  times       <em>time[]</em>,
  FOREIGN KEY (movieRef) REFERENCES Movie(id)
)</config>

				<miniHeadline>Arrays in ResultSets</miniHeadline>
				<explanation>Arrays are represented in JDBC by the <javadoc>Array</javadoc> interface and can be read from
				the <javadoc>ResultSet</javadoc> with <javadoc>getArray</javadoc>:</explanation>
				<code>
					<line>String sql = "SELECT times FROM ShowTimes WHERE movieRef=1";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    <javadoc>Array</javadoc> sta = rs.<javadoc>getArray</javadoc>("times");</line>
					<line>    <javadoc>Time</javadoc>[] showTimes  = (<javadoc>Time</javadoc>[]) sta.<javadoc to="java/sql/Array.html#getArray()">getArray</javadoc>();<cmt>cast to array of JDBC type <more><idf>getArray</idf>
					returns an array in the JDBC type corresponding to the database's type. Here, the database type is <idf>TIME</idf> and the
					corresponding JDBC type is <idf>java.sql.Time</idf>.</more></cmt></line>
					<line>    for (<javadoc>Time</javadoc> t: showTimes)</line>
					<line>        System.out.println(t.toString());</line>
					<line>}</line>
				</code>
				<explanation>To retrieve very long arrays, <javadoc>Array</javadoc> provides methods to retrieve slices of the array
				or to read the array as <javadoc>ResultSet</javadoc>.</explanation>
				
				<miniHeadline>Arrays as Parameters</miniHeadline>
				<explanation><em>Since JDBC 4.0</em> you can easily create an <javadoc>Array</javadoc> object using
				<javadoc>createArrayOf</javadoc> and then set it as parameter using <javadoc>setArray</javadoc>. <em>JDBC 3.0 does not 
				support <javadoc>createArrayOf</javadoc></em>, so you either need to use a driver-specific way of creating the
				array (some drivers support this), or use <link anchor="creatingsql">dynamically created SQL</link> to create the array
				with the database's own SQL syntax. This example uses JDBC 4.0 to insert a line into the <idf>ShowTimes</idf> table:</explanation>
				<code>
					<line>String sql = "INSERT INTO ShowTimes(movieRef, times) VALUES(8,?)";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<emptyLine/>
					<line><javadoc>Time</javadoc>[] showTimes = new <javadoc>Time</javadoc>[] {</line>
					<line>    new <javadoc>Time</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1970,0,1, 18,30).<javadoc>getTimeInMillis</javadoc>()),<cmt> 6:30pm</cmt></line>
					<line>    new <javadoc>Time</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1970,0,1, 20,15).<javadoc>getTimeInMillis</javadoc>()),<cmt> 8:15pm</cmt></line>
					<line>    new <javadoc>Time</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1970,0,1, 23,00).<javadoc>getTimeInMillis</javadoc>()),<cmt>11:00pm</cmt></line>
					<line>};</line>
					<line>stmt.<em><javadoc>setArray</javadoc></em>(1, connection.<em><javadoc>createArrayOf</javadoc></em>(<em>"time"</em>, showTimes)); <plainCmt>db type as first arg <more><javadoc>createArrayOf</javadoc> <em>requires the database's own type name</em> for the data stored
				in the database as first argument. In this example, it is an array of "time". For an array of strings, use "varchar" (or "varchar2" for Oracle).</more></plainCmt></line>
					<emptyLine/>
					<line>stmt.<javadoc>executeUpdate</javadoc>();</line>
				</code>
				<explanation></explanation>
			</content>
			
		</collapsedSubSection>
		
		<collapsedSubSection anchor="creatingsql">
			<head>Creating SQL</head>
			<summary>How to Escape Strings in SQL to Prevent SQL Injection Attacks</summary>
			<content>
				<explanation>
					Dynamically creating SQL statements by putting values into SQL is a <em>well-known cause of bugs and, even worse,
					<link to="http://en.wikipedia.org/wiki/SQL_injection">SQL Injection</link> security issues</em>. As example, this method
					is supposed to find out the release date of a movie:
				</explanation>
				<code>
					<line>Date getReleaseDate(<javadoc>Connection</javadoc> connection, String title) {</line>
					<line>    <javadoc>Statement</javadoc> stmt = connection.<javadoc>createStatement</javadoc>();</line>
					<emptyLine/>
					<line>    <plainCmt><warn>DON'T DO THIS:</warn></plainCmt></line>
					<line>    String sql = "SELECT releaseDate FROM Movie WHERE <em>title='" + title +"'"</em>;</line>
					<emptyLine/>
					<line>    ResultSet rs = stmt.<javadoc to="java/sql/Statement.html#executeQuery(java.lang.String)">executeQuery</javadoc>(sql);</line>
					<line>    <javadoc>Date</javadoc> r = rs.next() ? rs.<javadoc to="java/sql/ResultSet.html#getDate(int)">getDate</javadoc>(1) : null;</line>
					<line>    rs.<javadoc to="java/sql/ResultSet.html#close()">close()</javadoc>;</line>
					<line>    return r;</line>
					<line>}</line>
				</code>
				<explanation>If the <em><idf>title</idf> parameter contains a single quote</em> (') or any other character that will be interpreted by the database (which ones exactly
				depends on the database), the SQL statement does not work as intended. If the title has been entered by a user and the user enters something like the following string as
				title, the <em>user can delete the whole table</em> or execute any other SQL statement:</explanation>
				<config>'; DELETE FROM Movie WHERE title!='</config>
				<explanation>Because then the broken code above would execute the following SQL:</explanation>
				<config>SELECT releaseDate FROM Movie WHERE title='<em>'; DELETE FROM Movie WHERE title!='</em>';</config>
				<explanation>In other words, <em>avoid creating SQL statements at runtime</em>, be careful not to put any arbitrary strings into the executed
				SQL, and be <em>especially careful with user input</em>.</explanation>
				<explanation>Unfortunately <em>JDBC does not offer any database-independant way of escaping strings</em> for safe use in SQL statements.
				If you really want to create your SQL this way, consult the database's manual on how to filter and escape strings to prevent SQL injection attacks.
				But in almost every case, <em>it's easier and safer to use <javadoc>PreparedStatement</javadoc>s with parameters</em>.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="batch">
			<head>Batch Update</head>
			<summary>How to Do a Batch Updates</summary>
			<content>
				<explanation>
				Batch updates allow you to <em>delay statement invocations to execute them in a single batch</em>. This is usually faster than executing
				them separately <more>Batch updates avoid the back-and-forth between database client and server. Instead of issueing a single statement,
				waiting for the result and then executing the next, the server gets all statements at once. This can <em>reduce latency</em> caused by network
				and protocol significantly, and also avoids the protocol's overhead.<br/>
				Note that batch updates are <em>work best for many fast updates, but hardly accelerate a few slow updates</em>.</more>. 
				</explanation>
				<explanation>When used with <link anchor="plainstatements">plain statements</link>, you can specify a list of SQL statements to execute (but can
				not use parameters and probably have to <link anchor="creatingsql">escape strings in SQL</link>, with all the problems that it causes):</explanation>
				<code>
					<line><javadoc>Statement</javadoc> stmt = connection.<javadoc>createStatement</javadoc>();</line>
					<line>String sqlStart = "INSERT INTO Movie(title,budget,releaseDate) VALUES";</line>
					<line>stmt.<javadoc><em>addBatch</em></javadoc>(sqlStart + "('The Goonies',19000000,{d '1985-06-07'})");</line>
					<line>stmt.<javadoc><em>addBatch</em></javadoc>(sqlStart + "('E.T.',10500000,{d '1982-06-1'})");</line>
					<line>stmt.<javadoc><em>addBatch</em></javadoc>(sqlStart + "('Raiders of the Lost Ark',20000000,{d '1981-06-12'})");</line>
					<line>int updateCount[] = stmt.<javadoc><em>executeBatch</em></javadoc>();<cmt>result contains number of updates</cmt></line>
				</code>
				<explanation>
					With prepared statements, you can <em>execute the same SQL statement</em> several times, only the parameters can vary:   
				</explanation>
				<code>
					<line>String sql = "INSERT INTO Movie(title,budget,releaseDate) VALUES(?,?,?)";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>connection.prepareStatement</javadoc>(sql);</line>
					<emptyLine/>
					<line>stmt.<javadoc>setString</javadoc>(1, "The Goonies");</line>
					<line>stmt.<javadoc>setInt</javadoc>(2, 19000000);</line>
					<line><javadoc>Date</javadoc> june07_85 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1985, <javadoc>Calendar.JUNE</javadoc>, 7).<javadoc>getTimeInMillis</javadoc>());</line>
					<line>stmt.<javadoc>setDate</javadoc>(3, june07_85);</line>
					<line>stmt.<javadoc to="java/sql/PreparedStatement.html#addBatch()"><em>addBatch</em></javadoc>();</line>
					<emptyLine/>
					<line>stmt.<javadoc>setString</javadoc>(1, "E.T.");</line>
					<line>stmt.<javadoc>setInt</javadoc>(2, 10500000);</line>
					<line><javadoc>Date</javadoc> june01_82 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1982, <javadoc>Calendar.JUNE</javadoc>, 1).<javadoc>getTimeInMillis</javadoc>());</line>
					<line>stmt.<javadoc>setDate</javadoc>(3, june01_82);</line>
					<line>stmt.<javadoc to="java/sql/PreparedStatement.html#addBatch()"><em>addBatch</em></javadoc>();</line>
					<emptyLine/>
					<line>int updateCount[] = stmt.<javadoc><em>executeBatch</em></javadoc>();<cmt>result contains number of updates</cmt></line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="performance">
			<head>Performance</head>
			<summary>How to Improve Performance</summary>
			<content>
				<explanation>There are several ways of improving performance with JDBC:</explanation>
				<list>
					<li>In general, <em>the database is the bottleneck</em> and not JDBC. Optimize on the database side first:
						<list>
							<li><em>Optimize your SQL</em> code. Use an <link to="http://en.wikipedia.org/wiki/Explain_Plan">explain plan</link> to understand the
							database's behaviour.</li>
							<li>Optimize the <em>database schema and its indexes</em>.</li>
							<li>Try to return <em>as few results as possible</em>. Less data means better performance.</li>
						</list>
					</li>
					<li><em>Use <javadoc>PreparedStatement</javadoc> with parameters</em> and reuse the statement object, instead of creating new statements
					every time. Some databases perform worse when you create new statements for every query.</li>
					<li><em>Use <link to="batch">batch updates</link></em> if you execute many update statements that do not depend on each other.</li>
					<li>For queries with many results, consider <link to="fetchsizes">optimizing the fetch size</link>.</li>
				</list>
				
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="dateandtime">
			<head>Date and Time</head>
			<summary>How to Handle Date and Time</summary>
			<content>	
				<explanation>
					JDBC comes with <em>own types for date and time</em>. When you read or write a date in JDBC, you need to be sure to take the right one.
				</explanation>
				<miniHeadline>JDBC Types</miniHeadline>
				<table>
					<head><cell>SQL Type</cell><cell>JDBC Class</cell><cell>Description</cell><cell>ResultSet</cell><cell>Parameter</cell></head>
					<row><cell><javadoc to="java/sql/Types.html#DATE">DATE</javadoc></cell><cell><javadoc to="java/sql/Date.html">java.sql.Date</javadoc></cell><cell>Date (<em>without time!</em>) <more><idf>java.sql.Date</idf>
					represents a <em>date without time</em>. It is a <idf>java.util.Date</idf> whose time is <em>always
					midnight</em>.<br/>	If you need a date with time, use <idf>java.sql.Timestamp</idf>.</more></cell><cell><javadoc to="java/sql/ResultSet.html#getDate(java.lang.String)">getDate</javadoc></cell><cell><javadoc to="java/sql/PreparedStatement.html#setDate(int, java.sql.Date)">setDate</javadoc></cell></row>
					<row><cell><javadoc to="java/sql/Types.html#TIME">TIME</javadoc></cell><cell><javadoc to="java/sql/Time.html">java.sql.Time</javadoc></cell><cell>time of day <more><idf>java.sql.Time</idf>
					represents the <em>time of day</em>. It is a <idf>java.util.Date</idf> whose date is always January 1 1970. Only
					the time of that day is used by JDBC.</more></cell><cell><javadoc to="java/sql/ResultSet.html#getTime(java.lang.String)">getTime</javadoc></cell><cell><javadoc to="java/sql/PreparedStatement.html#setTime(int, java.sql.Time)">setTime</javadoc></cell></row>
					<row><cell><javadoc to="java/sql/Types.html#TIMESTAMP">TIMESTAMP</javadoc>, <idf>DATETIME</idf></cell><cell><javadoc to="java/sql/Timestamp.html">java.sql.Timestamp</javadoc></cell><cell>date and time <more><idf>java.sql.Timestamp</idf>
					represents the <em>time and day with nanosecond precision</em>. It extends <idf>java.util.Date</idf> with fractional seconds with a much higher precision
					than <idf>java.util.Date</idf>'s milliseconds.<br/>
					Timestamp can also be used to <em>set and retrieve <idf>DATETIME</idf>.</em></more></cell><cell><javadoc to="java/sql/ResultSet.html#getTimestamp(java.lang.String)">getTimestamp</javadoc></cell><cell><javadoc to="java/sql/PreparedStatement.html#setTimestamp(int, java.sql.Timestamp)">setTimestamp</javadoc></cell></row>
				</table>
				<explanation>Note: use <em><javadoc to="java/sql/Timestamp.html">java.sql.Timestamp</javadoc> for dates with time</em>, and <em><javadoc to="java/sql/Date.html">java.sql.Date</javadoc> only for dates without time (midnight)</em>.
				Even though the name may suggest that <javadoc to="java/sql/Date.html">java.sql.Date</javadoc> is the JDBC equivalent of
				<javadoc to="java/util/Date.html">java.util.Date</javadoc>, it is not.
				</explanation>
				<miniHeadline>Literals</miniHeadline>
				<explanation>
					Instead of the database's native syntax, JDBC's escape syntax supports database-independent literals.</explanation>
					<table>
						<head><cell>Syntax</cell><cell>Example</cell><cell>Description</cell></head>
						<row><cell>{d 'yyyy-mm-dd'}</cell><cell>{d '2010-06-30'}</cell><cell>Date</cell></row>
						<row><cell>{t 'hh:mm:ss'}</cell><cell>{t '17:30:00')</cell><cell>Time</cell></row>
						<row><cell>{ts 'yyyy-mm-dd hh:mm:ss'}</cell><cell>{ts '2000-12-24 18:00:00'}</cell><cell>Timestamp (second precision)</cell></row>
						<row><cell>{ts 'yyyy-mm-dd hh:mm:ss.fff'}</cell><cell>{ts '2006-10-06 09:34:15.51712'}</cell><cell>Timestamp (with fractional second)</cell></row>
					</table>
					<explanation>Example:</explanation>
					<code>
						<line>String sql = "SELECT title FROM Movie WHERE releaseDate > <em>{d '1980-01-01'}</em>";</line>
						<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
						<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					</code>	
					<explanation></explanation>
				</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="fetchsizes">
			<head>Fetch Sizes</head>
			<summary>How to Set the Fetch Size</summary>
			<content>
				<explanation>When you execute a query, <em>a JDBC driver may load the rows incrementally</em> as you browse through them, instead of fetching the whole
				result at once. You can use the method <javadoc><em>setFetchSize</em></javadoc> to tell the driver how many rows it should load at once. 
				Note that this is merely <em>a hint for the driver</em>, and it only affects the driver's performance, but not its function.
				</explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<emptyLine/>
					<line>String sql = "SELECT * FROM Movie";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<line>rs.<javadoc><em>setFetchSize</em></javadoc>(100);<cmt>recommend fetch size</cmt></line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    <plainCmt>...</plainCmt></line>
					<line>}</line>
				</code>
				<explanation>Setting the fetch size is useful, for example, when you may abort reading a large <javadoc>ResultSet</javadoc> after a few rows. Then you would
				set the fetch size very low, to avoid reading too much data.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="timeout">
			<head>Query Timeout</head>
			<summary>How to Set the Query Timeout</summary>
			<content>
				<explanation>Database queries can run a long time. <em>By default the driver decides how long a query may run</em> before the driver aborts it 
				and throws a <javadoc>SQLTimeoutException</javadoc>. If you need the driver to wait at least a certain amount of time, use 
				<javadoc><em>setQueryTimeout</em></javadoc> to set the minimum timeout value (the driver is allowed to wait longer though).
				</explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<emptyLine/>
					<line>String sql = "SELECT * FROM Movie";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line>stmt.<javadoc><em>setQueryTimeout</em></javadoc>(100);<cmt>wait at least 100s</cmt></line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    <plainCmt>...</plainCmt></line>
					<line>}</line>
				</code>
				<explanation>Note that a JDBC driver may also apply the timeout value to the <javadoc>ResultSet</javadoc>, thus throwing
				an error if you use the <javadoc>ResultSet</javadoc> for too long. This behaviour is driver-dependent.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="rowsets">
			<head>RowSets</head>
			<summary>What are RowSets?</summary>
			<content>
				<explanation><javadoc package="javax.sql">RowSet</javadoc>s are wrappers for <javadoc>ResultSet</javadoc>s that <em>add
				features for GUI applications</em> and similar programs. The standard <javadoc package="javax.sql">RowSet</javadoc> allows
				accessing the data as <em>JavaBeans component with properties and event notifications</em> and is designed for
				use in visual GUI editors.</explanation>
				<explanation>The most important <javadoc package="javax.sql">RowSet</javadoc> variant is the 
				<javadoc package="javax.sql">CachedRowSet</javadoc>. It can disconnect from the database to edit the data offline.
				Later it can re-connect and synchronize with the database. Other rowsets add features like XML serialization and filtering.</explanation>
				<explanation>Rowsets are a complex topic and out of the scope of this tutorial. Also, <em>rowsets are not really relevant anymore</em>,
				as GUI applications accessing databases directly are mostly out of fashion today. If you still want to learn more about
				rowsets, read the <link to="http://java.sun.com/j2se/1.5/pdf/jdbc-rowset-tutorial-1.5.0.pdf">rowset tutorial</link>.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="dbmetadata">
			<head>DB Metadata</head>
			<summary>How to Find Out the Database's Capabilities (DatabaseMetaData)</summary>
			<content>
				<explanation>
					Each database and each JDBC driver has its own limitations and <em>supports a different subset of the JDBC API</em>. 
					There is probably no database that supports all JDBC features. To learn what a driver supports,
					you can retrieve a <javadoc>DatabaseMetaData</javadoc> object from the <javadoc>Connection</javadoc>, which allows you 
					to find out about the database's capabilities as well as the connection's properties.
				</explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<emptyLine/>
					<line><plainCmt>Print some random meta data</plainCmt></line>
					<line><javadoc><em>DatabaseMetaData</em></javadoc> meta = connection.<javadoc><em>getMetaData</em></javadoc>();</line>
					<line>System.out.println("Connection URL: "+meta.<javadoc to="java/sql/DatabaseMetaData.html#getURL()"><em>getURL</em></javadoc>());</line>
					<line>System.out.println("Supports stored procedures: "+meta.<javadoc to="java/sql/DatabaseMetaData.html#supportsStoredProcedures()"><em>supportsStoredProcedures</em></javadoc>());</line>
					<line>System.out.println("Max row size in bytes: "+meta.<javadoc to="java/sql/DatabaseMetaData.html#getMaxRowSize()"><em>getMaxRowSize</em></javadoc>());</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="resultsetmetadata">
			<head>ResultSet Meta Data</head>
			<summary>How to Find Out About the Columns of a ResultSet (ResultSetMetaData)</summary>
			<content>
				<explanation>The <javadoc>ResultSetMetaData</javadoc> object allows you to <em>find out about the column definitions</em> of a <javadoc>ResultSet</javadoc>.
				This is mostly useful when writing a generic database tool.</explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<emptyLine/>
					<line>String sql = "SELECT * FROM Movie";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<emptyLine/>
					<line><javadoc><em>ResultSetMetaData</em></javadoc> meta = rs.<javadoc to="java/sql/ResultSet.html#getMetaData()"><em>getMetaData</em></javadoc>();</line>
					<line>for (int i = <em>1</em>; i &lt;= meta.<javadoc to="java/sql/ResultSetMetaData.html#getColumnCount()"><em>getColumnCount</em></javadoc>(); i++) <cmt>print column names and types</cmt></line>
					<line>    System.out.printf("%s (%s)\t", meta.<javadoc to="java/sql/ResultSetMetaData.html#getColumnLabel(int)"><em>getColumnLabel</em></javadoc>(i), meta.<javadoc to="java/sql/ResultSetMetaData.html#getColumnTypeName(int)"><em>getColumnTypeName</em></javadoc>(i));</line>
					<line>System.out.println();</line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    for (int i = 1; i &lt; meta.<javadoc to="java/sql/ResultSetMetaData.html#getColumnCount()"><em>getColumnCount</em></javadoc>(); i++)</line>
					<line>        System.out.print(rs.<javadoc to="java/sql/ResultSet.html#getString(int)">getString</javadoc>(i) + '\t');</line>
					<line>    System.out.println();</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="blobs">
			<head>Blobs / Clobs</head>
			<summary>How to Use Blobs and Clobs</summary>
			<content>
				<explanation>JDBC represents blobs (binary large objects) with the <javadoc>Blob</javadoc> interface. It allows you
				to access the blog either <em>as byte stream</em>, or by reading and writing parts of the blob with byte arrays. Because of the 
				unlimited size of the blob you <em>can not directly access it as byte array</em>. <br/>
				Clobs are the equivalent of <em>blobs for large texts</em>: you access the <javadoc>Clob</javadoc> interface using
				character streams or by setting and retrieving substrings, but never the whole clob.</explanation>
				<miniHeadline>Example Schema</miniHeadline>
				<explanation>The following examples use this table (Java DB syntax):</explanation>
				<config>CREATE TABLE MoviePicture (
  movieRef    int,
  picture     <em>blob</em>,
  FOREIGN KEY (movieRef) REFERENCES Movie(id)
)</config>
				<miniHeadline>Setting a Blob as Parameter</miniHeadline>
				<explanation>The following example inserts a row containing a blob. Note that in JDBC's API <em>all positions in <javadoc>Blob</javadoc>
				are always 1-based</em> (thus specify <idf>1</idf> instead of <idf>0</idf> to write something at the beginning of the blob). 
				</explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<line>String sql = "INSERT INTO MoviePicture(movieRef, picture) VALUES(1, ?)";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<emptyLine/>
					<line><javadoc><em>Blob</em></javadoc> blob = connection.<javadoc to="java/sql/Connection.html#createBlob()"><em>createBlob</em></javadoc>();</line>
					<line><javadoc package="java.io">OutputStream</javadoc> blobOs = blob.<em><javadoc to="java/sql/Blob.html#setBinaryStream(long)">setBinaryStream</javadoc>(1)</em>;<cmt><em>1 is beginning of the stream!</em></cmt></line>
					<line>IOUtils.copy(new <javadoc package="java.io">FileInputStream</javadoc>("jaws.jpeg"), blobOs);<cmt>from copy file into blob <more><idf>IOUtils.copy</idf>
is a method of the Apache Commons IO library, not part of Java. It copies the content of a given input stream (here: the file content)
into the given output stream (here: into the blob).</more></cmt></line>
					<line>stmt.<javadoc to="java/sql/PreparedStatement.html#setBlob(int, java.sql.Blob)">setBlob</javadoc>(1, blob);</line>
					<line>stmt.<javadoc>executeUpdate</javadoc>();</line>
				</code>
				
				<miniHeadline>Reading a Blob from a ResultSet</miniHeadline>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<line>String sql = "SELECT picture FROM MoviePicture";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    <javadoc><em>Blob</em></javadoc> blob = rs.<javadoc to="java/sql/ResultSet.html#getBlob(java.lang.String)"><em>getBlob</em></javadoc>("picture");</line>
					<line>    long len = blob.<javadoc to="java/sql/Blob.html#length()"><em>length</em></javadoc>();</line>
					<line>    if (len &lt; 64000) {</line>
					<line>        byte[] img = blob.<em><javadoc to="java/sql/Blob.html#getBytes(long, int)">getBytes</javadoc>(1, (int)blob.<javadoc to="java/sql/Blob.html#length()">length</javadoc>())</em>;<cmt><em>starts at 1!</em></cmt></line>
					<line>    <plainCmt>do something with <idf>img</idf> here...</plainCmt></line>
					<line>    }</line>
					<line>    else</line>
					<line>        System.out.println("Blob is longer than 64000 bytes, won't load");</line>
					<line>}</line>
				</code>
				
				<miniHeadline>Working with Clobs</miniHeadline>
				<explanation><javadoc>Clob</javadoc>s are used like blobs, just with character streams and strings. Creating a clob:</explanation>
				<code>
					<line><javadoc><em>Clob</em></javadoc> clob = connection.<javadoc to="java/sql/Connection.html#createClob()"><em>createClob</em></javadoc>();</line>
					<line>clob.<javadoc to="java/sql/Clob.html#setString(long, java.lang.String)">setString</javadoc>(1,  "hello");<cmt><em>first position is 1!</em></cmt></line>
				</code>
				<explanation>Reading a clob:</explanation>
				<code>
					<line>long len = clob.<javadoc to="java/sql/Clob.html#length()"><em>length</em></javadoc>();</line>
					<line>if (len &lt; 64000) {<cmt>if text not too long</cmt></line>
					<line>    String text = clob.<em><javadoc to="java/sql/Clob.html#getSubString(long, int)">getSubString</javadoc>(1, (int)clob.<javadoc to="java/sql/Clob.html#length()">length</javadoc>())</em>;</line>
					<line>    <plainCmt>do something with <idf>text</idf> ...</plainCmt></line>
					<line>}</line>
				</code>
				<miniHeadline>Freeing Blob/Clob Resources</miniHeadline>
				<explanation>
					Blobs and clobs can consume a lot of memory. If you plan to keep your <javadoc>Connection</javadoc> much longer open than
					you need your <javadoc>Blob</javadoc>, <em>free those resources explicitly</em> when you dont need the blob anymore:
				</explanation>
				<code>
					<line>blob.<javadoc to="java/sql/Clob.html#free()"><em>free</em></javadoc>();</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="xml">
			<head>XML</head>
			<summary>How to Access XML</summary>
			<content>
				<explanation><em>Since JDBC 4.0</em> you can access XML natively with the <em><javadoc>SQLXML</javadoc> type</em> (if the database
				supports this - many do not).
				It's mostly like a <javadoc>Blob</javadoc> or <javadoc>Clob</javadoc>, allowing you to access the XML as binary
				stream, character stream or string. The only XML-specific methods are <em><javadoc>getSource</javadoc> and <javadoc>setResult</javadoc></em>,
				which allow you to work with standard Java APIs on the XML.</explanation>
				<explanation>Note that JDBC itself offers no way of working with XML other than by reading or writing the whole XML document.
				Use SQL, either with the <link to="http://en.wikipedia.org/wiki/SQL/XML">SQL/XML</link> functions or
				priorietary extensions, to access parts of a XML document.</explanation>
				
				<explanation>The following examples assume that your database has the following table:
				</explanation>
				<config>CREATE TABLE MovieMeta (
  movieRef    int,
  metaData    <em>xml</em>,
  FOREIGN KEY (movieRef) REFERENCES Movie(id)
)
</config>
				<miniHeadline>Compatibility</miniHeadline>
				<explanation>Note that <em>many databases do not support XML</em>, or their JDBC driver does not support it. This
				includes Java DB. The following examples have been tested with PostgreSQL 8.4.</explanation>
				
				<miniHeadline>Setting XML as Parameter</miniHeadline>
				<explanation>
					<javadoc>SQLXML</javadoc> instances have to created using the <javadoc>Connection</javadoc>. Then you can set
					the XML content, either as stream, string or by writing a <javadoc package="javax.xml.transform">Result</javadoc>.
					This example shows how to write a <topic>JAXB</topic> XML tree into the database:
				</explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<line>MovieMetaData jaxbObject = new <abstract>MovieMetaData</abstract>();<cmt>some <em>JAXB object</em></cmt></line>
					<emptyLine/>
					<line>String sql = "INSERT INTO MovieMeta(movieRef, metaData) VALUES(1, ?)";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<emptyLine/>
					<line><javadoc><em>SQLXML</em></javadoc> xml = connection.<javadoc to="java/sql/Connection.html#createSQLXML()"><em>createSQLXML</em></javadoc>();</line>
					<line><javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, javax.xml.transform.Result)">JAXB.marshal</javadoc>(jaxbObject, xml.<javadoc><em>setResult</em></javadoc>(<javadoc to="javax/xml/transform/sax/SAXResult.html">javax.xml.transform.sax.SAXResult.class</javadoc>));</line>
					<line>stmt.<javadoc to="java/sql/PreparedStatement.html#setSQLXML(int, java.sql.SQLXML)">setSQLXML</javadoc>(1, xml);</line>
					<line>stmt.<javadoc>executeUpdate</javadoc>();</line>
				</code>
				
				<miniHeadline>Reading XML from a ResultSet</miniHeadline>
				<explanation>This example reads XML from the database using <topic>JAXB</topic> (requires a JAXB xml mapping, <abstract>MovieMetaData</abstract> here):</explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<line>String sql = "SELECT metaData FROM MovieMeta";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    <javadoc><em>SQLXML</em></javadoc> metaXml = rs.<javadoc><em>getSQLXML</em></javadoc>("metaData");</line>
					<line>    MovieMetaData jaxbObject = <javadoc to="javax/xml/bind/JAXB.html#unmarshal(javax.xml.transform.Source, java.lang.Class)">JAXB.unmarshal</javadoc>(</line>
					<line>            metaXml.<javadoc><em>getSource</em></javadoc>(<javadoc to="javax/xml/transform/sax/SAXSource.html">javax.xml.transform.sax.SAXSource.class</javadoc>), MovieMetaData.class);</line>
					<emptyLine/>
					<line>    <plainCmt><abstract>do something with <idf>jaxbObject</idf></abstract></plainCmt></line>
					<line>}</line>
				</code>	
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="arrayparameters">
			<head>Array Parameters</head>
			<summary>How to Pass an Array as Parameter for the IN operator</summary>
			<content>
				<explanation><em>Since JDBC 4.0</em>, you can create an SQL array for the IN parameter:</explanation>
				<code>
				<line><javadoc>Connection</javadoc> con = <abstract>...</abstract>;</line>
				<line>String[] titles = <abstract>...</abstract>;</line>
				<emptyLine/>
				<line><javadoc>PreparedStatement</javadoc> stmt = con.<javadoc>prepareStatement</javadoc>("SELECT * FROM Movie WHERE <em>title IN ?</em>");</line>
				<line><javadoc>Array</javadoc> array = con.<javadoc>createArrayOf</javadoc>("varchar", titles);</line>
				<line>stmt.<javadoc>setArray</javadoc>(1, array);</line>
				</code>
				
				<explanation>JDBC 3.0 and earlier do not have a nice way to pass lists or arrays. Usually you have the following options:</explanation>
				
				<list>
				<li>Some database drivers offer a <em>proprietary way</em> of creating an SQL <javadoc>Array</javadoc>. Then you can work like with
				JDBC 4.0, but your code is not portable.</li>
				<li>If you have a fixed number of arguments, <em>use a parameter for each</em> (e.g. <plainCode>"SELECT * FROM users WHERE name in (?, ?, ?)"</plainCode>).</li>
				<li>Use <topic>JPA</topic> instead of JDBC direcly. JPA allows setting collections as query parameters.</li>
				<li>Create the <em>SQL statement dynamically</em>. This should be a <em>last resort</em>, as it can be complicated to get right, especially with
				strings. Be sure to escape all values correctly.</li>
				</list>
				
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="transactionisolation">
			<head>Isolation</head>
			<summary>How to Set the Transaction Isolation Level</summary>
			<content>
				<explanation>
					The transaction isolation level defines what happens when another client <em>modifies data you read</em> in your transaction. 
					The default behaviour, if you do not set the isolation level explicitly, depends on your driver. Thus <em>truly portable applications
					must set the isolation level</em>. 
					</explanation>
					<explanation>
					JDBC defines <em>four isolation levels</em>. Higher isolation levels are better, because there are fewer side-effects to worry about, but also slower.
					A driver is <em>not required to implement the isolation levels exactly</em>, but must provide you at least with the
					isolation you requested. If it can not fulfill this, it must throw an <javadoc>SQLException</javadoc>.</explanation>
					<table>
						<head><cell>Level</cell>
						<cell>Transactions enabled</cell>
						<cell><annotated><title>Dirty Reads</title><explanation>Changes by other transactions <em>can be seen before they have been committed</em>.<br/>
						This is a violation of one of the most important transaction principles, but may allow many optimizations in the database.
						The only 'transaction-like' behaviour that remains with such a low transaction level is the rollback.</explanation></annotated></cell>
						<cell><annotated><title>Nonrepeatable Reads</title><explanation>When a query is executed for the second time in
						the same transaction, and another transaction modifies the result, the <em>second query may return a different result</em> than the first one.
						</explanation></annotated></cell>
						<cell><annotated><title>Phantom Reads</title><explanation>If you execute a query for a second time
						and you get additional rows because of another transaction's commit, you have a phantom read.
						</explanation></annotated></cell>
						</head>
						<row><cell><javadoc>TRANSACTION_NONE</javadoc></cell>             <cell>no</cell>   <cell>possible</cell>      <cell>possible</cell>      <cell>possible</cell></row>
						<row><cell><javadoc>TRANSACTION_READ_UNCOMMITTED</javadoc></cell> <cell>yes</cell>  <cell>possible</cell>      <cell>possible</cell>      <cell>possible</cell></row>
						<row><cell><javadoc>TRANSACTION_READ_COMMITTED</javadoc></cell>   <cell>yes</cell>  <cell>not possible</cell>  <cell>possible</cell>      <cell>possible</cell></row>
						<row><cell><javadoc>TRANSACTION_REPEATABLE_READ</javadoc></cell>  <cell>yes</cell>  <cell>not possible</cell>  <cell>not possible</cell>  <cell>possible</cell></row>
						<row><cell><javadoc>TRANSACTION_SERIALIZABLE</javadoc></cell>     <cell>yes</cell>  <cell>not possible</cell>  <cell>not possible</cell>  <cell>not possible</cell></row>
					</table>
					<explanation>Use <javadoc>setTransactionIsolation</javadoc> to set the isolation level <em>before you execute the first statement</em> 
					of a transaction (the result of setting it in the middle of a transaction is driver-dependent). The level will be kept for all future transactions of
					the <javadoc>Connection</javadoc>.
				</explanation>
				<code>
				<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
				<line>try {</line>
				<line>    connection.<em><javadoc>setTransactionIsolation</javadoc>(<javadoc>Connection.TRANSACTION_SERIALIZABLE</javadoc>)</em>;</line>
				<line>    connection.<javadoc>setAutoCommit</javadoc>(false);<cmt>begin transaction</cmt></line>
				<emptyLine/>
				<line>    <plainCmt>...</plainCmt></line>
				<emptyLine/>
				<line>    connection.<javadoc>commit</javadoc>();</line>
				<line>}</line>
				<line>catch (RuntimeException e) {</line>
				<line>    connection.<javadoc>rollback</javadoc>();<cmt>rollback on unhandled error</cmt></line>
				<line>}</line>
				<line>finally {</line>
				<line>    connection.<javadoc>close</javadoc>();</line>
				<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="drivercats">
			<head>Driver Categories</head>
			<summary>What are JDBC Driver Categories?</summary>
			<content>
				<explanation>
					<em>JDBC defines four categories of drivers</em>. The classification describes how they are implemented and it may give hints of how to install them.
					<em>From an API point of view, there is no difference</em> between those four categories.
				</explanation>
				<list>
					<li><em>Category 1: JDBC/ODBC bridge</em>. This type of driver uses Microsoft's <link to="http://en.wikipedia.org/wiki/Open_Database_Connectivity">ODBC</link>
					interface to access the database and was popular in the early days of JDBC when there were no native JDBC drivers. Today you should not use this anymore.</li>
					<li><em>Category 2: Native API driver</em>. Those drivers use a native library to access the database and were used before database network
					protocols were implemented in Java. In some cases they may be faster than category 4 drivers, but in all other cases they are not worth the trouble.</li>
					<li><em>Category 3: Network-translating driver</em>. This type of driver did not use the database's native protocol, but required a middleware
					between the driver and the database to translate between their protocols. Category 3 has never been popular and is irrelevant today.</li>
					<li><em>Category 4: Pure Java driver</em>. A driver that is written in 100% Java and communicates directly with the database. In almost
					all cases, <em>this is what you want</em>, and category 4 drivers are available for practically all current databases.</li>
				</list>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="wheretoputstatements">
			<head>Statements</head>
			<summary>Where to Put SQL Statements</summary>
			<content>
				<explanation>Where to put your SQL statements is an almost religious question. I'v seen pretty much everything, from putting 
					string literals into the execute() method, over using final static strings, putting them in property or XML configuration files, 
					setting them in the deployment descriptor or via Spring over to storing them in the database itself.
				</explanation><explanation>
					My personal opinion is to <em>keep SQL as close to as possible to the code that executes it</em>. This 
					means you should generally can keep it in the execute/prepare method invocation, unless you need the same statement at several places. 
					In the latter case it may make sense to put them into a commonly used static final string, but more likely is that you should put the 
					code fragment that needs the statement in a method of its own and share this method.
				</explanation><explanation>
					The reason for keeping the statement close to the code is simple: SQL statements are almost always heavily intertwined on the code. 
					They require that you give them parameters of the right type in the right order. The code requires that they return columns in the 
					right type either in the right order or with the right names. And there may be even more subtle things, such as the code requiring 
					results in a certain order.
				</explanation><explanation>
					This means on the one hand, that in order to understand the code you need to read the SQL statement as well. Putting it somewhere 
					far away makes the code less readable. And on the other hand, making the statement "configurable" is mostly an illusion. You would 
					have to go to great lengths to document all the constraints that your code puts on the statement. Otherwise changing the statement 
					requires at least reading the source code, and possibly also modifying it.
				</explanation><explanation>
					The only rule that override the 'keep it as close as possible' is <em>don't repeat yourself!</em>. If you need a SQL statement at
					two places, put it into a common constant. In most cases, however, before using the SQL statement twice you should consider writing
					a method that executes the statement and possibly returns the result set, because you are likely to repeat that code fragment at well.
				</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="dboverview">
			<head>Databases</head>
			<summary>Which Database is the Right One? (Short Database Overview)</summary>
			<content>
			<explanation>
			There are so many databases to chose from that giving advice is always difficult and depends on your goals. But I can try
			to give you a short overview over some common databases for Java development, from my very own perspective.
			</explanation>
			<miniHeadline>Apache Derby / JavaDB</miniHeadline>
			<explanation>Price: free (open-source, Apache license)</explanation>
			<explanation>
				Apache Derby is a database written in pure Java. In its rather complicated history, it has been written
				by a startup called Cloudscape in the late 90s, before being acquired by Informix, who were then acquired by IBM.
				In 2004 IBM donated the code to Apache Foundation, and since then it is known as Apache Derby. Sun 
				<em>ships a rebranded version called Java DB</em> as part of Java SE since version 6. 
			</explanation>
			<explanation>
				Derby is mostly known as low-footprint <annotated id="docs-embedded-db"><title>embedded database</title><explanation>'Embedded'
				in the context of databases usually means that the database is included as part of a product, often in desktop
				applications. Unlike server applications, the user does not even need to know that a database is being used,
				as it runs in the application's process and stores its data as regular files.</explanation></annotated>. Even though it can also be
				used as <annotated id="docs-server-db"><title>database server</title><explanation>"Server" means that the database runs in its own process 
				or even on a separate machine, allowing clients on other machines to access it.</explanation></annotated>, I have never heard
				of anyone doing this in production use.
			</explanation>
			<explanation>Link: <link to="http://db.apache.org/derby/">Apache Derby</link></explanation>
			
			<miniHeadline>MySQL</miniHeadline>
			<explanation>Price: free (open-source, GPL)</explanation>
			<explanation><link to="http://en.wikipedia.org/wiki/MySQL">MySQL</link> is the most popular database for
				web applications. While its SQL engine is rather simple and lacks many advanced features, MySQL's main advantage 
				lies beneath the SQL engine: unlike most other databases there are several storage engines to choose from. A plugin-mechanism allows
				you to use best suited engine for each table. Many of those engines, including the old default engine MyISAM,
				are designed for performance, but are not very strong at transaction support and data integrity.
				This leads to MySQL's reputation of being extremely fast (especially after tweaking it), but not as reliable as other databases.
				Your results may vary, depending on what storage engine you are using.</explanation>
				
			<explanation>Link: <link to="http://www.mysql.com/">MySQL</link></explanation>
			
			<miniHeadline>PostgreSQL</miniHeadline>
			<explanation>Price: free (open-source, BSD license)</explanation>
			<explanation>In many ways, you could say that PostgreSQL is the opposite of MySQL. While MySQL allows you to tweak everything and even replace 
				storage engines, PostgreSQL keeps it (relatively) simple. And while MySQL's transaction support and reliability has a bad reputation, PostgreSQL 
				is known for its excellent transaction and concurrency features.<br/>
				In my humble opinion, PostgreSQL is the most friendly one of the 'major' databases, easy to use, with very complete SQL implementation and 
				<link to="http://www.postgresql.org/docs/manuals/">excellent manuals</link>. If you have no special requirements for your database, 
				try PostgreSQL first.</explanation>
			<explanation>Link: <link to="http://www.postgresql.org/">PostgreSQL</link></explanation>

			<miniHeadline>Oracle Database</miniHeadline>
			<explanation>Prices: ranges from Express Edition (free) to Enterprise Edition (medium fortune)</explanation>
			<explanation>Unless forced by a corporate behemoth, using Oracle DB rarely makes sense. While undoubtly reliable and feature-rich, 
				the database is full of oddities caused by its long history, not very user-friendly and just plain expensive. 
				Here are the Top 3 Oracle oddities:</explanation>
			<list>
				<li>It does <em>not support empty strings</em>. If you insert one, Oracle converts it to a <idf>NULL</idf>.</li>
				<li>String columns should be declared as <idf>VARCHAR2</idf> <more><idf>VARCHAR</idf> was a failed attempt to implement it,
				but they kept it for backward compatibility and introduced the fixed version as <idf>VARCHAR2</idf>. In later versions
				<idf>VARCHAR</idf> has been fixed and works like <idf>VARCHAR2</idf> now, but Oracle still recommends you
				to use <idf>VARCHAR2</idf>.</more>.</li>
				<li>Names of internal structures (like table and column names) are <em>always in upper case</em>, which
				makes Oracle output look like an 8-bit revival.</li>
			</list>
			<explanation>Have I mentioned that I am not particularly fond of Oracle's database?</explanation>				
			
			<miniHeadline>Microsoft SQL Server Database</miniHeadline>
			<explanation>Prices: ranges from Express (free) to Enterprise Edition (small fortune)</explanation>
			<explanation>Microsoft's SQL Server is Windows-centric database. Originally forked from Sybase DB, it has
			long surpassed Sybase's version (which is mostly irrelevant today, but used to be one of the leading databases). 
			If you plan to develop and deploy on Windows machines and like to have GUIs for all administrative work, SQL Server
			can be a solid choice. The bigger versions are a bit pricey though, at least as long as you don't compare the prices 
			to Oracle's.</explanation>				
			<explanation>Link: <link to="http://www.microsoft.com/sqlserver/">Microsoft SQL Server</link></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="concurrency">
			<head>Concurrency</head>
			<summary>How to Use JDBC in Multi-Threaded Applications</summary>
			<content>
				<explanation>The JDBC specification does not even mention threads, so any <em>multi-threading capabilities depend on the JDBC driver</em>. 
					Many drivers claim to be thread-safe, but consult your driver's documentation to be sure. If you want to write portable applications, 
					<em>don't share <javadoc>Connection</javadoc> objects across threads</em>. This includes all objects obtained from the
					<javadoc>Connection</javadoc>, with the exception of immutable objects like <idf>String</idf> and <idf>Number</idf>.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="warnings">
			<head>SQLWarning</head>
			<summary>How to Read Warnings by the Driver or Database (SQLWarning)</summary>
			<content>
				<explanation>In some situations, the <em>SQL driver may issue a warning</em> instead of throwing an Exception, which would
				represent an error.
				Warnings are represented by the class <javadoc>SQLWarning</javadoc>, and can be retrieved
				from <javadoc>Connection</javadoc>, <javadoc>ResultSet</javadoc> and <javadoc>Statement</javadoc>
				objects by calling their respective <em><idf>getWarnings</idf></em> method. It returns the first new warning. Additional
				warnings can be retrieved using <javadoc to="java/sql/SQLWarning.html#getNextWarning()">getNextWarning</javadoc>.<br/>
				Note that even though <javadoc>SQLWarning</javadoc> <em>extends <javadoc>SQLException</javadoc>, but is never thrown</em>
				by the JDBC driver. It merely re-uses
				<javadoc>SQLException</javadoc>'s fields, including the stacktrace (I leave it up to you to figure out 
				whether extending <javadoc>Exception</javadoc> here is a good design).</explanation>
				
				<explanation>The following example prints warnings from a <javadoc>Connection</javadoc>:</explanation>
				
				<code>
				    <line><javadoc><em>SQLWarning</em></javadoc> warning = connection.<em><javadoc to="java/sql/Connection.html#getWarnings()">getWarnings()</javadoc></em>;</line>
				    <line>while (warning != null) {</line>
				    <line>    System.out.println(warning.<javadoc to="java/lang/Throwable.html#getMessage()"><em>getMessage</em></javadoc>());</line>
				    <line>    warning = warning.<javadoc to="java/sql/SQLWarning.html#getNextWarning()"><em>getNextWarning</em></javadoc>();<cmt>get next warning</cmt></line>
				    <line>}</line>
				</code>
				
				<explanation>Warnings are rarely used in most applications, but may help you investigate bugs and other odd database behaviour.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="types">
			<head>Type Mapping</head>
			<summary>How to Map Between Java Types and JDBC Types</summary>

			<content>
				<explanation>
				Each <em>SQL type is represented by a constant in <javadoc>Types</javadoc></em>, and there is a <em>corresponding Java type</em>
				for each of them. When you retrieve a <javadoc>ResultSet</javadoc> value with <javadoc to="java/sql/ResultSet.html#getObject(java.lang.String)">getObject</javadoc>,
				this is the type that you get. For built-in types (like <idf>int</idf>) you will get the wrapper class (like <javadoc to="java/lang/Integer.html">java.lang.Integer</javadoc>).
				</explanation> 
				<table>
		    <head>
		        <cell>JDBC Name</cell>
		        <cell>Java Type</cell>
		        <cell>ResultSet Getter</cell>
		        <cell>Parameter Setter</cell>
		        <cell>Comment</cell>
		    </head>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#ARRAY">ARRAY</javadoc></cell>
		        <cell><javadoc to="java/sql/Array.html">java.sql.Array</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getArray(java.lang.String)">getArray</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setArray(int, java.sql.Array)">setArray</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#BIGINT">BIGINT</javadoc></cell>
		        <cell><idf>long</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getLong(java.lang.String)">getLong</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setLong(int, long)">setLong</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#BINARY">BINARY</javadoc></cell>
		        <cell><idf>byte[]</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBytes(java.lang.String)">getBytes</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBytes(int, byte[])">setBytes</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#BIT">BIT</javadoc></cell>
		        <cell><idf>boolean</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBoolean(java.lang.String)">getBoolean</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBoolean(int, boolean)">setBoolean</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#BLOB">BLOB</javadoc></cell>
		        <cell><javadoc to="java/sql/Blob.html">java.sql.Blob</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBlob(java.lang.String)">getBlob</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBlob(int, java.sql.Blob)">setBlob</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#BOOLEAN">BOOLEAN</javadoc></cell>
		        <cell><idf>boolean</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBoolean(java.lang.String)">getBoolean</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBoolean(int, boolean)">setBoolean</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#CHAR">CHAR</javadoc></cell>
		        <cell><idf>String</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getString(java.lang.String)">getString</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setString(int, java.lang.String)">setString</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#CLOB">CLOB</javadoc></cell>
		        <cell><javadoc to="java/sql/Clob.html">java.sql.Clob</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getClob(java.lang.String)">getClob</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setClob(int, java.sql.Clob)">setClob</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#DATALINK">DATALINK</javadoc></cell>
		        <cell><javadoc to="java/net/URL.html">java.net.URL</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getURL(java.lang.String)">getURL</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setURL(int, java.net.URL)">setURL</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#DATE">DATE</javadoc></cell>
		        <cell><javadoc to="java/sql/Date.html">java.sql.Date</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getDate(java.lang.String)">getDate</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setDate(int, java.sql.Date)">setDate</javadoc>()</cell>
		        <cell>date without time</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#DECIMAL">DECIMAL</javadoc></cell>
		        <cell><javadoc to="java/lang/BigDecimal.html">BigDecimal</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBigDecimal(java.lang.String)">getBigDecimal</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBigDecimal(int, java.lang.BigDecimal)">setBigDecimal</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#DISTINCT">DISTINCT</javadoc></cell>
		        <cell>-</cell>
		        <cell>-</cell>
		        <cell>-</cell>
		        <cell>type depends on definition</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#DOUBLE">DOUBLE</javadoc></cell>
		        <cell><idf>double</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getDouble(java.lang.String)">getDouble</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setDouble(int, double)">setDouble</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#FLOAT">FLOAT</javadoc></cell>
		        <cell><idf>double</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getDouble(java.lang.String)">getDouble</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setDouble(int, double)">setDouble</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#INTEGER">INTEGER</javadoc></cell>
		        <cell><idf>int</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getInt(java.lang.String)">getInt</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setInt(int, int)">setInt</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#INTEGER">JAVA_OBJECT</javadoc></cell>
		        <cell>-</cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getObject(java.lang.String)">getObject</javadoc>()</cell>
		        <cell><javadoc>setObject</javadoc>()</cell>
		        <cell>class depends on definition</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#LONGNVARCHAR">LONGNVARCHAR</javadoc></cell>
		        <cell><idf>String</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getNCharacterStream(java.lang.String)">getNCharacterStream</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setNCharacterStream(int, java.io.Reader)">setNCharacterStream</javadoc>()</cell>
		        <cell>since JDBC 4.0</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#LONGVARBINARY">LONGVARBINARY</javadoc></cell>
		        <cell><idf>byte[]</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBinaryStream(java.lang.String)">getBinaryStream</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBinaryStream(int, java.io.InputStream)">setBinaryStream</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#LONGVARCHAR">LONGVARCHAR</javadoc></cell>
		        <cell><idf>String</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getCharacterStream(java.lang.String)">getCharacterStream</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setCharacterStream(int, java.io.Reader)">setCharacterStream</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#NCHAR">NCHAR</javadoc></cell>
		        <cell><idf>String</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getNString(java.lang.String)">getNString</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setNString(int, java.lang.String)">setNString</javadoc>()</cell>
		        <cell>since JDBC 4.0</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#NCLOB">NCLOB</javadoc></cell>
		        <cell><javadoc to="java/sql/NClob.html">java.sql.NClob</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getNClob(java.lang.String)">getNClob</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setNClob(int, java.sql.Clob)">setNClob</javadoc>()</cell>
		        <cell>since JDBC 4.0</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#NULL">NULL</javadoc></cell>
		        <cell><idf>null</idf></cell>
		        <cell>-</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setNull(int, int)">setNull</javadoc>()</cell>
		        <cell>generic <idf>NULL</idf> value</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#NUMERIC">NUMERIC</javadoc></cell>
		        <cell><javadoc to="java/lang/BigDecimal.html">BigDecimal</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBigDecimal(java.lang.String)">getBigDecimal</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBigDecimal(int, java.lang.BigDecimal)">setBigDecimal</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#NVARCHAR">NVARCHAR</javadoc></cell>
		        <cell><idf>String</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getNString(java.lang.String)">getNString</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setNString(int, java.lang.String)">setNString</javadoc>()</cell>
		        <cell>since JDBC 4.0</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#OTHER">OTHER</javadoc></cell>
		        <cell>-</cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getObject(java.lang.String)">getObject</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setObject(int, java.lang.Object)">setObject</javadoc>()</cell>
		        <cell>for database-specific types</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#REAL">REAL</javadoc></cell>
		        <cell><idf>float</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getFloat(java.lang.String)">getFloat</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setFloat(int, float)">setFloat</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#REF">REF</javadoc></cell>
		        <cell><javadoc to="java/sql/Ref.html">java.sql.Ref</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getRef(java.lang.String)">getRef</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setRef(int, java.sql.Ref)">setRef</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#ROWID">ROWID</javadoc></cell>
		        <cell><javadoc to="java/sql/RowId.html">java.sql.RowId</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getRowId(java.lang.String)">getRowId</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setRowId(int, java.sql.RowId)">setRowId</javadoc>()</cell>
		        <cell>since JDBC 4.0</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#SMALLINT">SMALLINT</javadoc></cell>
		        <cell><idf>short</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getShort(java.lang.String)">getShort</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setShort(int, short)">setShort</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#SQLXML">SQLXML</javadoc></cell>
		        <cell><javadoc to="java/sql/SQLXML.html">java.sql.SQLXML</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getSQLXML(java.lang.String)">getSQLXML</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setSQLXML(int, java.sql.SQLXML)">setSQLXML</javadoc>()</cell>
		        <cell>since JDBC 4.0</cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#STRUCT">STRUCT</javadoc></cell>
		        <cell><javadoc to="java/sql/Struct.html">java.sql.Struct</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getObject(java.lang.String)">getObject</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setObject(int, java.lang.Object)">setObject</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#TIME">TIME</javadoc></cell>
		        <cell><javadoc to="java/sql/Time.html">java.sql.Time</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getTime(java.lang.String)">getTime</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setTime(int, java.sql.Time)">setTime</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#TIMESTAMP">TIMESTAMP</javadoc></cell>
		        <cell><javadoc to="java/sql/Timestamp.html">java.sql.Timestamp</javadoc></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getTimestamp(java.lang.String)">getTimestamp</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setTimestamp(int, java.sql.Time)">setTimestamp</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#TINYINT">TINYINT</javadoc></cell>
		        <cell><idf>byte</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getByte(java.lang.String)">getByte</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setByte(int, short)">setByte</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#VARBINARY">VARBINARY</javadoc></cell>
		        <cell><idf>byte[]</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getBytes(java.lang.String)">getBytes</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setBytes(int, byte[])">setBytes</javadoc>()</cell>
		        <cell></cell>
		    </row>
		    <row>
		        <cell><javadoc to="java/sql/Types.html#VARCHAR">VARCHAR</javadoc></cell>
		        <cell><idf>String</idf></cell>
		        <cell><javadoc to="java/sql/ResultSet.html#getString(java.lang.String)">getString</javadoc>()</cell>
		        <cell><javadoc to="java/sql/PreparedStatement.html#setString(int, java.lang.String)">setString</javadoc>()</cell>
		        <cell></cell>
		    </row>
			</table>
				
			</content>
		</collapsedSubSection>
		
				
		<subSection anchor="todo">
			<head>TODO</head>
			<explanation>
3. How-To...
X CallableStatements / Stored Procudures
X getting auto-generated keys (section 13.6)
X JDBC / Java Datamapping (mapping table)
X Cursors
- Updating a ResultSet
X Reading NULLs
X NULL parameters
X Fetch Sizes
X Batch Updates
X Dates
X Retrieving Blobs
X Sending Blobs (setBinaryStream())
X XML
X Storing Java Objects
X DB Meta Data
X Result Set Meta Data
X structured type
- ref
X distinct types
X array (no support in javadb and mysql, and no direct array support in oracle (only type defs))
- row id
X query timeout
X Rowsets: short description (resultset on dope, offline functionality with sync, xml serialization). Not part of JDBC. Link to tutorial in JDK.
- distributed transactions with EJB (@Transaction; don't change auto-commit mode)
X 4 types of driver classes... http://java.sun.com/products/jdbc/driverdesc.html
X performance (reduce sql statements, optimize sql, indexes, schema, fewer results; reuse prepared statements; use batch mode; set fetch size)
X constructing / escaping SQL

- SVGs are too large, redraw them!

			</explanation>
		</subSection>

		<collapsedSubSection anchor="appservertransactions">
			<head>JEE Transactions</head>
			<summary>How to Use Transactions in an Application Server</summary>
			<content>	
				<explanation>Code running in an application server should not <link anchor="transactions">commit transactions manually</link>,
				but <em>use the container's transaction management</em>. You should not use JDBC's own functions at all<br/>
				With EJB 3.x container-managed transaction management is very convenient. By default, <em>every session bean method runs in a transaction</em>,
				including all methods that the session bean invokes. Methods that require a different behaviour can use the
				<javadoc to="http://download.oracle.com/docs/cd/E17477_01/javaee/5/api/javax/ejb/TransactionAttribute.html">@TransactionAttribute</javadoc>
				attribute to declare this. </explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="autokeys">
			<head>Generated Keys</head>
			<summary>How to Retrieve Generated Values (Auto-Generated Keys)</summary>
			<content>	
				<explanation>When you insert a row into a table, and some of those values are <em>automatically generated</em> (typically identity 
				keys), JDBC allows you to retrieve those values after <em>specifying the <javadoc>Statement.RETURN_GENERATED_KEYS</javadoc></em> option:</explanation>
				
				<code>
				    <line><javadoc>Connection</javadoc> connection = <abstract>...</abstract>;</line>
					<line>String sql = "INSERT INTO Movie(title, budget, releaseDate) VALUES(?, ?, ?)";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc to="java/sql/Connection.html#prepareStatement(java.lang.String, int)">prepareStatement</javadoc>(sql, <em><javadoc>Statement.RETURN_GENERATED_KEYS</javadoc></em>);</line>
					<emptyLine/>
					<line>stmt.<javadoc>setString</javadoc>(1, "Jurassic Park");</line>
					<line>stmt.<javadoc>setBigDecimal</javadoc>(2, new <javadoc>BigDecimal</javadoc>(63000000));</line>
					<line><javadoc>Date</javadoc> june11_93 = new <javadoc>Date</javadoc>(new <javadoc>GregorianCalendar</javadoc>(1993, <javadoc>Calendar.JUNE</javadoc>, 11).<javadoc>getTimeInMillis</javadoc>());</line>
					<line>stmt.<em><javadoc>setDate</javadoc>(3, june11_93)</em>;</line>
					<line>stmt.<javadoc>executeUpdate</javadoc>();</line>
					<emptyLine/>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc><em>getGeneratedKeys</em></javadoc>();<cmt>retrieve keys in <idf>ResultSet</idf></cmt></line>
					<line>if (rs.<javadoc>next</javadoc>())</line>
					<line>    System.out.println("Row created with id="+rs.<javadoc to="java/sql/ResultSet.html#getLong(java.lang.String)"><em>getLong</em></javadoc>(1));</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		
		<collapsedSubSection anchor="userdefinedtypes">
			<head>Java Objects</head>
			<summary>How to Write a Custom-Mapping for User-Defined Types</summary>
			<content>
				<explanation>If you have user-defined types (<annotated ref="doc-composite-type"><title>composite</title></annotated>
				or <annotated id="doc-scalar"><title>scalar</title><explanation>A scalar types consists only of a single value, like a single string or a single
				number. Types that consist of several scalar types are called composite types.</explanation></annotated>), you can <em>write
				your own Java class and declare map it on the user-defined type</em>. If you don't do this, you have to treat them <link anchor="structs">as Struct</link>
				or <link anchor="distinct">as distinct type</link>.</explanation>
				
				<explanation>
					The Java class representing your user-defined type <em>must implement the <javadoc>SQLData</javadoc> interface</em> (mapping a <topic>POJO</topic>
					is not possible) and <em>have a constructor without arguments</em>. <javadoc>SQLData</javadoc> works similar to <topic>serialization</topic>, 
					you read from a stream of JDBC types to create an instance and write to a stream of JDBC types to write it later.
				</explanation>
				<explanation>Here is an Oracle definition of a user-defined type and a table that uses it:</explanation>
				<config><em>CREATE TYPE Encoding</em> AS object (
	encoderName VARCHAR(30),
	pixelLines INT,
	bitrateMbits FLOAT
)

CREATE TABLE MovieEncodings (
  movieRef    int,
  hd <em>VideoEncoding</em>,
  sd <em>VideoEncoding</em>,
  mobile <em>VideoEncoding</em>,
  FOREIGN KEY (movieRef) REFERENCES Movie(id)
)</config>
				<miniHeadline>Writing the Custom Type</miniHeadline>
				<explanation>This class implements <javadoc>SQLData</javadoc> to handle the <idf>VideoEncoding</idf> type:</explanation>
				<code>
					<line>public class VideoEncoding <em>implements <javadoc>SQLData</javadoc></em> {</line>
					<emptyLine/>
					<line>    private String typeName = "VIDEOENCODING";<cmt>default name in capitals<more>This name is needed when you insert 
					an <idf>VideoEncoding</idf> without reading it first. It tells the database what <em>the corresponding user-defined type</em> is. 
					If you only read the object, you don't need to set it.<br/>Oracle requires type names to be capital letters.</more></cmt></line>
					<line>    public String encoderName;<cmt>public only to avoid writing getters</cmt></line>
					<line>    public int pixelLines;</line>
					<line>    public double bitrateMbits;</line>
					<emptyLine/>
					<line>    public <em>VideoEncoding()</em> {<cmt><em>required:</em> constructor without arguments</cmt></line>
					<line>    }</line>
					<emptyLine/>
					<line>    <plainCmt>convenience constructor</plainCmt></line>
					<line>    public VideoEncoding(String encoderName, int pixelLines, double bitrateMbits) {</line>
					<line>        this.encoderName = encoderName;</line>
					<line>        this.pixelLines = pixelLines;</line>
					<line>        this.bitrateMbits = bitrateMbits;</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public String <javadoc to="java/sql/SQLData.html#getSQLTypeName()"><em>getSQLTypeName</em></javadoc>() {</line>
					<line>        return typeName;</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public void <javadoc to="java/sql/SQLData.html#readSQL(java.sql.SQLInput, java.lang.String)"><em>readSQL</em></javadoc>(<javadoc>SQLInput</javadoc> stream, String typeName) throws <javadoc>SQLException</javadoc> {</line>
					<line>        this.typeName = typeName;<cmt>store name for <idf>getSQLTypeName</idf></cmt></line>
					<emptyLine/>
					<line>        encoderName = stream.<javadoc to="java/sql/SQLInput.html#readString()">readString</javadoc>();<cmt>in order of DB declaration</cmt></line>
					<line>        pixelLines = stream.<javadoc to="java/sql/SQLInput.html#readInt()">readInt</javadoc>();</line>
					<line>        bitrateMbits = stream.<javadoc to="java/sql/SQLInput.html#readDouble()">readDouble</javadoc>();</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public void <javadoc to="java/sql/SQLData.html#writeSQL(java.sql.SQLOutput)"><em>writeSQL</em></javadoc>(<javadoc>SQLOutput</javadoc> stream) throws <javadoc>SQLException</javadoc> {</line>
					<line>        stream.<javadoc to="java/sql/SQLOutput.html#writeString(java.lang.String)">writeString</javadoc>(encoderName);</line>
					<line>        stream.<javadoc to="java/sql/SQLOutput.html#writeInt(java.lang.String)">writeString</javadoc>(pixelLines);</line>
					<line>        stream.<javadoc to="java/sql/SQLOutput.html#writeDouble(java.lang.String)">writeString</javadoc>(bitrateMbits);</line>
					<line>    }</line>
					<line>}</line>
				</code>
				
				<miniHeadline>SQLData Types as Parameters</miniHeadline>
				<explanation>
					<javadoc>SQLData</javadoc>-based types can be set as parameters using <javadoc>setObject</javadoc>: 
				</explanation>
				<code>
				    <line><javadoc>Connection</javadoc> connection = <abstract>...</abstract>;</line>
					<line>String sql = "INSERT INTO MovieEncodings(movieRef, hd, sd, mobile) VALUES(1, ?, ?, ?)";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<emptyLine/>
					<line>VideoEncoding hd = new VideoEncoding("MPEG2", 1080, 20);</line>
					<line>stmt.<javadoc><em>setObject</em></javadoc>(1, hd);<cmt>use <idf>Object</idf> accessors for custom types</cmt></line>
					<emptyLine/>
					<line>VideoEncoding sd = new VideoEncoding("H264", 640, 1.5);</line>
					<line>stmt.<javadoc><em>setObject</em></javadoc>(2, sd);</line>
					<emptyLine/>
					<line>VideoEncoding mobile = new VideoEncoding("3GP", 200, 0.02);</line>
					<line>stmt.<javadoc><em>setObject</em></javadoc>(3, mobile);</line>
					<emptyLine/>
					<line>stmt.<javadoc>executeUpdate</javadoc>();</line>
				</code>
				
				<miniHeadline>Reading SQLData Types</miniHeadline>
				<explanation>Before you can read a <javadoc>SQLData</javadoc>-based type you need to <em>add your class to the type map</em>.
				After that you can <em>read it using <javadoc>getObject</javadoc></em>: </explanation>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<emptyLine/>
					<line><plainCmt>Add mapping class to type map</plainCmt></line>
					<line>Map&lt;String,Class&lt;?>> typeMap = connection.<javadoc to="java/sql/Connection.html#getTypeMap()"><em>getTypeMap</em></javadoc>();</line>
					<line>typeMap.put("<em>VIDEOENCODING</em>", <em>VideoEncoding.class</em>);<cmt>upper case required for Oracle</cmt></line>
					<line>connection.<javadoc to="java/sql/Connection.html#setTypeMap(java.util.Map)"><em>setTypeMap</em></javadoc>(typeMap);</line>
					<emptyLine/>
					<line>String sql = "SELECT hd FROM MovieEncodings WHERE movieRef=1";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    <javadoc><em>VideoEncoding</em></javadoc> hdEncoding = <javadoc><em>(VideoEncoding) rs.getObject</em></javadoc>("hd");</line>
					<emptyLine/>
					<line>    System.out.printf("Encoder: %s Lines: %s bitrate: %s Mbit/s\n", </line>
					<line>                      hdEncoding.encoderName, hdEncoding.pixelLines, hdEncoding.bitrateMbits);</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="distinct">
			<head>Distinct</head>
			<summary>How to Handle Scalar User-Defined Types (Distinct)?</summary>
			<content>
				<explanation><em>User-defined types that are based on a single basic type</em>, like a string restricted to 20 characters, are called 
				<javadoc to="java/sql/Types.html#DISTINCT"><em>DISTINCT</em></javadoc> in JDBC. For example, this statement creates a 
				5-character string type called 'MPAARating' in PostgreSQL:</explanation>
				<config>CREATE DOMAIN MPAARating AS VARCHAR(5) DEFAULT 'NR'
</config>
				<explanation>Distinct types are handled exactly <em>like their underlying basic type</em>. Let's assume the following table definition:</explanation>
				<config>CREATE TABLE MovieRating (
  movieRef    int,
  version VARCHAR(50),
  rating <em>MPAARating</em>,
  FOREIGN KEY (movieRef) REFERENCES Movie(id)
)</config>
				<explanation>Then you can read the <idf>rating</idf> column from a <javadoc>ResultSet</javadoc> like this:</explanation>
				<code>
					<line>String rating = rs.<javadoc><em>getString</em></javadoc>("rating");</line>
				</code>
				<explanation>Similarly, to set a distinct type as parameter you only need to call <javadoc>setString</javadoc> on the <javadoc>PreparedStatement</javadoc>.</explanation>
			</content>
							
		</collapsedSubSection>
		
		<collapsedSubSection anchor="structs">
			<head>Structs</head>
			<summary>How to Read Composite Types (Structs)</summary>
			<content>	
				<explanation>The <javadoc>Struct</javadoc> interface is used to <em>represent <annotated id="doc-composite-type"><title>composite types</title><explanation>A composite types
				is a type that consists of several other basic data types (such as numbers and strings), similar to a <idf>struct</idf> in C or a class with only 
				fields (and no methods) in Java. In SQL databases composite types are usually user-defined.</explanation></annotated></em>. Here is a Oracle definition
				for a composite type <idf>Encoding</idf> as well as a table that uses it (neither JavaDB nor PostgreSQL support <javadoc>Struct</javadoc>):
				</explanation>
				<config><em>CREATE TYPE Encoding</em> AS object (
	encoderName VARCHAR(30),
	pixelLines INT,
	bitrateMbits FLOAT
)

CREATE TABLE MovieEncodings (
  movieRef    int,
  hd <em>Encoding</em>,
  sd <em>Encoding</em>,
  mobile <em>Encoding</em>,
  FOREIGN KEY (movieRef) REFERENCES Movie(id)
)</config>
				<miniHeadline>Creating Struct Parameters</miniHeadline>
				<explanation><em>Since JDBC 4.0</em> you can create a <javadoc>Struct</javadoc> from a <javadoc>Connection</javadoc> using <javadoc>createStruct</javadoc>.
				In JDBC 3.0 you had to resort to driver-specific ways to do this, if possible at all.</explanation>
				<code>
				    <line><javadoc>Connection</javadoc> connection = <abstract>...</abstract>;</line>
					<line>String sql = "INSERT INTO MovieEncodings(movieRef, hd, sd, mobile) VALUES(1, ?, ?, ?)";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<emptyLine/>
					<line>Object[] hdVals = new Object[] {"MPEG2", 1080, 20.0};<cmt>values <em>declaration order</em><more>It is important here that the 
values must be exactly in the order they have been declared. The types must also be compatible to the JDBC types</more></cmt></line>
					<line>Struct hd = connection.<javadoc><em>createStruct</em></javadoc>("ENCODING", hdVals);<cmt><em>upper case</em> for Oracle <more>While Oracle is usually 
not case-sensitive, it is for user-defined types and requires you to use upper case (even if you defined the type with lower-case characters).</more></cmt></line>
					<line>stmt.<javadoc><em>setObject</em></javadoc>(1, hd);<cmt>use <idf>Object</idf> accessors for <idf>Struct</idf></cmt></line>
					<emptyLine/>
					<line>Object[] sdVals = new Object[] {"H264", 640, 1.5;</line>
					<line>Struct sd = connection.<javadoc><em>createStruct</em></javadoc>("ENCODING", sdVals);</line>
					<line>stmt.<javadoc><em>setObject</em></javadoc>(2, sd);</line>
					<emptyLine/>
					<line>Object[] mobileVals = new Object[] {"3GP", 200, 0.02};</line>
					<line>Struct mobile = connection.<javadoc><em>createStruct</em></javadoc>("ENCODING", mobileVals);</line>
					<line>stmt.<javadoc><em>setObject</em></javadoc>(3, mobile);</line>
					<emptyLine/>
					<line>stmt.<javadoc>executeUpdate</javadoc>();</line>
				</code>
				
				<miniHeadline>Reading Struct Values</miniHeadline>
				<code>
					<line><javadoc>Connection</javadoc> connection = <abstract>...</abstract> ;</line>
					<line>String sql = "SELECT hd FROM MovieEncodings WHERE movieRef=1";</line>
					<line><javadoc>PreparedStatement</javadoc> stmt = connection.<javadoc>prepareStatement</javadoc>(sql);</line>
					<line><javadoc>ResultSet</javadoc> rs = stmt.<javadoc>executeQuery</javadoc>();</line>
					<emptyLine/>
					<line>while (rs.<javadoc>next</javadoc>()) {</line>
					<line>    <javadoc><em>Struct</em></javadoc> hdEncoding = <javadoc><em>(Struct) rs.getObject</em></javadoc>("hd");<cmt>use <idf>getObject</idf> to get <idf>Struct</idf></cmt></line>
					<line>    Object[] hdValues = hdEncoding.<javadoc><em>getAttributes</em></javadoc>();<cmt>values in declaration order</cmt></line>
					<emptyLine/>
					<line>    String encoderName = (String) hdValues[0];</line>
					<line>    <javadoc>BigDecimal</javadoc> pixelLines = (<javadoc>BigDecimal</javadoc>) hdValues[1];</line>
					<line>    <javadoc>BigDecimal</javadoc> bitrateMbits = (<javadoc>BigDecimal</javadoc>) hdValues[2];</line>
					<line>    System.out.printf("Encoder: %s Lines: %s bitrate: %s Mbit/s\n", </line>
					<line>                      encoderName, pixelLines, bitrateMbits);</line>
					<line>}</line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="nullparameters">
			<head>Null Parameters</head>
			<summary>How to Set Parameters to NULL</summary>
			<content>
				<explanation>There are several ways to set a <javadoc>PreparedStatement</javadoc>'s parameter to <idf>NULL</idf>, depending on the
				parameter's type:</explanation>
				<list>
					<li>For Java reference types (like <idf>String</idf>, <javadoc>Time</javadoc> or <javadoc>Date</javadoc>), just <em>invoke the
					setter with <idf>null</idf></em>.</li>
					<li>All regular JDBC types can be set to null using <em><javadoc to="java/sql/PreparedStatement.html#setNull(int, int)">setNull</javadoc></em>.</li>
					<li>Custom types created by the user need the three-argument version of
					<javadoc to="java/sql/PreparedStatement.html#setNull(int, int, java.lang.String)">setNull</javadoc> to specify the name of the custom type.</li>
				</list>
				<explanation>The following example sets a string and an integer to null:</explanation>
				<code>
					<line><javadoc>PreparedStatement</javadoc> stmt = <abstract>...</abstract>;</line>
					<line>stmt.<javadoc>setString</javadoc>(1, <em>null</em>);<cmt>set <idf>String</idf>-based type to <idf>NULL</idf></cmt></line>
					<line>stmt.<javadoc to="java/sql/PreparedStatement.html#setNull(int, int)"><em>setNull</em></javadoc>(2, <javadoc to="java/sql/Types.html#INTEGER"><em>Types.INTEGER</em></javadoc>); <cmt>set <idf>INTEGER</idf> to <idf>NULL</idf></cmt></line>
				</code>
				<explanation></explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="wrapper">
			<head>Wrappers</head>
			<summary>How to Access Driver Classes When the Application Server Wraps Them</summary>
			<content>
			
				<explanation>
				    JDBC defines interfaces (such as <javadoc>Connection</javadoc> and <javadoc>Statement</javadoc>) whose
				    implementations will be provided by the JDBC drivers. Most <em>JDBC drivers extend those
				    interfaces</em> and offer additional methods for driver-specific features. In order to access
				    those methods, you need to <em>cast to the driver's own class</em> or interface.  
				</explanation> 
				<explanation>
				    Many <em>application servers wrap the JDBC driver's implementations</em> to add additional features. However,
				    this means that you get the application server's classes and can not cast to driver classes anymore, and
				    thus will not be able to access any driver-specific features. 
				</explanation>
				<explanation>
					<em>Since JDBC 4.0 many JDBC interfaces extend the <javadoc>Wrapper</javadoc> interface</em> to solve this problem.
					<javadoc>Wrapper</javadoc> allows you to <em>get a wrapped implementation</em>, even if it has been wrapped multiple times.
					You can search for implementation classes as well as any interfaces that they implement. The following example tries to get 
					a <javadoc>Connection</javadoc> that implements PostgreSQL's <idf>PGConnection</idf> interface:
				</explanation> 
				<code>
				    <line><javadoc>Connection</javadoc> connection = <abstract>...</abstract>;</line>
				    <line>if (stmt.<javadoc to="java/sql/Wrapper.html#isWrapperFor(java.lang.Class)"><em>isWrapperFor</em></javadoc>(org.postgresql.PGConnection.class))<cmt>is <idf>PGConnection</idf> available?</cmt></line>
				    <line>    PGConnection pgcon = (PGConnection) stmt.<javadoc to="java/sql/Wrapper.html#unwrap(java.lang.Class)"><em>unwrap</em></javadoc>(org.postgresql.PGConnection.class);</line>
				    <line>    Fastpath fp = pgcon.getFastpathAPI();<cmt>PostgreSQL-specific feature</cmt></line>
				    <line>    <plainCmt><abstract>...</abstract></plainCmt></line>
				    <line>}</line>
				</code>
				<explanation>There is no interoperable way of getting the driver's original classes in JDBC 3.0  Some application servers or wrappers may offer extensions to get them though.</explanation>
			</content>
		</collapsedSubSection>
		
	</singleColumnSection>
	
	
	<singleColumnSection anchor="andnow">
		<head>And now...?</head>
		<subSection anchor="nextsteps">
			<head>Next Steps</head>
			<explanation>This tutorial intends to give you a quick start on using JDBC, and maybe give answers for some questions
			that are hard to figure out on your own. But now you are on you own. If you need to find out more, try to find
			it in the <link to="http://java.sun.com/javase/6/docs/api/java/sql/package-summary.html">API documentation</link>.
			For a more thorough understanding of JDBC you should take the time to read 
			the <link to="http://jcp.org/en/jsr/summary?id=221">JDBC Specification</link>.
			 </explanation>
		</subSection>
	</singleColumnSection>
  </body>
  
  <sidebar>
    	<box>
  		<title>Useful Links</title>
  		<content>
  			<link to="http://java.sun.com/javase/technologies/database/">JDBC Homepage</link><br/>
  			<link to="http://en.wikipedia.org/wiki/Java_Database_Connectivity">JDBC on Wikipedia</link><br/>
  			<link to="http://java.sun.com/javase/6/docs/api/java/sql/package-summary.html">java.sql API Docs</link><br/>
  			<link to="http://java.sun.com/javase/6/docs/api/javax/sql/package-summary.html">javax.sql API Docs</link><br/>
  			<link to="http://jcp.org/aboutJava/communityprocess/final/jsr221/index.html">JDBC 4.0 Specification</link><br/>
  		</content>
  	</box>
  </sidebar>
  </article>
</page>


