<?xml version="1.0" encoding="UTF-8"?>
<page xmlns="http://tjansen.de/refPage" 
	xmlns:inc="http://tjansen.de/refPageInclude" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://tjansen.de/refPage ../../../schemas/page.xsd 
	                    http://tjansen.de/refPageInclude ../../../schemas/include.xsd">  
	
  <path>/guide/jaxb/</path>                    
  <title>JAXB Guide</title>
  <titleIntro>Read, modify and write XML documents with JAXB 2.1 or 2.2</titleIntro>
  
  <license>cc-by-free-src</license>
  
  <multipage/>
  
  <topicConfig>
	<inc:includeContent file="../srcContent/shared/topics.inc.xml"/>
  </topicConfig>
  
  <javadocConfig>
  	<baseURL>http://java.sun.com/javase/6/docs/api/</baseURL>
  	<defaultPackage>javax.xml.bind</defaultPackage>
  	<defaultAnnotationPackage>javax.xml.bind.annotation</defaultAnnotationPackage>
  </javadocConfig>

  <article>
  <body>
	<singleColumnSection anchor="jaxboverview">
		<head>Overview</head>
		<subSection anchor="intro">
			<head>Intro</head>
			<explanation>JAXB allows you to <em>access XML documents like regular Java classes</em>. It only works for
			documents that follow a <em>fixed structure</em> that can be described by a schema, a DTD or by a tree of Java classes.<br/>
			The easiest way to use JAXB is with a <topic>XML Schema</topic> (XSD file). You can then just <em>compile 
			the schema</em> using 
			<annotated id="doc-xjc"><title>xjc</title><explanation><idf>xjc</idf> is a compiler that takes a XML schema and 
			generates annotated Java classes that represent this schema. You can find <idf>xjc</idf> in your 
			JDK's <idf>bin</idf> directory since JDK6.</explanation></annotated>.
			<idf>xjc</idf> generates <em>annotated Java classes</em> that you use to read and write the XML.
			Alternatively, you write your data structures as Java classes yourself and <em>use 
			annotations</em> to map them onto the XML structure. An <em>XML schema is not needed</em> for this approach,
			but you can generate one from your code using the
			<annotated id="doc-schemagen"><title>schemagen</title><explanation><idf>schemagen</idf> takes Java classes
			with JAXB's annotations and generates an XML schema for them. This is useful if you
			want to use the XML document in other applications. You can find <idf>schemagen</idf> in your 
			JDK's <idf>bin</idf> directory (since JDK6).</explanation></annotated> tool. <br/>
			Once you have the annotated classes, JAXB can read XML documents and create object trees that
			represents them (this is called <em>unmarshalling</em>) and write them back into an XML document
			(<em>marshalling</em>). The object tree itself can be created, read and modified like
			any other Java object.
			</explanation>
		</subSection>
		<collapsedSubSection anchor="usecases">
			<head>Use Cases</head>
			<summary>When should JAXB be used?</summary>
			<content>
			<explanation>Use JAXB when..</explanation>
			<list>
				<li>you want to easily read or write XML documents with a <em>specific schema</em></li>
				<li>the documents are mainly structured data, <em>not markup text</em> (e.g. no XHTML or DocBook)</li>
				<li>throughput and performance is not your primary concern</li>
			</list>
			
			<miniHeadline>Alternatives</miniHeadline>
			<list>
				<li><link to="http://en.wikipedia.org/wiki/Document_Object_Model">DOM</link> provides a flexible object model that allows you to read and write any XML document. However, if your document has a known schema, using JAXB will be easier and less error-prone than the generic DOM model.</li>
				<li><link to="http://en.wikipedia.org/wiki/StAX">StAX</link> is a low-level pull API for reading any XML. It is fast and flexible, but also complicated to use and parsing a specific schema is hard to get right.</li>
				<li><link to="http://en.wikipedia.org/wiki/Simple_API_for_XML">SaX</link> is a very old push XML API. Is is quite fast, but very difficult to use correctly. Avoid if possible.</li>
				<li>There are several XML APIs that are not part of any Java Edition. None of them is in wide-spread use anymore, even though they may have advantages over Java's APIs.</li>
			</list>
			</content>
		</collapsedSubSection>
		<collapsedSubSection anchor="requirements">
			<head>Requirements</head>
			<summary>What do you need for JAXB?</summary>
			<content>
				<explanation>For JAXB 2.x...</explanation>
				<list>
					<li><em>Java SE 6</em> (or higher) <em>ships</em> with JAXB 2.x</li>
					<li><em>Java EE 5</em> (or higher) <em>ships</em> with JAXB 2.x</li>
					<li>JAXB for Java SE 5 can be downloaded <link to="http://jaxb.dev.java.net/">here</link></li>
					<li>JAXB 2.x can not be used for versions &lt; Java 5</li>
				</list>
			</content>
		</collapsedSubSection>
	</singleColumnSection>
	
	<singleColumnSection anchor="mappingclasses">
		<head>Mapping Classes</head>
		<subSection anchor="schemafirst">
			<head>Schema first?</head>
			<explanation>
				In case you don't already have a schema, you need to ask yourself whether you want to <em>write the XML Schema first</em>
				and generate classes for it using <annotated ref="doc-xjc"/>, or whether you want to <em>write the Java classes with JAXB
				annotations</em>, and optionally generate the XML Schema later using <annotated ref="doc-schemagen"/>.</explanation>
				<list>
				<li>If you just want to serialize some data in XML, and don't really care too much what the XML looks like,
				write the definitions in Java. It's usually more convenient and the resulting Java classes are simpler and easier to use. This is called
				<em>bottom-up design</em>.</li>
				<li>If you care about the XML Schema (e.g. you want to publish it), write the Schema first and use <idf>xjc</idf>. 
				This makes it a lot easier to have a good XML schema. This is called <em>top-down design</em></li>	
				</list>
		</subSection>
		<subSection anchor="xjc">
			<head>xjc</head>
			<explanation>
			If you have a schema, you can use <annotated ref="doc-xjc"/> on the command line to get the classes that you need. 
			<idf>xjc</idf> is included with both JDK6 and the JAXB reference implementation. Usage:</explanation>
			<console>> xjc -d <annotated><title>target-directory</title>
			<explanation>The path of the directory to store the generated source in.</explanation></annotated> -p <annotated><title>your.package.name</title>
			<explanation>The package name for the Java code to generate. If you don't specify the <idf>-p</idf> option, <idf>xjc</idf> will try to derive a package name
			from the XML Schema's namespace URI.</explanation></annotated> <annotated><title>path-to-schema</title>
			<explanation>The path to the XML schema you want to compile. You can specify more than one schema. If this is a directory, 
			all schemas in the directory will be compiled.</explanation></annotated></console>
		</subSection>
		<subSection anchor="propertybased">
			<head>Property-based Beans</head>
			<more>JAXB uses plain Java beans to represent the XML document. Data can be either stored in properties, as shown in this section,
			or in public fields.<br/>In order to map the bean onto a specific XML schema, it
			supports a large number of annotations to give you full control over the XML that will be generated. 
			However, if the exact XML layout is a concern for you (e.g. whether a field will be stored as an attribute or
			as an element), you are usually better off writing the XML Schema first and use <idf>xjc</idf>.</more>
			<code>
				<line>package com.jarfiller.example;</line>
				<line>import java.util.*;</line>
				<line>import <javadoc to="javax/xml/bind/annotation/XmlRootElement.html">javax.xml.bind.annotation.XmlRootElement</javadoc>;</line>
				<emptyLine/>
				<line><em><javadoc>@XmlRootElement</javadoc></em></line>
				<line>public class MovieLibrary {<cmt>root element</cmt></line>
				<line>  private List&lt;Movie> collection;</line>
				<emptyLine/>
				<line>  public MovieLibrary() {<cmt><em>no-arg constructor required</em> <more id="more-no-arg-ctor">Every serializable element needs a <idf>public</idf> constructor without
				arguments that JAXB can use to create new instances. You are free to add additional constructors, of course.</more></cmt></line>
				<line>  }</line>
				<emptyLine/>
				<line>  public MovieLibrary(List&lt;Movie> collection) {<cmt>convenience constructor</cmt></line>
				<line>    this.collection = collection;</line>
				<line>  }</line>
				<emptyLine/>
				<line>  public void setCollection(List&lt;Movie> collection) {</line>
				<line>    this.collection = collection;</line>
				<line>  }</line>
				<line>  public List&lt;Movie> getCollection() {</line>
				<line>    return collection;</line>
				<line>  }</line>
				<line>}</line>
				<emptyLine/>
				<line>public class Movie {<cmt>normal element - <em>annotations are optional</em></cmt></line>
				<line>  private String title;</line>
				<line>  private int releaseYear;</line>
				<emptyLine/>				
				<line>  public Movie() {<cmt><em>no-arg constructor required</em> <more ref="more-no-arg-ctor"/></cmt></line>
				<line>  }</line>
				<emptyLine/>
				<line>  public Movie(String title, int releaseYear) {</line>
				<line>    this.title = title;</line>
				<line>    this.releaseYear = releaseYear;</line>
				<line>  }</line>
				<emptyLine/>
				<line>  public String getTitle() {</line>
				<line>    return title;</line>
				<line>  }</line>
				<line>  public void setTitle(String title) {</line>
				<line>    this.title = title;</line>
				<line>  }</line>
				<emptyLine/>
				<line>  public int getReleaseYear() {</line>
				<line>    return releaseYear;</line>
				<line>  }</line>
				<line>  public void setReleaseYear(int releaseYear) {</line>
				<line>    this.releaseYear = releaseYear;</line>
				<line>  }</line>
				<line>}</line>		
			</code>
		</subSection>
		<subSection anchor="fieldbased">
			<head>Field-based beans</head>
			<more>In JAXB, you can either use bean properties or public fields for you data. You can also mix both of them. The created 
				XML will always be the same.<br/>
				You can override the automatic creation of elements for both types of members using 
				the <idf>@XmlAccessorType</idf> annotation.</more>
			<explanation>Shorter alternative: just <em>use public fields</em>. The following classes would create exactly the same XML as the property-based bean above:</explanation>
			<code>
				<line><javadoc>@XmlRootElement</javadoc></line>
				<line>public class MovieLibrary {</line>
				<line>  public List&lt;Movie> collection;</line>
				<line>}</line>
				<emptyLine/>
				<line>public class Movie {</line>
				<line>  public String title;</line>
				<line>  public int releaseYear;</line>
				<line>}</line>		
			</code>
		</subSection>
		<subSection anchor="exampleschema">
			<head>XML Schema</head>
			<explanation>This is the <topic>XML Schema</topic> that the <em><annotated ref="doc-schemagen"/> tool will create</em>, given the <idf>MovieLibrary</idf> class:</explanation>
			<code>
				<line>&lt;xs:schema version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema"></line>
				<emptyLine/>
				<line>  &lt;xs:complexType name="movieLibrary"></line>
				<line>    &lt;xs:sequence></line>
				<line>      &lt;xs:element name="collection" type="movie" nillable="true"</line>
				<line>                     minOccurs="0" maxOccurs="unbounded"/></line>
				<line>    &lt;/xs:sequence></line>
				<line>  &lt;/xs:complexType></line>
				<emptyLine/>
				<line>  &lt;xs:complexType name="movie"></line>
				<line>    &lt;xs:sequence></line>
				<line>      &lt;xs:element name="title" type="xs:string" minOccurs="0"/></line>
				<line>      &lt;xs:element name="releaseYear" type="xs:int"/></line>
				<line>    &lt;/xs:sequence></line>
				<line>  &lt;/xs:complexType></line>
				<line>&lt;/xs:schema></line>
			</code>
			<explanation>Be careful with <idf>schemagen</idf>-generated schemas though: as in this example, they do not declare a top-level element. You may need to add it yourself:</explanation>
			<code>
				<line>&lt;xs:element name="movieLibrary" type="movieLibrary"/></line>
			</code>
		</subSection>
	</singleColumnSection>

	<singleColumnSection anchor="readingandwriting">
		<head>Reading and Writing XML</head>
		<subSection anchor="writingxml">
			<head>Writing XML</head>
			<more>Since JAXB 2.1, serializing your Java class tree into a XML document is really simple. Just
			call the static <idf>marshal</idf> method and you're done.<br/>
			Only in more complicated scenarios you will need to create <javadoc>JAXBContext</javadoc> and <javadoc>Marshaller</javadoc> separately.
			This will be shown in the How-To sections below.
			</more>
			<code>
				<line>List&lt;Movie> movies = new java.util.ArrayList&lt;Movie>();</line>
				<line>movies.add(new Movie("Casablanca", 1942));</line>
				<line>movies.add(new Movie("Dr Zhivago", 1965));</line>
				<line>movies.add(new Movie("Out of Africa", 1985));</line>
				<line>MovieLibrary library = new MovieLibrary(movies);</line>
				<emptyLine/>
				<line><em><javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.File)">JAXB.marshal</javadoc></em>(library, new File("/tmp/library.xml"));<cmt>write XML <more>
					The <idf>marshal</idf> method writes the XML structure represented by the first argument 
					into the given file or stream. It is a short cut added in JAXB 2.1 that replaces
					the complicated setup mechanism of older versions. 
				</more></cmt></line>
				<emptyLine/>
			</code>
		</subSection>
		<subSection anchor="writingxmlresult">
			<head>Result</head>
			<explanation>Result of the previous code snippet:</explanation>
			<code>
				<line>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></line>
				<line>&lt;movieLibrary></line>
				<line>    &lt;collection></line>
				<line>        &lt;name>Casablanca&lt;/name></line>
				<line>        &lt;releaseYear>1942&lt;/releaseYear></line>
				<line>    &lt;/collection></line>
				<line>    &lt;collection></line>
				<line>        &lt;name>Dr Zhivago&lt;/name></line>
				<line>        &lt;releaseYear>1965&lt;/releaseYear></line>
				<line>    &lt;/collection></line>
				<line>    &lt;collection></line>
				<line>        &lt;name>Out of Africa&lt;/name></line>
				<line>        &lt;releaseYear>1985&lt;/releaseYear></line>
				<line>    &lt;/collection></line>
				<line>&lt;/movieLibrary></line>
			</code>
		</subSection>
		<subSection anchor="readingxml">
			<head>Reading XML</head>
			<more>Since JAXB 2.1, reading the XML document is as simple as writing. Just
			call the static <idf>marshal</idf> method and you're done.<br/>
			Only in more complicated scenarios you will need to create <javadoc>JAXBContext</javadoc> and <javadoc>Unmarshaller</javadoc> separately.
			This will be shown in the How-To sections below.
			</more>
			<code>
				<line>MovieLibrary library = <em><javadoc to="javax/xml/bind/JAXB.html#unmarshal(java.io.File, java.lang.Class)">JAXB.unmarshal</javadoc></em>(new File("/tmp/library.xml"), </line>
				<line>                               MovieLibrary.class);<cmt>read XML <more>
					The <idf>unmarshal</idf> method reads the XML structure represented by the first argument will
					and creates an object tree using the class specified in the second argument. 
					It is a short cut added since JAXB 2.1 that replaces the complicated setup mechanism of older versions.
				</more></cmt></line>
				<emptyLine/>
				<line>assert library.getCollection().size() == 3;</line>
				<line>assert library.getCollection().get(0).getTitle().equals("Casablanca");</line>
				<line>assert library.getCollection().get(2).getReleaseYear() == 1985;</line>
			</code>
		</subSection>
		<subSection anchor="supportedtypes">
			<head>Supported Types</head>
			<more>The Java types in this section's tables can be translated directly into corresponding XML types. You do not need
			to convert them manually. All other types are treated as beans by default. Alternatively you could also write an 
			<javadoc to="javax/xml/bind/annotation/adapters/XmlAdapter.html">@XmlAdapter</javadoc> to map
			a type and declare it with a <javadoc to="javax/xml/bind/annotation/adapters/XmlJavaTypeAdapter.html">@XmlJavaTypeAdapter</javadoc> annotation.</more>
			<explanation>Beside beans, JAXB supports the following types natively. Each of them can also be used either as element content or for XML attributes:</explanation>
			<table>
				<head><cell>Java type</cell><cell>XML Simple Schema type</cell></head>
				<row><cell><idf>java.lang.String</idf></cell><cell>xs:string</cell></row>
				<row><cell><idf>int</idf></cell><cell>xs:int</cell></row>
				<row><cell><idf>long</idf></cell><cell>xs:long</cell></row>
				<row><cell><idf>boolean</idf></cell><cell>xs:boolean</cell></row>
				<row><cell><idf>byte</idf></cell><cell>xs:byte</cell></row>
				<row><cell><idf>short</idf></cell><cell>xs:short</cell></row>
				<row><cell><idf>float</idf></cell><cell>xs:float</cell></row>
				<row><cell><idf>double</idf></cell><cell>xs:double</cell></row>
				<row><cell><idf>byte[]</idf></cell><cell>xs:base64Binary</cell></row>
				<row><cell><idf>java.math.BigInteger</idf></cell><cell>xs:integer</cell></row>
				<row><cell><idf>java.math.BigDecimal</idf></cell><cell>xs:decimal</cell></row>
				<row><cell><idf>java.util.Date</idf></cell><cell>xs:dateTime</cell></row>
				<row><cell><javadoc to="javax/xml/namespace/QName.html">javax.xml.namespace.QName</javadoc></cell><cell>xs:QName</cell></row>
				<row><cell><javadoc to="javax/xml/datatype/Duration.html">javax.xml.datatype.Duration</javadoc></cell><cell>xs:duration</cell></row>
			</table>
			<explanation>
			Collections are also supported by JAXB and can be used as element content:</explanation>
			<table>
				<head><cell>Java type</cell><cell>XML Mapping</cell></head>
				<row><cell>Arrays, single dimension</cell><cell>Repeats the element several times, sets <idf>maxOccurs</idf> in the
				schema to <idf>unbounded</idf>  (except <idf>byte[]</idf>, see above).</cell></row>
				<row><cell>Arrays, multi dimension</cell><cell>For the first dimension, the item is repeated (<idf>maxOccurs</idf> in the
				schema set to <idf>unbounded</idf>). For additional dimensions, there is a repeating element <idf>item</idf> defined that will be nested.</cell></row>
				<row><cell><idf>java.util.Collection</idf> (includes <idf>List</idf> and <idf>Set</idf>)</cell><cell>Repeats the element several times, sets <idf>maxOccurs</idf> in the
				schema to <idf>unbounded</idf> (like one-dimensional arrays).</cell></row>
				<row><cell><idf>java.util.Map</idf></cell><cell>The element contains an <idf>entry</idf> element for each Map entry (<idf>maxOccurs</idf> in the
				schema set to <idf>unbounded</idf>), each <idf>entry</idf> containing a <idf>key</idf> and a <idf>value</idf> element.</cell></row>
			</table>
		</subSection>
	</singleColumnSection>
	
	
	<singleColumnSection anchor="howtomapping" multipage="true">
		<head>How to... Mapping</head>
		<collapsedSubSection anchor="namespaces">
			<head>Namespaces</head>
			<summary>How to Use XML Namespaces</summary>
			<content>
				<explanation>To declare an XML namespace at the Java package level, create a file called <idf>package-info.java</idf> in the 
				package's directory and declare the namespace using the <javadoc>@XmlSchema</javadoc> annotation like this 
				(no <idf>class</idf> declaration needed):</explanation>
				<code>
					<line><javadoc>@javax.xml.bind.annotation.XmlSchema</javadoc>(<em><javadoc to="javax/xml/bind/annotation/XmlSchema.html#namespace()">namespace</javadoc>="http://example.jarfiller.com"</em>)</line>
					<line>package com.jarfiller.example;</line>
				</code>
				<explanation>Alternatively, you can also declare the schema separately for each class as well as for the XML 
				root element:
				</explanation>
				<code>
					<line><javadoc>@XmlRootElement</javadoc>(<em><javadoc to="javax/xml/bind/annotation/XmlRootElement.html#namespace()">namespace</javadoc>="http://example.jarfiller.com"</em>)</line>
					<line><javadoc>@XmlType</javadoc>(<em><javadoc to="javax/xml/bind/annotation/XmlType.html#namespace()">namespace</javadoc>="http://example.jarfiller.com"</em>)</line>
					<line>public class MovieLibrary {</line>
					<line>  public List&lt;Movie> collection;</line>
					<line>}</line>
					<emptyLine/>
					<line><javadoc>@XmlType</javadoc>(<em><javadoc to="javax/xml/bind/annotation/XmlType.html#namespace()">namespace</javadoc>="http://example.jarfiller.com"</em>)</line>
					<line>public class Movie {</line>
					<line>    public String title;</line>
					<line>    public int releaseYear;</line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="attributes">
			<head>Attributes</head>
			<summary>How to Declare XML Attributes</summary>
			<content>
				<explanation>With the annotation <javadoc>@XmlAttribute</javadoc> you can declare that a bean's property or field is represented by an attribute instead 
				of by an element. Example (with properties):</explanation>
				<code>
					<line>public class Movie {</line>
					<line>    private String title;</line>
					<line>    private int releaseYear;</line>
					<emptyLine/>
					<line>    <em><javadoc>@XmlAttribute</javadoc></em></line>
					<line>    public String getTitle() {</line>
					<line>        return title;</line>
					<line>    }</line>
					<line>    public void setTitle(String title) {</line>
					<line>        this.title = title;</line>
					<line>    }</line>
					<emptyLine/>
					<line>    <em><javadoc>@XmlAttribute</javadoc></em></line>
					<line>    public int getReleaseYear() {</line>
					<line>        return releaseYear;</line>
					<line>    }</line>
					<line>    public void setReleaseYear(int releaseYear) {</line>
					<line>        this.releaseYear = releaseYear;</line>
					<line>    }</line>
					<line>}</line>
				</code>
				<explanation>Resulting <topic>XML Schema</topic> fragment:
				</explanation>
				<code>
					<line>&lt;xs:complexType name="movie"></line>
					<line>    &lt;xs:sequence/></line>
					<line>    &lt;xs:attribute name="releaseYear" type="xs:int" use="required"/></line>
					<line>    &lt;xs:attribute name="title" type="xs:string"/></line>
					<line>&lt;/xs:complexType></line>
				</code>
				<explanation>Example XML fragment:
				</explanation>
				<code>
					<line>&lt;ns2:movieLibrary xmlns:ns2="http://example.jarfiller.com"></line>
					<line>    &lt;collection title="Casablanca" releaseYear="1942" /></line>
					<line>    &lt;collection title="Dr Zhivago" releaseYear="1965" /></line>
					<line>    &lt;collection title="Out of Africa" releaseYear="1985" /></line>
					<line>&lt;/ns2:movieLibrary></line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="requiredelements">
			<head>Required Elements</head>
			<summary>How to Require XML Elements</summary>
			<content>
				<explanation>By default, all XML elements in the generated schema are optional, unless the underlying Java type is a 
				built-in type that does not allow <idf>null</idf> (such as <idf>int</idf>, <idf>boolean</idf>...). If you a value is
				required in an element, you must declare this explicitly: 
				</explanation>
				<code>
					<line>public class Movie {</line>
					<line>    private String title;</line>
					<line>    private int releaseYear;</line>
					<emptyLine/>
					<line>    <em><javadoc>@XmlElement</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlElement.html#required()">required</javadoc>=true)</em></line>
					<line>    public String getTitle() {</line>
					<line>        return title;</line>
					<line>    }</line>
					<line>    public void setTitle(String title) {</line>
					<line>        this.title = title;</line>
					<line>    }</line>
					<emptyLine/>
					<line>    public <em>int</em> getReleaseYear() {<cmt><idf>int</idf> is always required <more>Built-in types (<idf>int</idf>, <idf>boolean</idf>,
					<idf>long</idf>, <idf>float</idf>...) are always required, as they can not be null. If you want to make the XML elements optional
					you must use the corresponding wrapper type (<idf>Integer</idf>, <idf>Boolean</idf>, <idf>Long</idf>, <idf>Float</idf>...).</more></cmt></line>
					<line>        return releaseYear;</line>
					<line>    }</line>
					<line>    public void setReleaseYear(int releaseYear) {</line>
					<line>        this.releaseYear = releaseYear;</line>
					<line>    }</line>
					<line>}</line>
				</code>
				<explanation>Resulting <topic>XML Schema</topic> fragment (the <idf>minOccurs</idf> attributes that made the elements optional have disappeared):
				</explanation>
				<code>
					<line>&lt;xs:complexType name="movie"></line>
					<line>    &lt;xs:sequence></line>
					<line>        &lt;xs:element name="releaseYear" type="xs:int"/></line>
					<line>        &lt;xs:element name="title" type="xs:string"/></line>
					<line>    &lt;/xs:sequence></line>
					<line>&lt;/xs:complexType></line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="elementnames">
			<head>Element Names</head>
			<summary>How to Specify a Different Name for an Element</summary>
			<content>
				<explanation>By default, JAXB uses the property name or field name as element name. If you don't want this, use
				an <javadoc>@XmlElement</javadoc> annotation with <idf>name</idf> parameter.
				</explanation>
				<code>
					<line>public class Movie {</line>
					<line>    <javadoc>@XmlElement</javadoc>(<em><javadoc to="javax/xml/bind/annotation/XmlElement.html#name()">name</javadoc>="movie-title")</em></line>
					<line>    public String title;</line>
					<line>    <javadoc>@XmlAttribute</javadoc>(<em><javadoc to="javax/xml/bind/annotation/XmlAttribute.html#name()">name</javadoc>="release-year")</em></line>
					<line>    public int releaseYear;</line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="preventingserialization">
			<head>Preventing Serialization</head>
			<summary>How to Prevent Serialization of Properties or Fields</summary>
			<content>
				<explanation>By default, JAXB will serialize all public fields and properties of a bean. However, you can control this
				behaviour using the <javadoc>@XmlAccessorType</javadoc> annotation at class or package level. Instead of the default 
				<javadoc to="javax/xml/bind/annotation/XmlAccessType.html#PUBLIC">XmlAccessType.PUBLIC</javadoc>	you can specify that only 
				properties (<javadoc to="javax/xml/bind/annotation/XmlAccessType.html#PROPERTY">XmlAccessType.PROPERTY</javadoc>), 
				fields (<javadoc to="javax/xml/bind/annotation/XmlAccessType.html#FIELD">XmlAccessType.FIELD</javadoc>) or 
				no members (<javadoc to="javax/xml/bind/annotation/XmlAccessType.html#NONE">XmlAccessType.NONE</javadoc>)
				are serialized without a explicit annotation. Then only <javadoc>@XmlElement</javadoc>-annotated 
				members will be written: 
				</explanation>
				<code>
					<line><em><javadoc>@XmlAccessorType</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlAccessType.html#NONE">XmlAccessType.NONE</javadoc>)</em></line>
					<line>public class Movie {</line>
					<line>    <em><javadoc>@XmlElement</javadoc></em></line>
					<line>    public String title;</line>
					<line>    <em><javadoc>@XmlElement</javadoc></em></line>
					<line>    public int releaseYear;</line>
					<line>    public String notWritten;<cmt>will not be serialized</cmt></line>
					<line>}</line>
				</code>
				
				<explanation>The serialization of specific members can also be prevented with the 
				<javadoc>@XmlTransient</javadoc> annotation, or (for fields)
				with the <idf>transient</idf> modifier:
				</explanation>
				<code>
					<line>public class Movie {</line>
					<line>    public String title;</line>
					<line>    public int releaseYear;</line>
					<emptyLine/>
					<line>    <em><javadoc>@XmlTransient</javadoc></em></line>
					<line>    public String notWritten1;<cmt>will not be serialized</cmt></line>
					<emptyLine/>
					<line>    public <em>transient</em> String notWritten2;<cmt>will not be serialized</cmt></line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="propertyorder">
			<head>Property Order</head>
			<summary>How to Specify an Order for Properties/Fields</summary>
			<content>
				<explanation>By default, the generated <topic>XML Schema</topic> for a bean require XML elements to have the same order
				that you defined your properties and fields in (using <idf>xs:sequence</idf>). Often this is not a good idea,
				because after refactoring the Java code may create a XML Schema incompatible with the old one. 
				Therefore a specific order can be defined with the 
				<javadoc to="javax/xml/bind/annotation/XmlType.html#propOrder()">propOrder</javadoc> parameter of the 
				<javadoc>@XmlType</javadoc> annotation:
				</explanation>
				<code>
					<line><em><javadoc>@XmlType</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlType.html#propOrder()">propOrder</javadoc>={"title", "releaseYear"})</em></line>
					<line>public class Movie {</line>
					<line>    public int releaseYear;</line>
					<line>    public String title;</line>
					<line>}</line>
				</code>
				<explanation>If you do not care about the element order at all, you can also specify an empty <javadoc to="javax/xml/bind/annotation/XmlType.html#propOrder()">propOrder</javadoc>
				sequence. The generated <topic>XML Schema</topic> will then use <idf>xs:all</idf> instead of <idf>xs:sequence</idf>, 
				meaning that the XML elements can appear in any order. But note that the resulting schema may be more difficult
				to read, for humans as well as computers:</explanation>
				<code>
					<line><em><javadoc>@XmlType</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlType.html#propOrder()">propOrder</javadoc>={})</em></line>
					<line>public class Movie {</line>
					<line>    public int releaseYear;</line>
					<line>    public String title;</line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
		
		
		<collapsedSubSection anchor="choice">
			<head>Choice Collection</head>
			<summary>How to Have Mixed XML Elements in a Single List (Choice)</summary>
			<content>
				<explanation>It is possible to put different XML elements in the same list. 
				Let's say you want to create a collection of values that can either be strings, numbers or a key/value pair of
				strings. This can be represented by the following schema:</explanation>
				<code>
					<line>&lt;xs:schema version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema"></line>
					<line>  &lt;xs:element name="values"></line>
					<line>    &lt;xs:complexType></line>
					<line>      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"></line>
					<line>        &lt;xs:element name="aString" type="xs:string"/></line>
					<line>        &lt;xs:element name="aNumber" type="xs:int"/></line>
					<line>        &lt;xs:element name="aKeyValuePair"></line>
					<line>          &lt;xs:complexType></line>
					<line>            &lt;xs:sequence/></line>
					<line>            &lt;xs:attribute name="key" type="xs:string"/></line>
					<line>            &lt;xs:attribute name="value" type="xs:string"/></line>
					<line>          &lt;/xs:complexType></line>
					<line>        &lt;/xs:element></line>
					<line>      &lt;/xs:choice></line>
					<line>    &lt;/xs:complexType></line>
					<line>  &lt;/xs:element></line>
					<line>&lt;/xs:schema></line>
				</code>
				<explanation>The problem here is that the <idf>aString</idf>, <idf>aNumber</idf> and <idf>aKeyValuePair</idf> elements
				do not have a common super-class. You can implement it in Java by using an <idf>Object</idf> collection and specifying
				all possible types that the collection may contain:</explanation>
				<code>
					<line><javadoc>@XmlRootElement</javadoc>(name="values")</line>
					<line><javadoc>@XmlType</javadoc>(name="")<cmt>anonymous (inline) type</cmt></line> 
					<line>public class Values {</line>
					<emptyLine/>
					<line>  <em><javadoc>@XmlElements</javadoc>({</em><cmt>declares the element choice</cmt></line>
					<line>    <em><javadoc>@XmlElement</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlElement.html#name()">name</javadoc>="aKeyValuePair", <javadoc to="javax/xml/bind/annotation/XmlElement.html#type()">type</javadoc>=Values.AKeyValuePair.class),</em></line>
					<line>    <em><javadoc>@XmlElement</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlElement.html#name()">name</javadoc>="aString", <javadoc to="javax/xml/bind/annotation/XmlElement.html#type()">type</javadoc>=String.class),</em></line>
					<line>    <em><javadoc>@XmlElement</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlElement.html#name()">name</javadoc>="empty")</em></line>
					<line>  <em>})</em></line> 
					<line>  public List&lt;Object> list = new new ArrayList&lt;Object>();</line>
					<emptyLine/>
					<line>  <javadoc>@XmlType</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlType.html#name()">name</javadoc>="")<cmt>anonymous (inline) type</cmt></line>
					<line>  public static class AKeyValuePair {</line>
					<line>    <javadoc>@XmlAttribute</javadoc></line>
					<line>    public String key;</line>
					<line>    <javadoc>@XmlAttribute</javadoc></line>
					<line>    public String value;</line>
					<line>  }</line>
					<line>}</line>
				</code>
			</content>
		</collapsedSubSection>
				
		<collapsedSubSection anchor="simpletypes">
			<head>Simple Types</head>
			<summary>How to Implement a Simple Type</summary>
			<content>
				<explanation><idf>Simple types</idf> are types that consist only of text, without any elements. Examples for 
				simple types are strings, numbers and dates.<br/>
				JAXB has the <javadoc>@XmlValue</javadoc> type to implement simple 
				types. To do this, you need to create a Java class to represent the type. Exactly one single property or field of the class
				must be annotated with the <javadoc>@XmlValue</javadoc> annotation. The property's (or field's) type must 
				always map to a simple type (such as a string or number). The following example implements the 
				class <idf>Price</idf> as simple type:</explanation>
				<code>
					<line><javadoc>@XmlRootElement</javadoc></line>
					<line>public class PriceList {</line>
					<line>	public List&lt;Price> prices;</line>
					<line>}</line>
					<emptyLine/>
					<line>public class Price {</line>
					<line>  <em><javadoc>@XmlValue</javadoc></em></line>
					<line>  public double amount;</line>
					<emptyLine/>
					<line>  public Price(double amount) {</line>
					<line>    this.amount = amount;</line>
					<line>  }</line>
					<emptyLine/>
					<line>  public Price() {</line>
					<line>  }</line>
					<line>}</line>
				</code>
				<explanation>Now the following marshalling code</explanation>
				<code>
					<line>PriceList priceList = new PriceList();</line>
					<line>priceList.prices = Arrays.asList(new Price(99.95), new Price(74.90));</line>
					<line><javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshal</javadoc>(priceList, System.out);</line>
				</code>
				<explanation>Note that will print this XML document:</explanation>
				<code>
					<line>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></line>
					<line>&lt;priceList></line>
    				<line>  <em>&lt;prices>99.95&lt;/prices></em></line>
    				<line>  <em>&lt;prices>74.9&lt;/prices></em></line>
					<line>&lt;/priceList></line>
				</code>
				<explanation>Note that there is no <idf>&lt;amount></idf> element in the resulting XML, only <idf>PriceList</idf>'s
				<idf>&lt;prices></idf> element.</explanation>
				
				<explanation>You can also combine a <javadoc>@XmlValue</javadoc> in a class with an <javadoc>@XmlAttribute</javadoc>.
				The following example shows you how to use it:</explanation>
				<code>
					<line>public class Price {</line>
					<line>  <javadoc>@XmlValue</javadoc></line>
					<line>  public double amount;</line>
					<emptyLine/>
					<line>  <em><javadoc>@XmlAttribute</javadoc></em></line>
					<line>  public String currency;</line>
					<emptyLine/>
					<line>  public Price(double amount, String currency) {</line>
					<line>    this.amount = amount;</line>
					<line>    this.currency = currency;</line>
					<line>  }</line>
					<emptyLine/>
					<line>  public Price() {</line>
					<line>  }</line>
					<line>}</line>
				</code>
				<explanation>Then the following code</explanation>
				<code>
					<line>PriceList priceList = new PriceList();</line>
					<line>priceList.prices = Arrays.asList(new Price(99.95, "US Dollar"), new Price(74.90, "Euro"));</line>
					<line><javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshal</javadoc>(priceList, System.out);</line>
				</code>
				<explanation>will print this XML document:</explanation>
				<code>
					<line>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></line>
					<line>&lt;priceList></line>
    				<line>  &lt;prices <em>currency="US Dollar"</em>>99.95&lt;/prices></line>
    				<line>  &lt;prices <em>currency="Euro"</em>>74.9&lt;/prices></line>
					<line>&lt;/priceList></line>
				</code>
				
				<explanation>Not every <javadoc>@XmlValue</javadoc> property needs to be backed by an actual
				field, of course. You can also use it to construct a simple typed value from several other values:</explanation>
				<code>
					<line>public class Price {</line>
					<line>  <em>private</em> double amount;</line>
					<line>  <em>private</em> String currency;</line>
					<emptyLine/>
					<line>  public Price(double amount, String currency) {</line>
					<line>    this.amount = amount;</line>
					<line>    this.currency = currency;</line>
					<line>  }</line>
					<emptyLine/>
					<line>  public Price() {</line>
					<line>  }</line>
					<emptyLine/>
					<line>  <em><javadoc>@XmlValue</javadoc></em></line>
					<line>  <em>public String getValue()</em> {</line>
					<line>    return amount + " " + currency;</line>
					<line>  }</line>
					<emptyLine/>
					<line>  <em>public void setValue(String v)</em> {<cmt>bad code, no error handling!</cmt></line>
					<line>    amount = Double.parseDouble(v.replaceFirst("\\s.*$", ""));</line>
					<line>    currency = v.replaceFirst("^.*\\s", "");</line>
					<line>  }</line>
					<line>}</line>
				</code>
				<explanation>When using the same content tree as in the previous example, the resulting XML
				will be:</explanation>
				<code>
					<line>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></line>
					<line>&lt;priceList></line>
    				<line>  &lt;prices><em>99.95 US Dollar</em>&lt;/prices></line>
    				<line>  &lt;prices><em>74.9 Euro</em>&lt;/prices></line>
					<line>&lt;/priceList></line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="xmladapter">
			<head>XML Adapter</head>
			<summary>How to Map Java Types to XML</summary>
			<content>
				<explanation>The <javadoc>XmlAdapter</javadoc> interface allows you to serialize any
				Java type to XML, by providing a <javadoc>XmlAdapter</javadoc> implementation that maps
				the arbitrary Java object to a JAXB supported object.<br/>
				For example, the following class is not JAXB-compatible because it lacks the 
				argument-less default constructor and its fields are <idf>final</idf>:</explanation>
				<code>
					<line>public class EMailAddress {<cmt>not JAXB-compatible</cmt></line>
					<line>  public final String user, hostname;</line>
					<emptyLine/>
					<line>  public EMailAddress(String user, String hostname) {</line>
					<line>    this.user = user;</line>
					<line>    this.hostname = hostname;</line>
					<line>  }</line>
					<line>}</line>
				</code>
				<explanation>The first step for mapping the <idf>EMailAddress</idf> class to XML is
				creating or finding a suitable JAXB-compatible type that can represent it. So let's define
				a bean <idf>XmlEMailAddress</idf> that can be serialized by JAXB:</explanation>
				<code>
					<line>public class XmlEMailAddress { <cmt>JAXB-compatible</cmt></line>
					<line>  public String user;</line>
					<line>  public String hostname;</line>
					<line>}</line>
				</code>
				<explanation>
				The next step is to implement the <idf>XmlAdapter</idf> and provide methods
				to convert between <idf>EMailAddress</idf> and <idf>XmlEMailAddress</idf>:
				</explanation>
				<code>
					<line>public class XmlEMailAddressAdapter <em>extends <javadoc>XmlAdapter</javadoc>&lt;XmlEMailAddress, EMailAddress></em> {</line>
					<line>  @Override</line>
					<line>  public <em>XmlEMailAddress marshal(EMailAddress v)</em> {</line>
					<line>    XmlEMailAddress a = new XmlEMailAddress();</line>
					<line>    a.user = v.user;</line>
					<line>    a.hostname = v.hostname;</line>
					<line>    return a;</line>
					<line>  }</line>
					<emptyLine/>
					<line>  @Override</line>
					<line>  public <em>EMailAddress unmarshal(XmlEMailAddress v)</em>{</line>
					<line>    return new EMailAddress(v.user, v.hostname);</line>
					<line>  }</line>
					<line>}</line>
				</code>
				<explanation>Now you only need to declare that the <javadoc package="javax.xml.bind.annotation.adapters">XmlAdapter</javadoc> should be used for
				<idf>EMailAddress</idf>. For this you need 
				the <javadoc package="javax.xml.bind.annotation.adapters">XmlJavaTypeAdapter</javadoc> annotation.
				It can be used at a property-level (to define the adapter only for this property or field),
				at the mapped class, or at the package level to define an adapter for the whole package.
				In this example, a class <idf>EMail</idf> is defined that uses the adapter only for a single
				property:</explanation>
				<code>
					<line><javadoc>@XmlRootElement</javadoc></line>
					<line>public class EMail {</line>
					<line>  <em><javadoc package="javax.xml.bind.annotation.adapters">@XmlJavaTypeAdapter</javadoc>(value=XmlEMailAddressAdapter.class)</em></line>
					<line>  public EMailAddress recipient;</line>
					<emptyLine/>
					<line>  public String body;</line>
					<line>}</line>
				</code>
				<explanation>Now <idf>EMail</idf> can be used like any other class:</explanation>
				<code>
					<line>EMail mail = new EMail();</line>
					<line>mail.recipient = <em>new EMailAddress("recipient", "example.com")</em>;</line>
					<line>mail.body = "Hello!";</line>
					<line><javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshal</javadoc>(mail, System.out);</line>
				</code>
				<explanation>This is the output of the last code fragment:</explanation>
				<code>
					<line>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></line>
					<line>&lt;eMail></line>
					<line>    <em>&lt;recipient></em></line>
					<line>        <em>&lt;user>recipient&lt;/user></em></line>
					<line>        <em>&lt;hostname>example.com&lt;/hostname></em></line>
					<line>    <em>&lt;/recipient></em></line>
					<line>    &lt;body>Hello!&lt;/body></line>
					<line>&lt;/eMail></line>
				</code>
				
				<explanation>An adapter can also map to a simple type such as a string.
				The following example shows an adapter that converts the <idf>EMail</idf>
				class into a string with the usual email notation:</explanation>
				<code>
					<line>public class XmlEMailAddressAdapter extends <javadoc>XmlAdapter</javadoc>&lt;<em>String</em>, EMailAddress> {</line>
					<line>  @Override</line>
					<line>  public String marshal(EMailAddress v) throws Exception {</line>
					<line>    return v.user + "@" + v.hostname;</line>
					<line>  }</line>
					<emptyLine/>
					<line>  @Override</line>
					<line>  public EMailAddress unmarshal(String v) throws Exception {</line>
					<line>    return new EMailAddress(v.replaceFirst("@.*$", ""), v.replaceFirst("^.*@", ""));</line>
					<line>  }</line>
					<line>}</line>
				</code>
				<explanation>When this is used as <javadoc>XmlAdapter</javadoc>, the following XML will be generated:</explanation>
				<code>
					<line>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?></line>
					<line>&lt;eMail></line>
					<line>    &lt;recipient><em>recipient@example.com</em>&lt;/recipient></line>
					<line>    &lt;body>Hello!&lt;/body></line>
					<line>&lt;/eMail></line>
				</code>
			</content>
		</collapsedSubSection>
				
		<collapsedSubSection anchor="jaxbelement">
			<head>JAXBElement</head>
			<summary>How to use JAXBElement</summary>
			<content>
				<explanation><javadoc>JAXBElement</javadoc> is used in JAXB where the 
				<topic>XML Schema</topic> can not be represented by a Java bean. You will often
				encounter it when compiling complex XML Schema documents with <annotated ref="doc-xjc"/>. Each <javadoc>JAXBElement</javadoc>
				corresponds to an XML element. It stores the element's tag name as well as its content. The 
				content of a <javadoc>JAXBElement</javadoc>
				can be any object supported by JAXB, beans or  simple types.<br/>
				The following example</explanation>
				<code>
					<line>Movie movieContent = new Movie("Casablanca", 1942);</line>
					<line><javadoc>JAXBElement</javadoc>&lt;Movie> myMovie = <em><javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, T)">new JAXBElement</javadoc>&lt;Movie>(new QName("myMovie"),</em></line>
					<line>                                           <em>Movie.class, movieContent)</em>;</line>
					<line><javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshal</javadoc>(myMovie, new File("/tmp/movie.xml"));</line>
				</code>
				<explanation>will create this XML:</explanation>
				<code>
					<line>&lt;<em>myMovie</em>></line> 
    				<line>  &lt;releaseYear>1942&lt;/releaseYear></line> 
					<line>  &lt;title>Casablanca&lt;/title></line> 
					<line>&lt;/<em>myMovie</em>></line> 
				</code>
				<explanation>Note that the tag name of the generated element is not <idf>Movie</idf>, but <idf>myMovie</idf>, as specified
				in the <javadoc>JAXBElement</javadoc>.</explanation>
							
				<miniHeadline>JAXBElement for Choice</miniHeadline>
				<explanation>Here is an example for a XML Schema that will need <javadoc>JAXBElement</javadoc>:</explanation>
				<code>
					<line>&lt;xs:schema version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema"></line>
					<line>  &lt;xs:element name="movieSoSoLibrary"></line>
					<line>    &lt;xs:complexType></line>
					<line>      &lt;xs:<em>choice</em> minOccurs="0" maxOccurs="unbounded"></line>
					<line>        &lt;xs:element <em>name="goodMovie" type="movie"</em> nillable="true"/></line>
					<line>        &lt;xs:element <em>name="badMovie" type="movie"</em> nillable="true"/></line>
					<line>      &lt;/xs:<em>choice</em>></line>
					<line>    &lt;/xs:complexType></line>
					<line>  &lt;/xs:element></line>
					<emptyLine/>
					<line>  &lt;xs:complexType name="movie"></line>
					<line>    &lt;xs:sequence></line>
					<line>      &lt;xs:element name="releaseYear" type="xs:int"/></line>
					<line>      &lt;xs:element name="title" type="xs:string"/></line>
					<line>    &lt;/xs:sequence></line>
					<line>  &lt;/xs:complexType></line>
					<line>&lt;/xs:schema></line>
				</code>
				<explanation>In this example, the tag names <idf>goodMovie</idf> and <idf>badMovie</idf> can both be used to
				represent the <idf>movie</idf> type. In order to differentiate a <idf>goodMovie</idf> from a <idf>badMovie</idf>, 
				even though both are represented by the <idf>Movie</idf> class, <annotated ref="doc-xjc"/> will create the following code:</explanation>
				<code>
					<line><javadoc>@XmlAccessorType</javadoc>(<javadoc to="javax/xml/bind/annotation/XmlAccessType.html#FIELD">XmlAccessType.FIELD</javadoc>)</line>
					<line><javadoc>@XmlType</javadoc>(name = "", propOrder = { "goodMovieOrBadMovie" })</line>
					<line><javadoc>@XmlRootElement</javadoc>(name = "movieSoSoLibrary")</line>
					<line>public class MovieSoSoLibrary {</line>
					<emptyLine/>
					<line>  <javadoc>@XmlElementRefs</javadoc>({</line>
					<line>    <em><javadoc>@XmlElementRef</javadoc>(name = "goodMovie", type = JAXBElement.class),</em></line>
					<line>    <em><javadoc>@XmlElementRef</javadoc>(name = "badMovie", type = JAXBElement.class)</em></line>
					<line>  })</line>
					<line>  protected <em>List&lt;<javadoc>JAXBElement</javadoc>&lt;Movie>> goodMovieOrBadMovie</em>;</line>
					<emptyLine/>
					<line>  public List&lt;<javadoc>JAXBElement</javadoc>&lt;Movie>> getGoodMovieOrBadMovie() {</line>
					<line>    if (goodMovieOrBadMovie == null) {</line>
					<line>      goodMovieOrBadMovie = new ArrayList&lt;<javadoc>JAXBElement</javadoc>&lt;Movie>>();</line>
					<line>    }</line>
					<line>  return this.goodMovieOrBadMovie;</line>
					<line>  }</line>
					<line>}</line>
				</code>
				<explanation>When <annotated ref="doc-xjc"/> generates such code, it places factory methods for the <javadoc>JAXBElement</javadoc>
				instances into a class called <idf>ObjectFactory</idf>. There you can find the following definitions for
				creating <idf>goodMovie</idf> and <idf>badMovie</idf> elements:</explanation>
				<code>
					<line><javadoc>@XmlElementDecl</javadoc>(namespace = "", name = "badMovie", scope = MovieSoSoLibrary.class)</line>
					<line>public <javadoc>JAXBElement</javadoc>&lt;Movie> createMovieSoSoLibraryBadMovie(Movie value) {</line>
					<line>  return <javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, java.lang.Class, T)">new JAXBElement</javadoc>&lt;Movie>(_MovieSoSoLibraryBadMovie_QNAME, </line>
					<line>                                   Movie.class, MovieSoSoLibrary.class, value);</line>
					<line>}</line>
					<emptyLine/>
					<line><javadoc>@XmlElementDecl</javadoc>(namespace = "", name = "goodMovie", scope = MovieSoSoLibrary.class)</line>
					<line>public <javadoc>JAXBElement</javadoc>&lt;Movie> createMovieSoSoLibraryGoodMovie(Movie value) {</line>
					<line>  return <javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, java.lang.Class, T)">new JAXBElement</javadoc>&lt;Movie>(_MovieSoSoLibraryGoodMovie_QNAME, </line>
					<line>                                   Movie.class, MovieSoSoLibrary.class, value);</line>
					<line>}</line>
				</code>
				<explanation>Note that the <javadoc>@XmlElementRef</javadoc> annotations in the <idf>MovieSoSoLibrary</idf> refer to the
				<javadoc>@XmlElementDecl</javadoc> annotations in <idf>ObjectFactory</idf>.</explanation>
			</content>
		</collapsedSubSection>
	</singleColumnSection>
	
	
	
	
	<singleColumnSection anchor="howtoserialization" multipage="true">
		<head>How to... Serialization</head>
		<collapsedSubSection anchor="jaxbcontext">
			<head>JAXBContext</head>
			<summary>How to Use JAXBContext</summary>
			<content>
				<explanation>
				<javadoc>JAXBContext</javadoc> represents a collection of JAXB-enabled classes. You create it with 
				either a list of JAXB-enabled classes, or using a 'context path' containing a list of colon-separated packages (read
				<javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.String, java.lang.ClassLoader)">newInstance(String,ClassLoader)</javadoc>
				for details). Once you have the <javadoc>JAXBContext</javadoc>, you can obtain <javadoc>Marshaller</javadoc> and 
				<javadoc>Unmarshaller</javadoc> objects from it, which will do the acutal serialization.<br/>
				When you use the methods <javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshal</javadoc> 
				and <javadoc to="javax/xml/bind/JAXB.html#unmarshal(java.io.File, java.lang.Class)">JAXB.unmarshall</javadoc> shown in the previous sections,
				you <em>don't need to take care of the <javadoc>JAXBContext</javadoc></em> yourself - it will all be done automatically.
				 <javadoc>JAXBContext</javadoc> is only needed when you want <em>to customize the serialization process</em>.
				</explanation>
				<miniHeadline>Creating JAXBContext by Class</miniHeadline>
				<explanation>
					This is a simplest way to create a <javadoc>JAXBContext</javadoc>. Note that not only the <idf>MovieLibrary</idf> class will be in the context, but also <em>all beans it refers to</em>: 
				</explanation>
				<code>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);</line>
				</code>
				<explanation> You can also add more classes:</explanation>
				<code>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class, Movie.class);</line>
				</code>
				<miniHeadline>Creating JAXBContext by Package</miniHeadline>
				<explanation>
					You can also generate the context for one or more packages, but <em>only if you generated them using <annotated ref="doc-xjc"/></em> 
					<more>Well, that's not entirely true. But creating the context by package works only if you either have an 
					<idf>ObjectFactory</idf> class, which is a helper class generated by , or a file called <idf>jaxb.index</idf> containing
					all class names. See the JavaDocs for details.<br/> 
					If you create the Java classes by hand, you usually don't have neither <idf>ObjectFactory</idf> nor <idf>jaxb.index</idf>, 
					and it does not make much sense to create those files manually instead of just listing the classes in the code. 
					So, effectively, creating the context by package is only a good option for <annotated ref="doc-xjc"/>-generated code.</more>. 
					Just list the package names, <em>separated by colons</em>:
				</explanation>
				<code>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.String, java.lang.ClassLoader)">JAXBContext.newInstance</javadoc>("com.jarfiller.example<em>:</em>com.jarfiller.xml");</line>
				</code>
				<explanation></explanation>					
			</content>
		</collapsedSubSection>
		<collapsedSubSection anchor="customizedserialization">
			<head>Marshaller / Unmarshaller</head>
			<summary>How to Customize the Serialization / use JAXB 2.0</summary>
			<content>
				<explanation>Using the methods <javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshal</javadoc> 
				and <javadoc to="javax/xml/bind/JAXB.html#unmarshal(java.io.File, java.lang.Class)">JAXB.unmarshall</javadoc>, as shown
				in the previous sections, is the most convenient way of using JAXB. Unfortunately, they do no allow any customization
				of the serialization and deserialization processes, and they are not available JAXB 2.0. In order to get around these limitations, you have to 
				work with the <javadoc>JAXBContext</javadoc>, <javadoc>Marshaller</javadoc> 
				and <javadoc>Unmarshaller</javadoc> objects. <br/>
				The following example shows you how to write a Java object into an XML document using <javadoc>Marshaller</javadoc>:</explanation>
				<code>
					<line>MovieLibrary library = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);<cmt>create <javadoc>JAXBContext</javadoc> <more>The 
<javadoc>JAXBContext</javadoc> represents the mapping between Java classes and XML. You can either specify one or more root classes (it supports
varargs) or the name of the package containing the mapping classes. <javadoc>JAXBContext</javadoc> is multi-thread safe and can be shared
among threads (note that you can not share <javadoc>Marshaller</javadoc> and 
<javadoc>Unmarshaller</javadoc>).</more></cmt></line>
					<line><javadoc>Marshaller</javadoc> marshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createMarshaller()">createMarshaller</javadoc>();</line>
					<line>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, java.io.OutputStream)">marshal</javadoc>(library, new FileOutputStream("/tmp/library.xml"));</line>
				</code>
				<explanation>Note that the example above only works if you declared the 
				<javadoc>@XmlRootElement</javadoc> for the <idf>MovieLibrary</idf>
				class. This shouldn't be a problem for classes you wrote yourself. However, the <annotated ref="doc-xjc"/> compiler does not set it automatically
				under some circumstances <more><idf>xjc</idf> does not set it if the root element is defined using a stand-alone complex type
				instead of an inline type. Then <idf>xjc</idf> can not be sure whether all uses of the complex type are really as root type, and thus it 
				can not write the <javadoc>@XmlRootElement</javadoc> annotation.</more>. In this case you must set the root element's name explicitly 
				and the <idf>marshal</idf> call looks like this:</explanation>
				<code>
					<line>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, java.io.OutputStream)">marshal</javadoc>(<em><javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, T)">new JAXBElement</javadoc>&lt;MovieLibrary>(new QName("movieLibrary"),</em> </line>
					<line>                                                    <em>MovieLibrary.class, library)</em>,</line> 
					<line>                   new FileOutputStream("/tmp/library.xml"));</line>
				</code>
				<explanation>Loading XML with the <javadoc>Unmarshaller</javadoc> is similar to storing: 
				</explanation>
				<code>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);<cmt>can be reused</cmt></line>
					<line><javadoc>Unmarshaller</javadoc> unmarshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createUnmarshaller()">createUnmarshaller</javadoc>();</line>
					<line>MovieLibrary library = unmarshaller.<javadoc to="javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.transform.Source, java.lang.Class)">unmarshal</javadoc>(<javadoc to="javax/xml/transform/stream/StreamSource.html#StreamSource(java.io.File)">new StreamSource</javadoc>(new File("/tmp/library.xml")),</line>
					<line>                                              MovieLibrary.class).<javadoc to="javax/xml/bind/JAXBElement.html#getValue()">getValue</javadoc>();</line>
				</code>
			</content>
		</collapsedSubSection>
		<collapsedSubSection anchor="schemavalidation">
			<head>Schema Validation</head>
			<summary>How to Validate Against an XML Schema</summary>
			<content>
				<explanation>A <topic>XML Schema</topic> allows more restrictions than Java's object model. For example,
				Java does not allow you to limit the length of a string. If you have a XML schema,
				you can let JAXB check the XML during the transformation process to be sure that the input and
				output is valid. First, you need to create a <javadoc package="javax.xml.validation">Schema</javadoc> instance 
				(<idf>javax.xml.validation</idf> package): </explanation>
				<code>
					<line><javadoc package="javax.xml.validation">SchemaFactory</javadoc> factory = <javadoc to="javax/xml/validation/SchemaFactory.html#newInstance(java.lang.String)">SchemaFactory.newInstance</javadoc>(<javadoc to="javax/xml/XMLConstants.html#W3C_XML_SCHEMA_NS_URI">XMLConstants.W3C_XML_SCHEMA_NS_URI</javadoc>);</line>
					<line><javadoc package="javax.xml.validation">Schema</javadoc> schema = factory.<javadoc to="javax/xml/validation/SchemaFactory.html#newSchema(javax.xml.transform.Source)">newSchema</javadoc>(<javadoc to="javax/xml/transform/stream/StreamSource.html#StreamSource(java.io.File)">new StreamSource</javadoc>(new File("schema1.xsd")));</line>
				</code>
				<explanation>Now that you have the <javadoc to="javax/xml/validation/Schema.html">Schema</javadoc>, just set the property in the <javadoc>Marshaller</javadoc> to 
				validate the generated XML:</explanation>
				<code>
					<line>MovieLibrary library = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);</line>
					<line><javadoc>Marshaller</javadoc> marshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createMarshaller()">createMarshaller</javadoc>();</line>
					<line><em>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#setSchema(javax.xml.validation.Schema)">setSchema</javadoc>(schema);</em></line>
					<line>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, java.io.OutputStream)">marshal</javadoc>(<javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, T)">new JAXBElement</javadoc>&lt;MovieLibrary>(new QName("movieLibrary"), </line>
					<line>                                                    MovieLibrary.class, library),</line> 
					<line>                   new FileOutputStream("/tmp/library.xml"));</line>
				</code>
				<explanation>To validate XML before you read it, set the <idf>schema</idf> property 
				in the <javadoc>Unmarshaller</javadoc>:</explanation>
					<code>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);<cmt>can be reused</cmt></line>
					<line><javadoc>Unmarshaller</javadoc> unmarshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createUnmarshaller()">createUnmarshaller</javadoc>();</line>
					<line><em>unmarshaller.<javadoc to="javax/xml/bind/Unmarshaller.html#setSchema(javax.xml.validation.Schema)">setSchema</javadoc>(schema);</em></line>
					<line>MovieLibrary library = unmarshaller.<javadoc to="javax/xml/bind/Unmarshaller.html#unmarshal(javax.xml.transform.Source, java.lang.Class)">unmarshal</javadoc>(<javadoc to="javax/xml/transform/stream/StreamSource.html#StreamSource(java.io.File)">new StreamSource</javadoc>(new File("/tmp/library.xml")),</line>
					<line>                                              MovieLibrary.class).<javadoc to="javax/xml/bind/JAXBElement.html#getValue()">getValue</javadoc>();</line>
				</code>
				<explanation>Reading or writing an invalid document causes JAXB to throw an exception.</explanation>
			</content>
		</collapsedSubSection>
		<collapsedSubSection anchor="prettyprinting">
			<head>Pretty Printing</head>
			<summary>How to Create Nicely Formatted XML</summary>
			<content>
				<explanation>By default, JAXB creates compact XML that can not easily be read by humans. If you want to
				format it more nicely, you need to set the <javadoc to="javax/xml/bind/Marshaller.html#JAXB_FORMATTED_OUTPUT">JAXB_FORMATTED_OUTPUT</javadoc> property of the 
				<javadoc>Marshaller</javadoc>:</explanation>
				<code>
					<line>MovieLibrary library = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);</line>
					<line><javadoc>Marshaller</javadoc> marshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createMarshaller()">createMarshaller</javadoc>();</line>
					<line><em>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#setProperty(java.lang.String, java.lang.Object)">setProperty</javadoc>(<javadoc to="javax/xml/bind/Marshaller.html#JAXB_FORMATTED_OUTPUT">Marshaller.JAXB_FORMATTED_OUTPUT</javadoc>, true);</em></line>
					<line>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, java.io.OutputStream)">marshal</javadoc>(<javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, T)">new JAXBElement</javadoc>&lt;MovieLibrary>(new QName("movieLibrary"), </line>
					<line>                                                    MovieLibrary.class, library),</line> 
					<line>                   new FileOutputStream("/tmp/library.xml"));</line>
				</code>
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="xmlfragments">
			<head>XML Fragments</head>
			<summary>How to Create XML Fragments</summary>
			<content>
				<explanation>If you want to create an XML fragment (a XML snippet without XML declaration that can be included
				into other XML documents) instead of a document, you need to set the <javadoc to="javax/xml/bind/Marshaller.html#JAXB_FRAGMENT">JAXB_FRAGMENT</javadoc> property of 
				the <javadoc>Marshaller</javadoc>:</explanation>
				<code>
					<line>MovieLibrary library = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);</line>
					<line><javadoc>Marshaller</javadoc> marshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createMarshaller()">createMarshaller</javadoc>();</line>
					<line><em>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#setProperty(java.lang.String, java.lang.Object)">setProperty</javadoc>(<javadoc to="javax/xml/bind/Marshaller.html#JAXB_FRAGMENT">Marshaller.JAXB_FRAGMENT</javadoc>, true);</em></line>
					<line>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, java.io.OutputStream)">marshal</javadoc>(<javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, T)">new JAXBElement</javadoc>&lt;MovieLibrary>(new QName("movieLibrary"), </line>
					<line>                                                    MovieLibrary.class, library),</line> 
					<line>                   new FileOutputStream("/tmp/library.xml"));</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="encoding">
			<head>Encoding</head>
			<summary>How to Change the Charset Encoding of the XML Output</summary>
			<content>
				<explanation>Sometimes you need to use a specific charset for the XML output instead the default UTF-8.
				You can use the <javadoc to="javax/xml/bind/Marshaller.html#JAXB_ENCODING">JAXB_ENCODING</javadoc>
				property of the <javadoc>Marshaller</javadoc> to set it:</explanation>
				<code>
					<line>MovieLibrary library = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);</line>
					<line><javadoc>Marshaller</javadoc> marshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createMarshaller()">createMarshaller</javadoc>();</line>
					<line><em>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#setProperty(java.lang.String, java.lang.Object)">setProperty</javadoc>(<javadoc to="javax/xml/bind/Marshaller.html#JAXB_ENCODING">Marshaller.JAXB_ENCODING</javadoc>, "iso-8859-15");</em></line>
					<line>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, java.io.OutputStream)">marshal</javadoc>(<javadoc to="javax/xml/bind/JAXBElement.html#JAXBElement(javax.xml.namespace.QName, java.lang.Class, T)">new JAXBElement</javadoc>&lt;MovieLibrary>(new QName("movieLibrary"), </line>
					<line>                                                    MovieLibrary.class, library),</line> 
					<line>                   new FileOutputStream("/tmp/library.xml"));</line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="consumer">
			<head>Consumer</head>
			<summary>How to Send the Content Tree to a DOM/SAX Consumer</summary>
			<content>
				<explanation>The <javadoc>Marshaller</javadoc> interface provides several ways of interoperating with
				code that expects XML as a DOM tree or is implemented as SAX <idf>ContentHandler</idf>.
				</explanation>
				<code>
					<line>MovieLibrary library = new MovieLibrary();</line>
					<line><javadoc>Marshaller</javadoc> m = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line>// Writing into a DOM tree</line>
					<line>Document doc = ...;<cmt>DOM Document</cmt></line>
					<line><em><javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, org.w3c.dom.Node)">m.marshal</javadoc>(library, doc)</em>;<cmt>write into the given DOM node</cmt></line>
					<emptyLine/>
					<line>// Writing to a SAX ContentHandler</line>
					<line>ContentHandler handler = ...;</line>
					<line><em><javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, org.xml.sax.ContentHandler)">marshal</javadoc>(library, handler);</em><cmt>write into ContentHandler</cmt></line>
				</code>
				<explanation>In addition to the <idf>marshal</idf> variants, there is also the optional operation
				<javadoc to="javax/xml/bind/Marshaller.html#getNode(java.lang.Object)">getNode</javadoc>, which would return
				a live DOM tree corrensponding to the JAXB content tree. Java's default implemention does not
				support this operation though.</explanation>
			</content>
		</collapsedSubSection>

		<collapsedSubSection anchor="domtree">
			<head>DOM Tree</head>
			<summary>How to Read from a DOM Tree</summary>
			<content>
				<explanation>The <javadoc>Unmarshaller</javadoc> interface provides a variant of the 
				<idf>unmarshall</idf> method that reads a DOM <idf>Node</idf>.
				</explanation>
				<code>
					<line>Node node = <abstract>...</abstract>;</line>
					<line><javadoc>Unmarshaller</javadoc> m = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line>MovieLibrary library = (MovieLibrary) <em>m.<javadoc to="javax/xml/bind/Unmarshaller.html#unmarshal(org.w3c.dom.Node)">unmarshal</javadoc>(node)</em>;<cmt>read from DOM node</cmt></line>
				</code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="stringreading">
			<head>String Reading</head>
			<summary>How to Read from a String</summary>
			<content>
			    <explanation><idf>JAXB</idf> allows you to read from a <javadoc package="java.io">Reader</javadoc>, which can easily
			    be used to read from a String:</explanation>
			    <code>
			        <line>String xml = "&lt;movieLibrary>&lt;collection>"+</line>
			        <line>             "&lt;name>Up&lt;/name>&lt;releaseYear>2009&lt;/releaseYear>"+</line>
			        <line>             "&lt;/collection>&lt;/movieLibrary>";</line>
			        <emptyLine/>
			        <line><em><javadoc package="java.io">StringReader</javadoc> reader = new <javadoc to="java/io/StringReader.html#StringReader(java.lang.String)">StringReader</javadoc>(xml)</em>;</line>
			        <line>MovieLibrary lib = <javadoc to="javax/xml/bind/JAXB.html#unmarshal(java.io.Reader, java.lang.Class)">JAXB.unmarshall</javadoc>(<em>reader</em>, MovieLibrary.class);</line>
			    </code>
			    <explanation>Note that JAXB will ignore any character encoding set in the <annotated ref="doc-xml-prolog"/>.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="stringwriting">
			<head>String Writing</head>
			<summary>How to Serialize XML Into a String</summary>
			<content>
			    <explanation>In general, it is <em>not recommended to serialize XML into a String</em>. XML is defined as a <em>binary format</em>,
			        and ideally you should write handle it as such. When storing an 'XML string' you need to be aware
			        of the character encoding defined in the <annotated id="doc-xml-prolog"><title>XML prolog</title>
			        <explanation>The prolog is the optional first line of a XML file, and looks like "&lt;?xml bla bla bla?>". Most importantly,
			        it defines the XML version ("version") and the character encoding ("encoding") of the file.<br/>
			        If a document has no prolog, the character encoding is either UTF-8 or UTF-16. The processor will detect the
			        encoding by inspecting the document's first four bytes.</explanation></annotated>. If you write your 'XML string' in
			        the wrong encoding you will run into trouble.</explanation>
			    <explanation>Now, after the obligatory warning, it is possible and actually quite easy to write your JAXB tree into an 'XML string':
			    </explanation>
			    <code>
			        <line>MovieLibrary ml = <abstract>...</abstract>;</line>
			        <emptyLine/>
			        <line><javadoc package="java.io">StringWriter</javadoc> writer = new <javadoc to="java/io/StringWriter.html#StringWriter()">StringWriter</javadoc>();</line>
			        <line><javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshall</javadoc>(ml, <em>writer</em>);</line>
			        <line>String <em>xmlText = writer.<javadoc to="java/io/StringWriter.html#toString()">toString</javadoc>()</em>;</line>
			    </code>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="xpath">
			<head>XPath</head>
			<summary>How to Use XPath on JAXB Content Trees</summary>
			<content>
				<explanation>Java's <topic>XPath</topic> engine is not able to use JAXB content trees directly. You either need to convert it to
				a DOM tree or to a binary XML document first. The following example shows you how to use DOM for running XPath:</explanation>
				<code>
					<line>MovieLibrary library = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);</line>
					<line><javadoc>Marshaller</javadoc> marshaller = ctx.<javadoc to="javax/xml/bind/JAXBContext.html#createMarshaller()">createMarshaller</javadoc>();</line>
					<emptyLine/>
					<line><javadoc package="javax.xml.parsers">DocumentBuilderFactory</javadoc> domFactory = <javadoc to="javax/xml/parsers/DocumentBuilderFactory.html#newInstance()">DocumentBuilderFactory.newInstance</javadoc>();</line>
					<line><javadoc package="javax.xml.parsers">DocumentBuilder</javadoc> domBuilder = domFactory.<javadoc to="javax/xml/parsers/DocumentBuilderFactory.html#newDocumentBuilder()">newDocumentBuilder</javadoc>();</line>
					<line><javadoc package="org.w3c.dom">Document</javadoc> doc = domBuilder.<javadoc to="javax/xml/parsers/DocumentBuilder.html#newDocument()">newDocument</javadoc>();</line>
					<line><em>marshaller.<javadoc to="javax/xml/bind/Marshaller.html#marshal(java.lang.Object, org.w3c.dom.Node)">marshal</javadoc>(library, doc)</em>;</line>
					<emptyLine/>
					<line><javadoc package="javax.xml.xpath">XPathFactory</javadoc> factory = <javadoc to="javax/xml/xpath/XPathFactory.html#newInstance()">XPathFactory.newInstance</javadoc>();</line>
					<line><javadoc package="javax.xml.xpath">XPath</javadoc> xpath = factory.<javadoc to="javax/xml/xpath/XPathFactory.html#newXPath()">newXPath</javadoc>();</line>
					<emptyLine/>
					<line><javadoc package="org.w3c.dom">NodeList</javadoc> list = (<javadoc package="org.w3c.dom">NodeList</javadoc>) <em>xpath.<javadoc to="javax/xml/xpath/XPath.html#evaluate(java.lang.String, java.lang.Object, javax.xml.namespace.QName)">evaluate</javadoc>(</em></line>
					<line>          <em>"/movieLibrary/collection[releaseYear &lt; 1980]/title",</em></line>
					<line>          <em>doc, <javadoc to="javax/xml/xpath/XPathConstants.html#NODESET">XPathConstants.NODESET</javadoc>)</em>;</line>
					<line>for (int i = 0; i &lt; list.<javadoc to="org/w3c/dom/NodeList.html#getLength()">getLength</javadoc>(); i++)<cmt>print list of movies older than 1980</cmt></line>
					<line>  System.out.println(list.<javadoc to="org/w3c/dom/NodeList.html#item(int)">item</javadoc>(i).<javadoc to="org/w3c/dom/Node.html#getTextContent()">getTextContent</javadoc>());</line>
				</code>
				<explanation>An alternative for running 'real' XPath expressions over the XML is to use 
				<link to="http://commons.apache.org/jxpath/">JXPath</link>, which allows you to run XPath expressions over
				Java object trees.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="xslt">
			<head>XSLT</head>
			<summary>How to Use JAXB with XSLT</summary>
			<content>
				<explanation>Java's <topic>XSLT</topic> framework (TrAX) can use JAXB content trees as input or output of XSLT transformations.
				You can find the required helper classes <javadoc package="javax.xml.bind.util">JAXBSource</javadoc> and 
				<javadoc package="javax.xml.bind.util">JAXBResult</javadoc> in the <idf>javax.xml.bind.util</idf> package.<br/>
				The following example transforms a <idf>MovieLibrary</idf> document to another <idf>MovieLibrary</idf> using a XSLT
				file:</explanation>
				<code>
					<line>MovieLibrary library = <abstract>...</abstract>;</line>
					<emptyLine/>
					<line><javadoc>JAXBContext</javadoc> ctx = <javadoc to="javax/xml/bind/JAXBContext.html#newInstance(java.lang.Class...)">JAXBContext.newInstance</javadoc>(MovieLibrary.class);</line>
					<line><javadoc>JAXBSource</javadoc> src = <em><javadoc to="javax/xml/bind/util/JAXBSource.html#JAXBSource(javax.xml.bind.JAXBContext, java.lang.Object)">new JAXBSource</javadoc>(ctx, library)</em>;</line>
					<line><javadoc>JAXBResult result</javadoc> = <em><javadoc to="javax/xml/bind/util/JAXBResult.html#JAXBResult(javax.xml.bind.JAXBContext)">new JAXBResult</javadoc>(ctx)</em>;</line>
					<emptyLine/>
					<line><javadoc package="javax.xml.transform">TransformerFactory</javadoc> factory = <javadoc to="javax/xml/transform/TransformerFactory.html#newInstance()">TransformerFactory.newInstance</javadoc>();</line>
					<line><javadoc package="javax.xml.transform">Transformer</javadoc> transformer = factory.<javadoc to="javax/xml/transform/TransformerFactory.html#newTransformer()">newTransformer</javadoc>(<javadoc to="javax/xml/transform/stream/StreamSource.html#StreamSource(java.io.File)">new StreamSource</javadoc>(new File("myTemplate.xslt")));</line>
					<line><em>transformer.<javadoc to="javax/xml/transform/Transformer.html#transform(javax.xml.transform.Source, javax.xml.transform.Result)">transform</javadoc>(src, result)</em>;</line>
					<emptyLine/>
					<line>MovieLibrary modifiedLibrary = (MovieLibrary) <em>result.<javadoc to="javax/xml/bind/util/JAXBResult.html#getResult()">getResult</javadoc>()</em>;</line>
				</code>
				<explanation>Using <javadoc package="javax.xml.bind.util">JAXBSource</javadoc> it is also possible to provide the stylesheet itself
				as JAXB content tree.</explanation>
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="performance">
			<head>Performance</head>
			<summary>How to Improve Performance</summary>
			<content>
				<explanation>Consider the following things:</explanation>
				<list><li>The static helper methods in the <javadoc>JAXB</javadoc> class (<javadoc to="javax/xml/bind/JAXB.html#marshal(java.lang.Object, java.io.Writer)">JAXB.marshal</javadoc> 
				and <javadoc to="javax/xml/bind/JAXB.html#unmarshal(java.io.File, java.lang.Class)">JAXB.unmarshall</javadoc>) should be 
				avoided if you need to invoke them repeatedly. 
				Instead, create a <javadoc>JAXBContext</javadoc> instance once and work with
				the <javadoc>Marshaller</javadoc> and 
				<javadoc>Unmarshaller</javadoc> interfaces.</li>
				<li>Make sure you have only a single <javadoc>JAXBContext</javadoc> instance 
				and share it across objects and threads.</li>
				<li>Don't use schema validation (if possible).</li> 
				<li>Check that you use the best source or destination for the serialization/deserialization process. For example,
				if you want to transmit XML over the net, write it directly into the connection's <idf>OutputStream</idf>. Try to avoid
				temporary storage of the XML using ByteArray streams or in DOM trees.</li>
				<li>If the document contains binary data, use a XOP transport if possible.</li>
				<li>If you are sure you can't reach your performance target using JAXB, switch to the 
				<javadoc to="javax/xml/stream/XMLStreamReader.html">XMLStreamReader</javadoc>/<javadoc to="javax/xml/stream/XMLStreamWriter.html">XMLStreamWriter</javadoc> interfaces 
				(StAX API) for those parts that are 
				too slow. Note that using this low-level API can be a lot more work than using JAXB, and getting the code to work right in all possible situations
				(e.g. comments in the middle of an XML text) is even more difficult.</li>
				</list>
				
			</content>
		</collapsedSubSection>
		
		<collapsedSubSection anchor="multithreading">
			<head>Multithreading</head>
			<summary>How to Write Thread-safe Code with JAXB</summary>
			<content>
				<explanation>The rules for JAXB in a multi-threaded environment are very simple: you can share the 
				<javadoc>JAXBContext</javadoc> object among threads. Doing so will also improve performance, as the construction
				of the context may be expensive. All other objects, including <javadoc>Marshaller</javadoc> 
				and <javadoc>Unmarshaller</javadoc>,
				are not thread-safe and must not be shared. The static helper methods in the <javadoc>JAXB</javadoc> class can be
				used from several threads, of course.<br/>
				In practice, this means that if you need a <javadoc>JAXBContext</javadoc> instance, 
				you should probably store in a static member.</explanation>
			</content>
		</collapsedSubSection>
	</singleColumnSection>
  </body>
  <sidebar>
  	<box>
  		<title>Useful Links</title>
  		<content>
  			<link to="http://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding">JAXB on Wikipedia</link><br/>
  			<link to="https://jaxb.dev.java.net/">JAXB Reference Implementation (Metro)</link><br/>
  			<link to="http://jcp.org/en/jsr/detail?id=222">JSR-222 (JAXB)</link><br/>
  			<link to="http://java.sun.com/javase/6/docs/api/javax/xml/bind/package-summary.html">Java 6 API javax.xml.bind</link>
  		</content>
  	</box>
  </sidebar>
  </article>
</page>
